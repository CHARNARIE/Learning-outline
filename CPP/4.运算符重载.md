# 友元

友元(friend)是C++中的一种特殊机制，它允许一个类将对其非公有成员(private和protected)的访问权授予指定的函数或类。友元打破了类的封装性，但提供了更高的灵活性和运行效率。

友元分为三种类型：
1. 友元函数
2. 友元类
3. 友元成员函数

## 友元函数

友元函数是定义在类外部，但有权访问类的所有私有(private)成员和保护(protected)成员的非成员函数。

在类中声明友元函数的语法如下：

```cpp
class ClassName {
    // 可以在任何访问修饰符下声明
    friend 返回类型 函数名(参数列表);
};

// 类外定义友元函数（不需要friend关键字）
返回类型 函数名(参数列表) {
    // 函数体
}
```

```cpp
#include <iostream>
#include <cmath>
using namespace std;

class Point {
private:
    double x, y;

public:
    Point(double xx, double yy) { x = xx; y = yy; }
    void Getxy() {
        cout << "(" << x << "," << y << ")" << endl;
    }
    
    // 声明友元函数
    friend double Distance(Point &a, Point &b);
};

// 定义友元函数
double Distance(Point &a, Point &b) {
    double dx = a.x - b.x; // 可以直接访问私有成员
    double dy = a.y - b.y;
    return sqrt(dx*dx + dy*dy);
}

int main() {
    Point p1(3.0, 4.0), p2(6.0, 8.0);
    p1.Getxy();
    p2.Getxy();
    double d = Distance(p1, p2); // 调用友元函数
    cout << "Distance is " << d << endl;
    return 0;
}
```

## 友元类

友元类是指一个类可以访问另一个类的所有成员（包括私有成员和保护成员）的类。当一个类被声明为另一个类的友元时，这个类的所有成员函数都成为另一个类的友元函数。

```cpp
class ClassA {
    // 声明ClassB为友元类
    friend class ClassB;

private:
    int data;
};

class ClassB {
public:
    void func(ClassA &a) {
        // 可以访问ClassA的私有成员
        a.data = 100;
    }
};
```

```cpp
#include <iostream>
using namespace std;

class CCar; // 前向声明

class CDriver {
public:
    void ModifyCar(CCar *pCar); // 改装汽车
};

class CCar {
private:
    int price;
    
    // 声明CDriver为友元类
    friend class CDriver;
};

void CDriver::ModifyCar(CCar *pCar) {
    pCar->price += 1000; // 可以访问CCar的私有成员
    cout << "Car price after modification: " << pCar->price << endl;
}

int main() {
    CCar car;
    CDriver driver;
    
    // 通过友元类访问私有成员
    driver.ModifyCar(&car);
    
    return 0;
}
```

## 友元成员函数

友元成员函数是指将一个类的某个成员函数声明为另一个类的友元，使该成员函数可以访问另一个类的私有成员。

```cpp
#include <iostream>
using namespace std;

class A; // 前向声明

class B {
public:
    void set_show(int x, A &a); // 该函数将成为类A的友元函数
};

class A {
public:
    // 声明B类的set_show方法为友元
    friend void B::set_show(int x, A &a);
    
private:
    int data;
};

// 定义B类的set_show方法
void B::set_show(int x, A &a) {
    a.data = x; // 可以访问A的私有成员
    cout << "A's data: " << a.data << endl;
}

int main() {
    A a;
    B b;
    
    b.set_show(100, a);
    
    return 0;
}
```

## 友元的使用场景

**1. 运算符重载**

当需要重载某些运算符（如`<<`、`>>`等）时，这些运算符通常需要访问类的私有成员，此时可以将它们声明为友元函数。

```cpp
class Complex {
private:
    double real, imag;
    
public:
    Complex(double r = 0, double i = 0) : real(r), imag(i) {}
    
    // 声明重载的<<运算符为友元
    friend ostream& operator<<(ostream& os, const Complex& c);
};

// 重载<<运算符
ostream& operator<<(ostream& os, const Complex& c) {
    os << c.real << "+" << c.imag << "i"; // 访问私有成员
    return os;
}
```

**2. 需要访问多个类的私有成员**

当一个函数需要同时访问多个类的私有成员时，可以将该函数声明为这些类的友元。

**3. 提高性能**

在某些情况下，特别是在对某些成员函数多次调用时，由于参数传递、类型检查和安全性检查等都需要时间开销，使用友元可以提高程序的运行效率。

**4. 辅助类和工具类**

当设计辅助类或工具类来操作主类的内部数据时，可以将辅助类声明为主类的友元。

## 友元的特性

1. **友元关系不能被继承**：如果类B是类A的友元，类C继承自类B，类C不会自动成为类A的友元。

2. **友元关系是单向的**：如果类B是类A的友元，类A不一定是类B的友元，除非有明确声明。

3. **友元关系不具有传递性**：如果类B是类A的友元，类C是类B的友元，类C不会自动成为类A的友元。

4. **友元声明位置**：友元声明可以出现在类中的任何地方（private、protected或public部分），不受访问控制影响。

**优点**

1. **提高程序运行效率**：减少了类型检查和安全性检查等时间开销。

2. **增加灵活性**：使程序可以在封装和快速性方面做合理选择。

3. **便于实现需要访问多个类私有成员的功能**：可以灵活地实现需要访问若干类的私有或受保护成员才能完成的任务。

4. **便于与非面向对象语言混合编程**：便于与其他不支持类概念的语言(如C语言、汇编等)进行混合编程。

**缺点**

1. **破坏封装性**：友元机制破坏了类的封装性和数据隐藏性，使得非成员函数可以访问类的私有成员。

2. **降低可维护性**：过度使用友元会使代码结构变得复杂，难以维护。

3. **增加耦合性**：友元增加了类之间的耦合度，不利于代码的模块化。

> [!tip]
>
> 1. **谨慎使用**：为了确保数据的完整性以及数据封装与隐藏的原则，建议尽量不使用或少使用友元。
>
> 2. **合理场景**：在需要提高性能、实现运算符重载或需要访问多个类私有成员的情况下，可以考虑使用友元。
>
> 3. **友元声明位置**：通常，将友元声明成组地放在类定义的开始或结尾是个好主意，以便于代码阅读和维护。
>
> 4. **避免过度使用**：过度使用友元会使代码难以理解和维护，应该在确实需要的情况下才使用。

# 运算符重载

## +运算符重载

加号(+)是一个典型的双目运算符，需要两个操作数：一个在加号前，一个在加号后。在C++中，我们可以通过两种方式实现+运算符的重载： 

1. 类成员函数方式
2. 全局函数方式

**通过类成员函数实现+运算符重载**

当使用类成员函数实现+运算符重载时，函数原型如下：

```cpp
Class_Name operator+(const Class_Name& other);
```

这种方式下，左操作数是调用该成员函数的对象(this)，右操作数作为参数传入。

```cpp
#include <iostream>
using namespace std;

class Person {
public:
    Person();
    Person(int val);
    Person operator+(const Person& p); // 运算符重载函数声明
private:
    int m_age;
};

int main() {
    Person p1;
    Person p2;
    Person p3 = p1 + p2; // 重载后的效果
    return 0;
}

Person::Person() :m_age(10) {
    cout << "无参构造函数" << endl;
}

Person::Person(int val) : m_age(val) {
    cout << "有参构造函数" << endl;
}

Person Person::operator+(const Person& p) { // 运算符重载实现
    Person tmp;
    tmp.m_age = this->m_age + p.m_age;
    return tmp;
}
```
在上面的例子中，执行`p1 + p2`时，实际上调用的是`p1.operator+(p2)`，返回一个新的Person对象，其m_age值为p1和p2的m_age之和。

**通过全局函数实现+运算符重载**

全局函数方式的运算符重载函数原型如下：

```cpp
Class_Name operator+(const Class_Name& left, const Class_Name& right);
```

这种方式下，左右操作数都作为参数传入函数。

```cpp
#include <iostream>
using namespace std;

class xiMeng {
public:
    int M_A;
    int M_B;
    // 这里不使用成员函数重载
};

// 通过全局函数实现运算符重载
xiMeng operator+(xiMeng& p1, xiMeng& p2) {
    xiMeng temp;
    temp.M_A = p1.M_A + p2.M_A;
    temp.M_B = p1.M_B + p2.M_B;
    return temp;
}

// 运算符重载也可以发生函数重载
xiMeng operator+(xiMeng& p, int num) {
    xiMeng temp;
    temp.M_A = p.M_A + num;
    temp.M_B = p.M_B + num;
    return temp;
}
```
> [!tip]
>
> 1. **成员函数方式**：
>    - 左操作数必须是类的对象
>    - 可以访问类的私有成员
>    - 适合当左操作数必须是该类对象的情况
>
> 2. **全局函数方式**：
>    - 左右操作数可以是不同类型
>    - 需要访问私有成员时，可以将函数声明为友元
>    - 适合需要支持交换律的情况（如 a+b = b+a）
>    - 适合左操作数不是该类对象的情况（如 5 + obj）

> [!note]
>
> 1. 不能改变运算符的优先级和结合性
> 2. 不能改变运算符的操作数个数
> 3. 至少有一个操作数是用户定义的类型
> 4. 不能创建新的运算符
> 5. 某些运算符不能被重载（如 :: 、. 、.* 、?: 等）   

## +=运算符重载

重载`+=`运算符的基本语法是：

```cpp
returnType operator+=(const ParameterType& param);
```

**作为类成员函数**

作为成员函数重载`+=`运算符时，左操作数隐式地是当前对象（`this`指针），右操作数作为参数传入。

```cpp
class MyClass {
private:
    int value;

public:
    MyClass(int val) : value(val) {}
    
    // 重载 += 运算符作为成员函数
    MyClass& operator+=(const MyClass& other) {
        this->value += other.value;
        return *this;
    }
    
    // 也可以重载不同类型的参数
    MyClass& operator+=(int num) {
        this->value += num;
        return *this;
    }
    
    int getValue() const {
        return value;
    }
};
```

**作为友元函数**

虽然`+=`运算符通常作为成员函数实现，但在某些情况下也可以作为友元函数实现：

```cpp
class MyClass {
private:
    int value;

public:
    MyClass(int val) : value(val) {}
    
    friend MyClass& operator+=(MyClass& left, const MyClass& right);
    
    int getValue() const {
        return value;
    }
};

// 作为友元函数实现 += 运算符
MyClass& operator+=(MyClass& left, const MyClass& right) {
    left.value += right.value;
    return left;
}
```

> [!note]
>
> 1. `+=`运算符重载函数通常返回对象的引用（`&`），这样可以支持连续操作，如`a += b += c`。
>
> 2. 重载`+=`运算符时，应该考虑同时重载`+`运算符，保持一致性。
>
> 3. 对于自定义类，重载`+=`运算符可以提高代码的可读性和直观性。
>
> 4. 返回引用类型可以避免创建不必要的临时对象，提高性能。

```cpp
#include <iostream>
using namespace std;

class Complex {
private:
    double real;
    double imag;

public:
    Complex(double r = 0, double i = 0) : real(r), imag(i) {}
    
    // 重载 += 运算符
    Complex& operator+=(const Complex& other) {
        this->real += other.real;
        this->imag += other.imag;
        return *this;
    }
    
    // 显示复数
    void display() const {
        cout << real << " + " << imag << "i" << endl;
    }
};

int main() {
    Complex c1(3.0, 4.0);
    Complex c2(1.5, 2.5);
    
    cout << "c1 = ";
    c1.display();
    
    cout << "c2 = ";
    c2.display();
    
    // 使用重载的 += 运算符
    c1 += c2;
    
    cout << "c1 += c2 的结果: ";
    c1.display();
    
    return 0;
}
```

运行结果：
```
c1 = 3 + 4i
c2 = 1.5 + 2.5i
c1 += c2 的结果: 4.5 + 6.5i         
```

## ++运算符重载

++运算符有两种形式：前置++（如`++a`）和后置++（如`a++`）。这两种形式在行为和实现上有明显区别。

1. **前置++**：先增加变量的值，然后返回增加后的变量
2. **后置++**：先返回变量的当前值，然后再增加变量的值

C++通过函数参数来区分前置和后置++运算符重载

- **前置++**：`T& operator++()`，返回对象的引用（`T&`），这样可以支持连续操作，如`++(++a)`
- **后置++**：`T operator++(int)` - 这里的`int`参数是一个哑参数，仅用于区分后置版本，返回对象的值（`T`），通常是修改前的对象副本

```cpp
#include <iostream>
using namespace std;

class Age {
private:
    int years;

public:
    // 构造函数
    Age(int age = 0) : years(age) {}
    
    // 前置++运算符重载
    Age& operator++() {
        // 先增加值
        ++years;
        // 返回增加后的对象引用
        return *this;
    }
    
    // 后置++运算符重载
    Age operator++(int) {
        // 保存当前状态
        Age temp = *this;
        // 增加值
        years++;
        // 返回原始值（修改前的副本）
        return temp;
    }
    
    // 用于输出的友元函数
    friend ostream& operator<<(ostream& os, const Age& obj) {
        os << "Age: " << obj.years;
        return os;
    }
};

int main() {
    Age age(25);
    
    // 测试后置++
    cout << "原始年龄: " << age << endl;
    Age oldAge = age++;
    cout << "后置++后: " << age << endl;
    cout << "后置++返回: " << oldAge << endl;
    
    // 测试前置++
    cout << "\n当前年龄: " << age << endl;
    Age& newAge = ++age;
    cout << "前置++后: " << age << endl;
    cout << "前置++返回: " << newAge << endl;
    
    // 验证前置++返回的引用
    ++age = Age(30);
    cout << "\n赋值后: " << age << endl;
    
    return 0;
}
```

前置++通常比后置++更高效 ，因为：

1. **前置++**：
   - 直接修改对象
   - 返回对象引用
   - 无需创建临时对象

2. **后置++**：
   - 需要创建临时对象保存原始状态
   - 修改对象
   - 返回临时对象

对于简单的内置类型（如int），性能差异很小。但对于复杂的用户定义类型，前置++的性能优势更为明显。

> [!tip]
>
> 1. 同时实现前置和后置版本以保持一致性
> 2. 优先使用前置++，特别是对于迭代器和复杂对象
> 3. 前置++返回引用，后置++返回值
> 4. 后置++的实现应该调用前置++，以避免代码重复

> [!note]
>
> 1. 前置++：`T& operator++()`，先增加再返回引用
> 2. 后置++：`T operator++(int)`，先返回副本再增加


## []运算符重载

`[]` 运算符（下标运算符）是 C++ 中常用的运算符之一，它允许我们像访问数组元素一样访问自定义类型的对象。通过重载 `[]` 运算符，我们可以为自定义类实现类似数组的访问语法，使代码更加直观和易于理解。

`[]` 运算符重载的基本语法如下：

```cpp
返回类型 operator[](参数类型 参数名);
```

具体来说，有两种常见的形式：

```cpp
// 非 const 版本，允许修改元素
返回类型& operator[](参数类型 参数名);

// const 版本，不允许修改元素
const 返回类型& operator[](参数类型 参数名) const;
```

> [!note]
>
> 1. **必须是成员函数**：`[]` 运算符重载必须定义为类的成员函数，不能是全局函数。
>
> 2. **通常返回引用**：为了支持赋值操作（如 `obj[i] = value`），通常返回引用类型。
>
> 3. **提供 const 版本**：为了支持 const 对象的访问，通常还需要提供一个 const 版本的重载。
>
> 4. **参数类型灵活**：参数通常是整数类型（如 int），但也可以是其他类型（如字符串）。
>
> 5. **边界检查**：通常需要进行边界检查，防止越界访问。

**简单的数组封装类**

```cpp
#include <iostream>
#include <stdexcept>

class MyArray {
private:
    int* data;
    int size;

public:
    MyArray(int sz) : size(sz) {
        data = new int[size]();
    }
    
    ~MyArray() {
        delete[] data;
    }
    
    // 非 const 版本，可读可写
    int& operator[](int index) {
        if (index < 0 || index >= size) {
            throw std::out_of_range("索引越界");
        }
        return data[index];
    }
    
    // const 版本，只读
    const int& operator[](int index) const {
        if (index < 0 || index >= size) {
            throw std::out_of_range("索引越界");
        }
        return data[index];
    }
    
    int getSize() const {
        return size;
    }
};

int main() {
    MyArray arr(5);
    
    // 使用 [] 运算符赋值
    for (int i = 0; i < arr.getSize(); ++i) {
        arr[i] = i * 10;
    }
    
    // 使用 [] 运算符读取
    for (int i = 0; i < arr.getSize(); ++i) {
        std::cout << "arr[" << i << "] = " << arr[i] << std::endl;
    }
    
    // 使用 const 对象
    const MyArray constArr = arr;
    // constArr[0] = 100;  // 错误：不能修改 const 对象的元素
    std::cout << "constArr[2] = " << constArr[2] << std::endl;
    
    try {
        std::cout << arr[10] << std::endl;  // 越界访问
    } catch (const std::out_of_range& e) {
        std::cout << "异常：" << e.what() << std::endl;
    }
    
    return 0;
}
```

**使用非整数类型作为索引**

```cpp
#include <iostream>
#include <string>
#include <map>

class Dictionary {
private:
    std::map<std::string, std::string> data;

public:
    // 非 const 版本
    std::string& operator[](const std::string& key) {
        return data[key];  // 利用 std::map 的 [] 运算符
    }
    
    // const 版本
    const std::string& operator[](const std::string& key) const {
        auto it = data.find(key);
        if (it == data.end()) {
            throw std::out_of_range("键不存在");
        }
        return it->second;
    }
    
    bool hasKey(const std::string& key) const {
        return data.find(key) != data.end();
    }
};

int main() {
    Dictionary dict;
    
    // 使用 [] 运算符添加/修改元素
    dict["apple"] = "苹果";
    dict["banana"] = "香蕉";
    dict["orange"] = "橙子";
    
    // 使用 [] 运算符读取元素
    std::cout << "apple 的中文是：" << dict["apple"] << std::endl;
    std::cout << "banana 的中文是：" << dict["banana"] << std::endl;
    
    // 修改元素
    dict["apple"] = "红苹果";
    std::cout << "修改后，apple 的中文是：" << dict["apple"] << std::endl;
    
    return 0;
}
```

**实现多维数组访问**

```cpp
#include <iostream>
#include <vector>

class Matrix {
private:
    std::vector<std::vector<int>> data;
    int rows, cols;

public:
    Matrix(int r, int c) : rows(r), cols(c) {
        data.resize(rows);
        for (int i = 0; i < rows; ++i) {
            data[i].resize(cols, 0);
        }
    }
    
    // 返回行引用，以支持二维访问
    std::vector<int>& operator[](int row) {
        if (row < 0 || row >= rows) {
            throw std::out_of_range("行索引越界");
        }
        return data[row];
    }
    
    // const 版本
    const std::vector<int>& operator[](int row) const {
        if (row < 0 || row >= rows) {
            throw std::out_of_range("行索引越界");
        }
        return data[row];
    }
    
    void print() const {
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                std::cout << data[i][j] << " ";
            }
            std::cout << std::endl;
        }
    }
};

int main() {
    Matrix mat(3, 4);
    
    // 使用 [][] 设置元素
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 4; ++j) {
            mat[i][j] = i * 10 + j;
        }
    }
    
    // 打印矩阵
    std::cout << "矩阵内容：" << std::endl;
    mat.print();
    
    // 访问单个元素
    std::cout << "mat[1][2] = " << mat[1][2] << std::endl;
    
    // 修改元素
    mat[1][2] = 100;
    std::cout << "修改后 mat[1][2] = " << mat[1][2] << std::endl;
    
    return 0;
}
```

**代理类模式**

有时我们需要在访问元素时执行特殊操作（如写时复制、延迟计算等），可以使用代理类模式：

```cpp
#include <iostream>
#include <string>

class StringArray {
private:
    std::string* data;
    int size;
    
    // 代理类，用于实现特殊的下标操作
    class Proxy {
    private:
        StringArray& array;
        int index;
    
    public:
        Proxy(StringArray& a, int i) : array(a), index(i) {}
        
        // 赋值运算符，当执行 array[i] = value 时调用
        Proxy& operator=(const std::string& value) {
            if (index < 0 || index >= array.size) {
                throw std::out_of_range("索引越界");
            }
            
            // 这里可以添加特殊处理逻辑
            std::cout << "写入操作：将 " << value << " 写入位置 " << index << std::endl;
            array.data[index] = value;
            return *this;
        }
        
        // 转换运算符，当读取 array[i] 时调用
        operator std::string() const {
            if (index < 0 || index >= array.size) {
                throw std::out_of_range("索引越界");
            }
            
            // 这里可以添加特殊处理逻辑
            std::cout << "读取操作：从位置 " << index << " 读取 " << array.data[index] << std::endl;
            return array.data[index];
        }
    };

public:
    StringArray(int sz) : size(sz) {
        data = new std::string[size];
    }
    
    ~StringArray() {
        delete[] data;
    }
    
    // [] 运算符返回代理对象
    Proxy operator[](int index) {
        return Proxy(*this, index);
    }
};

int main() {
    StringArray arr(3);
    
    // 写入操作
    arr[0] = "Hello";
    arr[1] = "World";
    arr[2] = "C++";
    
    // 读取操作
    std::string s1 = arr[0];
    std::string s2 = arr[1];
    
    // 组合操作
    std::cout << "组合：" << s1 + " " + s2 + " " + std::string(arr[2]) << std::endl;
    
    return 0;
}
```

> [!note]
>
> 1. **内存管理**：如果类管理动态内存，确保正确处理内存分配和释放，避免内存泄漏。
>
> 2. **边界检查**：始终进行边界检查，防止越界访问导致的未定义行为。
>
> 3. **返回引用**：通常返回引用以支持赋值操作，但要确保引用的对象生命周期合适。
>
> 4. **const 正确性**：提供 const 和非 const 版本的重载，以支持不同场景的使用。
>
> 5. **异常安全**：适当使用异常处理机制，确保在异常情况下不会导致资源泄漏。


## <<输出运算符重载

在C++中，`<<`运算符原本是位左移运算符，但在C++标准库中被重载用于输出流操作。通过重载这个运算符，我们可以为自定义类型定义输出格式，使其能够直接与`std::cout`等输出流一起使用。

```cpp
std::ostream& operator<<(std::ostream& os, const MyClass& obj);
```

**1. 友元函数**

```cpp
class MyClass {
private:
    int _value;
    std::string _name;
    
public:
    // 声明为友元函数，可以访问私有成员
    friend std::ostream& operator<<(std::ostream& os, const MyClass& obj);
};

// 实现友元函数
std::ostream& operator<<(std::ostream& os, const MyClass& obj) {
    os << "名称: " << obj._name << ", 值: " << obj._value;
    return os;
}
```

**2. 成员函数**

```cpp
class MyClass {
private:
    int _value;
    std::string _name;
    
public:
    // 作为成员函数实现
    std::ostream& operator<<(std::ostream& os) const {
        os << "名称: " << _name << ", 值: " << _value;
        return os;
    }
};
```

成员函数方式不常用，因为它改变了运算符的使用方式（`obj << cout`而不是`cout << obj`）。

> [!important]
>
> 1. **返回类型**：返回`std::ostream&`引用，允许链式调用（如`cout << obj1 << obj2`）
>
> 2. **参数**：
>    - 第一个参数是输出流的引用
>    - 第二个参数通常是要输出的对象的常量引用
>
> 3. **const修饰**：第二个参数通常用`const`修饰，表示不会修改对象
>
> 4. **友元声明**：通常在类内声明为友元，以访问私有成员

在继承体系中，派生类的`<<`运算符可以调用基类的`<<`运算符：

```cpp
friend std::ostream& operator<<(std::ostream& os, const Derived& obj) {
    // 先调用基类的<<运算符
    os << static_cast<const Base&>(obj);
    // 再输出派生类特有部分
    os << ", 派生类成员: " << obj._derivedMember;
    return os;
}
```

```cpp
MyClass obj("测试", 100);
std::cout << obj << std::endl;
// 输出：名称: 测试, 值: 100
        
```


## >>输入运算符重载

在C++中，`>>`运算符原本是位右移运算符，但在C++标准库中被重载用于输入流操作。通过重载这个运算符，我们可以为自定义类型定义输入格式，使其能够直接与`std::cin`等输入流一起使用。

```cpp
std::istream& operator>>(std::istream& is, MyClass& obj);
```

**1. 友元函数**

```cpp
class MyClass {
private:
    int _value;
    std::string _name;
    
public:
    // 声明为友元函数，可以访问私有成员
    friend std::istream& operator>>(std::istream& is, MyClass& obj);
};

// 实现友元函数
std::istream& operator>>(std::istream& is, MyClass& obj) {
    is >> obj._name >> obj._value;
    
    // 检查输入是否成功
    if (!is) {
        // 处理输入错误
    }
    
    return is;
}
```

**2. 成员函数**

```cpp
class MyClass {
private:
    int _value;
    std::string _name;
    
public:
    // 作为成员函数实现
    std::istream& operator>>(std::istream& is) {
        is >> _name >> _value;
        return is;
    }
};
```

成员函数方式不常用，因为它改变了运算符的使用方式（`obj >> cin`而不是`cin >> obj`）。

> [!important]
>
> 1. **返回类型**：返回`std::istream&`引用，允许链式调用（如`cin >> obj1 >> obj2`）
>
> 2. **参数**：
>    - 第一个参数是输入流的引用
>    - 第二个参数是要输入的对象的非常量引用（因为需要修改对象）
>
> 3. **错误处理**：应该检查输入操作是否成功，并适当处理错误
>
> 4. **友元声明**：通常在类内声明为友元，以访问私有成员
>
> 5. **输入验证**：通常需要验证输入数据的有效性

```cpp
std::istream& operator>>(std::istream& is, MyClass& obj) {
    int tempValue;
    std::string tempName;
    
    // 先读取到临时变量
    is >> tempName >> tempValue;
    
    // 验证输入
    if (is) {
        // 输入有效，更新对象
        obj._name = tempName;
        obj._value = tempValue;
    } else {
        // 输入无效，将流设置为失败状态
        is.setstate(std::ios::failbit);
    }
    
    return is;
}
```

```cpp
MyClass obj;
std::cout << "请输入名称和值：";
std::cin >> obj;

// 检查输入是否成功
if (std::cin) {
    std::cout << "输入成功！" << std::endl;
} else {
    std::cout << "输入失败！" << std::endl;
}
```


# 成员访问运算符

C++中有两种主要的成员访问运算符：点运算符(`.`)和箭头运算符(`->`)。这两个运算符用于访问类或结构体的成员（包括变量和函数）。

## 点运算符 (.)

点运算符用于通过对象直接访问其成员。

```cpp
对象名.成员名
```

- 用于访问普通对象（非指针）的成员
- 用于访问引用类型对象的成员
- 用于访问通过值传递的对象的成员

```cpp
class Person {
public:
    std::string name;
    void sayHello() {
        std::cout << "你好，我是" << name << std::endl;
    }
};

int main() {
    Person person;
    person.name = "张三";  // 使用点运算符访问成员变量
    person.sayHello();    // 使用点运算符调用成员函数
    
    Person& personRef = person;
    personRef.name = "李四";  // 引用类型也使用点运算符
    
    return 0;
}
```

## 箭头运算符 (->)

箭头运算符用于通过指针访问对象的成员。

```cpp
指针名->成员名
```

- 用于访问指针所指向对象的成员
- 用于访问动态分配对象的成员
- 用于智能指针访问其管理对象的成员

```cpp
int main() {
    Person* personPtr = new Person();
    personPtr->name = "王五";    // 使用箭头运算符访问指针所指对象的成员变量
    personPtr->sayHello();      // 使用箭头运算符调用指针所指对象的成员函数
    
    delete personPtr;  // 不要忘记释放内存
    
    // 使用智能指针
    std::shared_ptr<Person> smartPtr = std::make_shared<Person>();
    smartPtr->name = "赵六";
    smartPtr->sayHello();
    
    return 0;
}
```

箭头运算符(`->`)可以被重载，但有特殊规则：

```cpp
class SmartPointer {
private:
    Person* ptr;
    
public:
    SmartPointer(Person* p) : ptr(p) {}
    ~SmartPointer() { delete ptr; }
    
    // 重载箭头运算符
    Person* operator->() {
        return ptr;  // 必须返回指针类型
    }
};

int main() {
    SmartPointer sp(new Person());
    sp->name = "智能指针测试";  // 等价于 (sp.operator->())->name
    sp->sayHello();
    return 0;
}
```

重载箭头运算符时：
- 必须是类的成员函数
- 必须返回指针类型或者另一个重载了箭头运算符的类对象


## 箭头运算符重载在两层和三层结构下的使用

在多层结构下，箭头运算符的重载可以实现链式调用，这在智能指针和代理类设计中非常有用。

箭头运算符重载有几个特殊规则：

1. 必须是类的成员函数
2. 不能有参数（是一个无参数的一元运算符）
3. 必须返回指针或者另一个重载了箭头运算符的对象

### 两层结构

两层结构是指一个类重载箭头运算符，返回一个指针。

```cpp
class Resource {
public:
    void doSomething() {
        std::cout << "资源执行操作" << std::endl;
    }
    int value = 42;
};

class SmartPointer {
private:
    Resource* ptr;

public:
    SmartPointer(Resource* p = nullptr) : ptr(p) {}
    ~SmartPointer() { delete ptr; }
    
    // 箭头运算符重载 - 返回指针
    Resource* operator->() {
        std::cout << "箭头运算符被调用" << std::endl;
        return ptr;
    }
};

int main() {
    SmartPointer sp(new Resource());
    sp->doSomething();  // 等价于 (sp.operator->())->doSomething();
    int x = sp->value;  // 等价于 (sp.operator->())->value;
    return 0;
}
```

当编译器看到`sp->doSomething()`时，它会：
1. 调用`sp.operator->()`，得到一个`Resource*`指针
2. 对该指针应用箭头运算符，访问`doSomething()`方法

### 三层结构（链式调用）

三层结构是指一个类重载箭头运算符，返回另一个重载了箭头运算符的对象，形成链式调用。

```cpp
class Level3 {
private:
    Resource* ptr;

public:
    Level3(Resource* p) : ptr(p) {}
    
    // 最终返回真正的指针
    Resource* operator->() {
        std::cout << "Level3::operator->被调用" << std::endl;
        return ptr;
    }
};

class Level2 {
private:
    Level3 level3;

public:
    Level2(Resource* p) : level3(p) {}
    
    // 返回另一个重载了箭头运算符的对象
    Level3 operator->() {
        std::cout << "Level2::operator->被调用" << std::endl;
        return level3;
    }
};

class Level1 {
private:
    Level2 level2;

public:
    Level1(Resource* p) : level2(p) {}
    
    // 返回另一个重载了箭头运算符的对象
    Level2 operator->() {
        std::cout << "Level1::operator->被调用" << std::endl;
        return level2;
    }
};

int main() {
    Level1 l1(new Resource());
    l1->doSomething();
    // 执行顺序：
    // 1. l1.operator->() 返回 Level2对象
    // 2. Level2对象.operator->() 返回 Level3对象
    // 3. Level3对象.operator->() 返回 Resource*指针
    // 4. 使用该指针调用 doSomething()
    return 0;
}
```

执行`l1->doSomething()`时，编译器会：
1. 调用`l1.operator->()`，得到一个`Level2`对象
2. 对该对象调用`operator->()`，得到一个`Level3`对象
3. 对该对象调用`operator->()`，得到一个`Resource*`指针
4. 对该指针应用箭头运算符，访问`doSomething()`方法

## 实际应用场景

**1. 智能指针**

```cpp
template<typename T>
class SmartPtr {
private:
    T* ptr;
    int* refCount;

public:
    SmartPtr(T* p = nullptr) : ptr(p), refCount(new int(1)) {}
    ~SmartPtr() {
        if (--(*refCount) == 0) {
            delete ptr;
            delete refCount;
        }
    }
    
    // 拷贝构造函数和赋值运算符省略...
    
    T* operator->() {
        return ptr;
    }
};
```

**2. 代理模式**

```cpp
class DatabaseProxy {
private:
    Database* realDb;
    bool hasAccess;

public:
    DatabaseProxy(Database* db, bool access) : realDb(db), hasAccess(access) {}
    
    Database* operator->() {
        if (!hasAccess) {
            throw std::runtime_error("访问被拒绝");
        }
        return realDb;
    }
};
```

**3. 延迟加载**

```cpp
class LazyLoader {
private:
    Resource* ptr;
    std::string resourcePath;
    bool loaded;

public:
    LazyLoader(const std::string& path) : ptr(nullptr), resourcePath(path), loaded(false) {}
    ~LazyLoader() { delete ptr; }
    
    Resource* operator->() {
        if (!loaded) {
            ptr = loadResource(resourcePath);
            loaded = true;
        }
        return ptr;
    }
    
    Resource* loadResource(const std::string& path) {
        // 从路径加载资源
        return new Resource();
    }
};
```

> [!note]
>
> 1. **内存管理**：在多层结构中，需要明确每一层的内存管理责任，避免内存泄漏。
>
> 2. **返回值类型**：链式调用中，中间层返回的是对象而非引用，可能导致性能问题。考虑返回引用以避免不必要的对象复制。
>
> 3. **递归终止**：链式调用必须最终返回一个指针，否则会导致编译错误
>
> 4. **线程安全**：在多线程环境中，需要考虑箭头运算符重载函数的线程安全性。
>
> 5. **异常安全**：箭头运算符重载函数可能抛出异常，需要确保异常安全。

## 迭代器与过滤器

```cpp
template<typename T>
class FilterIterator {
private:
    std::vector<T>::iterator current;
    std::vector<T>::iterator end;
    std::function<bool(const T&)> predicate;

public:
    FilterIterator(std::vector<T>::iterator begin, 
                  std::vector<T>::iterator end,
                  std::function<bool(const T&)> pred)
        : current(begin), end(end), predicate(pred) {
        // 找到第一个满足条件的元素
        while (current != end && !predicate(*current)) {
            ++current;
        }
    }
    
    T* operator->() {
        return &(*current);
    }
    
    // 其他迭代器操作...
};

int main() {
    std::vector<Resource> resources(10);
    auto isEven = [](const Resource& r) { return r.value % 2 == 0; };
    
    FilterIterator<Resource> it(resources.begin(), resources.end(), isEven);
    it->doSomething();  // 只对满足条件的资源执行操作
    
    return 0;
}
        
```


# 函数对象（Functor）

函数对象是C++中一种特殊的对象，它可以像函数一样被调用。从技术上讲，函数对象是一个重载了函数调用运算符`operator()`的类的实例。

## 基本概念

函数对象是通过重载`operator()`（函数调用运算符）来实现的类对象，使其行为类似于函数。

```cpp
class MyFunctor {
public:
    // 重载函数调用运算符
    int operator()(int x, int y) const {
        return x + y;
    }
};

int main() {
    MyFunctor addObj;  // 创建函数对象
    
    // 像调用函数一样使用函数对象
    int result = addObj(5, 3);  // 调用 operator()(5, 3)
    std::cout << "结果: " << result << std::endl;  // 输出: 结果: 8
    
    return 0;
}
```

相比普通函数，函数对象有以下优势：

**1. 可以保存状态**

```cpp
class Counter {
private:
    int count;
    
public:
    Counter() : count(0) {}
    
    int operator()() {
        return ++count;  // 每次调用都会增加计数
    }
    
    void reset() {
        count = 0;
    }
};

int main() {
    Counter counter;
    std::cout << counter() << std::endl;  // 输出: 1
    std::cout << counter() << std::endl;  // 输出: 2
    std::cout << counter() << std::endl;  // 输出: 3
    
    counter.reset();
    std::cout << counter() << std::endl;  // 输出: 1
    
    return 0;
}
```

**2. 可以有多个重载版本的调用运算符**

```cpp
class Calculator {
public:
    // 整数加法
    int operator()(int a, int b) const {
        return a + b;
    }
    
    // 浮点数加法
    double operator()(double a, double b) const {
        return a + b;
    }
    
    // 字符串连接
    std::string operator()(const std::string& a, const std::string& b) const {
        return a + b;
    }
};

int main() {
    Calculator calc;
    std::cout << calc(10, 20) << std::endl;          // 调用int版本
    std::cout << calc(2.5, 3.5) << std::endl;        // 调用double版本
    std::cout << calc("Hello, ", "World!") << std::endl;  // 调用string版本
    
    return 0;
}
```

**3. 可以作为模板参数传递**

```cpp
template<typename T, typename Comparator>
void sort(std::vector<T>& vec, Comparator comp) {
    // 使用comp作为比较器进行排序
    for (size_t i = 0; i < vec.size(); ++i) {
        for (size_t j = i + 1; j < vec.size(); ++j) {
            if (comp(vec[j], vec[i])) {  // 使用函数对象进行比较
                std::swap(vec[i], vec[j]);
            }
        }
    }
}

class DescendingOrder {
public:
    bool operator()(int a, int b) const {
        return a > b;  // 降序排列
    }
};

int main() {
    std::vector<int> numbers = {5, 2, 8, 1, 9};
    
    // 使用函数对象作为排序算法的比较器
    sort(numbers, DescendingOrder());
    
    // 输出排序结果
    for (int num : numbers) {
        std::cout << num << " ";
    }  // 输出: 9 8 5 2 1
    
    return 0;
}
```

**4. 内联优化**

编译器通常可以将函数对象的调用内联化，从而提高性能。

## 函数对象的类型

**1. 一元函数对象（Unary Functor）**

接受一个参数的函数对象。

```cpp
class Square {
public:
    int operator()(int x) const {
        return x * x;
    }
};

int main() {
    Square square;
    std::cout << square(5) << std::endl;  // 输出: 25
    return 0;
}
```

**2. 二元函数对象（Binary Functor）**

接受两个参数的函数对象。

```cpp
class Multiply {
public:
    int operator()(int x, int y) const {
        return x * y;
    }
};

int main() {
    Multiply multiply;
    std::cout << multiply(5, 3) << std::endl;  // 输出: 15
    return 0;
}
```

**3. 谓词函数对象（Predicate Functor）**

返回布尔值的函数对象，常用于条件判断。

```cpp
class IsEven {
public:
    bool operator()(int x) const {
        return x % 2 == 0;
    }
};

int main() {
    IsEven isEven;
    std::cout << std::boolalpha;
    std::cout << isEven(4) << std::endl;  // 输出: true
    std::cout << isEven(5) << std::endl;  // 输出: false
    return 0;
}
```

## 标准库中的函数对象

C++标准库在`<functional>`头文件中提供了许多预定义的函数对象：

**1. 算术运算符**

```cpp
#include <functional>
#include <iostream>

int main() {
    std::plus<int> add;
    std::minus<int> subtract;
    std::multiplies<int> multiply;
    std::divides<int> divide;
    std::modulus<int> modulo;
    std::negate<int> negate;
    
    std::cout << add(5, 3) << std::endl;       // 输出: 8
    std::cout << subtract(5, 3) << std::endl;  // 输出: 2
    std::cout << multiply(5, 3) << std::endl;  // 输出: 15
    std::cout << divide(6, 3) << std::endl;    // 输出: 2
    std::cout << modulo(5, 3) << std::endl;    // 输出: 2
    std::cout << negate(5) << std::endl;       // 输出: -5
    
    return 0;
}
```

**2. 比较运算符**

```cpp
#include <functional>
#include <iostream>

int main() {
    std::equal_to<int> equal;
    std::not_equal_to<int> not_equal;
    std::greater<int> greater;
    std::less<int> less;
    std::greater_equal<int> greater_equal;
    std::less_equal<int> less_equal;
    
    std::cout << std::boolalpha;
    std::cout << equal(5, 5) << std::endl;          // 输出: true
    std::cout << not_equal(5, 3) << std::endl;      // 输出: true
    std::cout << greater(5, 3) << std::endl;        // 输出: true
    std::cout << less(5, 3) << std::endl;           // 输出: false
    std::cout << greater_equal(5, 5) << std::endl;  // 输出: true
    std::cout << less_equal(3, 5) << std::endl;     // 输出: true
    
    return 0;
}
```

**3. 逻辑运算符**

```cpp
#include <functional>
#include <iostream>

int main() {
    std::logical_and<bool> logical_and;
    std::logical_or<bool> logical_or;
    std::logical_not<bool> logical_not;
    
    std::cout << std::boolalpha;
    std::cout << logical_and(true, false) << std::endl;  // 输出: false
    std::cout << logical_or(true, false) << std::endl;   // 输出: true
    std::cout << logical_not(true) << std::endl;         // 输出: false
    
    return 0;
}
```

## 函数对象在STL算法中的应用

函数对象在STL算法中被广泛使用，特别是作为自定义比较器或转换器。

**1. 排序算法**

```cpp
#include <algorithm>
#include <functional>
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numbers = {5, 2, 8, 1, 9};
    
    // 使用标准库函数对象进行降序排序
    std::sort(numbers.begin(), numbers.end(), std::greater<int>());
    
    // 输出排序结果
    for (int num : numbers) {
        std::cout << num << " ";
    }  // 输出: 9 8 5 2 1
    
    return 0;
}
```

**2. 查找算法**

```cpp
#include <algorithm>
#include <functional>
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numbers = {5, 2, 8, 1, 9};
    
    // 查找大于5的第一个元素
    auto it = std::find_if(numbers.begin(), numbers.end(),
                          [](int n) { return n > 5; });
    
    if (it != numbers.end()) {
        std::cout << "找到大于5的第一个元素: " << *it << std::endl;
    }
    
    return 0;
}
```

**3. 转换算法**

```cpp
#include <algorithm>
#include <functional>
#include <iostream>
#include <vector>

class Square {
public:
    int operator()(int x) const {
        return x * x;
    }
};

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    std::vector<int> squares(numbers.size());
    
    // 使用函数对象计算平方
    std::transform(numbers.begin(), numbers.end(), squares.begin(), Square());
    
    // 输出结果
    for (int num : squares) {
        std::cout << num << " ";
    }  // 输出: 1 4 9 16 25
    
    return 0;
}
```

## 函数对象与Lambda表达式

C++11引入的Lambda表达式可以看作是函数对象的一种简化写法。

```cpp
#include <algorithm>
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numbers = {5, 2, 8, 1, 9};
    
    // 使用函数对象进行排序
    struct {
        bool operator()(int a, int b) const {
            return a > b;
        }
    } customLess;
    
    std::sort(numbers.begin(), numbers.end(), customLess);
    
    // 等价的Lambda表达式
    std::sort(numbers.begin(), numbers.end(), [](int a, int b) { return a > b; });
    
    // 输出排序结果
    for (int num : numbers) {
        std::cout << num << " ";
    }  // 输出: 9 8 5 2 1
    
    return 0;
}
```

## 函数对象与std::function

C++11引入的`std::function`是一个通用的函数包装器，可以包装任何可调用对象，包括函数对象。

```cpp
#include <functional>
#include <iostream>

class Adder {
private:
    int base;
    
public:
    Adder(int b) : base(b) {}
    
    int operator()(int x) const {
        return base + x;
    }
};

int main() {
    // 包装函数对象
    std::function<int(int)> add5 = Adder(5);
    
    // 包装Lambda表达式
    std::function<int(int)> multiply2 = [](int x) { return x * 2; };
    
    // 包装普通函数
    std::function<int(int)> negate = [](int x) { return -x; };
    
    // 组合使用
    std::cout << add5(10) << std::endl;                // 输出: 15
    std::cout << multiply2(10) << std::endl;           // 输出: 20
    std::cout << negate(10) << std::endl;              // 输出: -10
    std::cout << negate(multiply2(add5(10))) << std::endl;  // 输出: -30
    
    return 0;
}
```


# 普通函数指针

函数指针是C++中一种特殊类型的指针，它指向函数而不是数据。函数指针允许我们在运行时选择要调用的函数，实现回调机制和策略模式等设计模式。

函数指针的声明语法如下：

```cpp
返回类型 (*指针名称)(参数类型列表);
```

例如，声明一个指向接受两个整数并返回整数的函数的指针：

```cpp
int (*pFunc)(int, int);
```

## 基本用法

**1. 定义和初始化函数指针**

```cpp
#include <iostream>

// 定义几个具有相同签名的函数
int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int multiply(int a, int b) {
    return a * b;
}

int main() {
    // 声明函数指针
    int (*operation)(int, int);
    
    // 将函数指针指向add函数
    operation = add;
    std::cout << "加法结果: " << operation(5, 3) << std::endl;  // 输出: 8
    
    // 将函数指针指向subtract函数
    operation = subtract;
    std::cout << "减法结果: " << operation(5, 3) << std::endl;  // 输出: 2
    
    // 将函数指针指向multiply函数
    operation = multiply;
    std::cout << "乘法结果: " << operation(5, 3) << std::endl;  // 输出: 15
    
    // 也可以直接使用函数名初始化
    int (*anotherOperation)(int, int) = add;
    
    return 0;
}
```

**2. 作为函数参数**

函数指针常用作函数参数，实现回调机制：

```cpp
#include <iostream>
#include <vector>

// 接受函数指针作为参数的函数
void processArray(const std::vector<int>& arr, int (*processor)(int)) {
    for (int num : arr) {
        std::cout << processor(num) << " ";
    }
    std::cout << std::endl;
}

// 可以传递给processArray的函数
int square(int x) {
    return x * x;
}

int cube(int x) {
    return x * x * x;
}

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    std::cout << "平方结果: ";
    processArray(numbers, square);  // 输出: 1 4 9 16 25
    
    std::cout << "立方结果: ";
    processArray(numbers, cube);    // 输出: 1 8 27 64 125
    
    return 0;
}
```

**3. 作为函数返回值**

函数也可以返回函数指针：

```cpp
#include <iostream>

int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

// 返回函数指针的函数
int (*getOperation(char op))(int, int) {
    if (op == '+') {
        return add;
    } else if (op == '-') {
        return subtract;
    } else {
        return nullptr;
    }
}

// 使用typedef简化函数指针类型
typedef int (*Operation)(int, int);

// 使用typedef后的版本
Operation getOperationSimpler(char op) {
    if (op == '+') {
        return add;
    } else if (op == '-') {
        return subtract;
    } else {
        return nullptr;
    }
}

int main() {
    char op = '+';
    int (*operation)(int, int) = getOperation(op);
    if (operation) {
        std::cout << "结果: " << operation(5, 3) << std::endl;  // 输出: 8
    }
    
    // 使用typedef简化后的版本
    Operation op2 = getOperationSimpler('-');
    if (op2) {
        std::cout << "结果: " << op2(5, 3) << std::endl;  // 输出: 2
    }
    
    return 0;
}
```

函数指针的语法可能比较复杂，可以使用`typedef`或C++11的`using`来简化：

```cpp
// 使用typedef简化函数指针类型
typedef int (*MathFunc)(int, int);

// 使用C++11的using简化函数指针类型
using MathOperation = int (*)(int, int);

int main() {
    MathFunc add = [](int a, int b) { return a + b; };
    MathOperation subtract = [](int a, int b) { return a - b; };
    
    std::cout << add(5, 3) << std::endl;       // 输出: 8
    std::cout << subtract(5, 3) << std::endl;  // 输出: 2
    
    return 0;
}
```

## 函数指针数组

可以创建函数指针数组，存储多个函数指针：

```cpp
#include <iostream>

int add(int a, int b) { return a + b; }
int subtract(int a, int b) { return a - b; }
int multiply(int a, int b) { return a * b; }
int divide(int a, int b) { return b != 0 ? a / b : 0; }

int main() {
    // 函数指针数组
    int (*operations[4])(int, int) = {add, subtract, multiply, divide};
    
    int a = 10, b = 5;
    const char* opNames[] = {"加", "减", "乘", "除"};
    
    for (int i = 0; i < 4; ++i) {
        std::cout << a << " " << opNames[i] << " " << b << " = " 
                  << operations[i](a, b) << std::endl;
    }
    
    return 0;
}
```

## 函数指针与std::function

C++11引入的`std::function`是一个通用的函数包装器，可以存储、复制和调用任何可调用目标，包括函数指针：

```cpp
#include <iostream>
#include <functional>

int add(int a, int b) { return a + b; }

class Multiplier {
public:
    int multiply(int a, int b) { return a * b; }
};

int main() {
    // 存储普通函数
    std::function<int(int, int)> func1 = add;
    std::cout << func1(5, 3) << std::endl;  // 输出: 8
    
    // 存储Lambda表达式
    std::function<int(int, int)> func2 = [](int a, int b) { return a - b; };
    std::cout << func2(5, 3) << std::endl;  // 输出: 2
    
    // 存储成员函数
    Multiplier multiplier;
    std::function<int(int, int)> func3 = 
        [&multiplier](int a, int b) { return multiplier.multiply(a, b); };
    std::cout << func3(5, 3) << std::endl;  // 输出: 15
    
    // 使用std::bind存储成员函数
    std::function<int(int, int)> func4 = 
        std::bind(&Multiplier::multiply, multiplier, std::placeholders::_1, std::placeholders::_2);
    std::cout << func4(5, 3) << std::endl;  // 输出: 15
    
    return 0;
}
```

## 函数指针与回调函数

函数指针常用于实现回调机制，例如在事件处理中：

```cpp
#include <iostream>
#include <vector>
#include <string>

// 定义事件处理器类型
typedef void (*EventHandler)(const std::string&);

class Button {
private:
    std::string label;
    EventHandler clickHandler;
    
public:
    Button(const std::string& lbl) : label(lbl), clickHandler(nullptr) {}
    
    void setClickHandler(EventHandler handler) {
        clickHandler = handler;
    }
    
    void click() {
        if (clickHandler) {
            clickHandler(label);
        }
    }
};

// 事件处理函数
void handleButtonClick(const std::string& buttonLabel) {
    std::cout << "按钮 '" << buttonLabel << "' 被点击了！" << std::endl;
}

void anotherHandler(const std::string& buttonLabel) {
    std::cout << "另一个处理器: 按钮 '" << buttonLabel << "' 被点击了！" << std::endl;
}

int main() {
    Button submitButton("提交");
    Button cancelButton("取消");
    
    // 设置点击处理器
    submitButton.setClickHandler(handleButtonClick);
    cancelButton.setClickHandler(anotherHandler);
    
    // 模拟点击
    submitButton.click();  // 输出: 按钮 '提交' 被点击了！
    cancelButton.click();  // 输出: 另一个处理器: 按钮 '取消' 被点击了！
    
    return 0;
}
```

## 函数指针与策略模式

函数指针可以用于实现策略模式，允许在运行时选择算法：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

// 排序策略函数
bool ascending(int a, int b) {
    return a < b;
}

bool descending(int a, int b) {
    return a > b;
}

bool evenFirst(int a, int b) {
    // 偶数优先，然后按升序
    if (a % 2 == 0 && b % 2 != 0) return true;
    if (a % 2 != 0 && b % 2 == 0) return false;
    return a < b;
}

// 使用函数指针作为排序策略
void sortVector(std::vector<int>& vec, bool (*compareFunc)(int, int)) {
    std::sort(vec.begin(), vec.end(), compareFunc);
}

int main() {
    std::vector<int> numbers = {5, 2, 8, 1, 9, 4, 3, 7, 6};
    
    // 使用不同的排序策略
    sortVector(numbers, ascending);
    std::cout << "升序排序: ";
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    sortVector(numbers, descending);
    std::cout << "降序排序: ";
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    sortVector(numbers, evenFirst);
    std::cout << "偶数优先排序: ";
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

​          


​          


​          


​          


​          
# 成员函数指针

成员函数指针是C++中一种特殊类型的函数指针，用于指向类的成员函数。与普通函数指针不同，成员函数指针需要考虑类的上下文，因此其语法和使用方式都更为复杂。

## 基本概念与语法

成员函数指针的基本声明语法如下：

```cpp
返回类型 (类名::*指针名)(参数列表);
```

例如，声明一个指向`MyClass`类中接受一个`int`参数并返回`double`的成员函数的指针：

```cpp
double (MyClass::*pFunc)(int);
```

将成员函数地址赋给成员函数指针：

```cpp
pFunc = &MyClass::someMethod;
```

注意：虽然对于普通函数指针，`&`运算符是可选的，但对于成员函数指针，`&`运算符是必需的。

调用成员函数指针需要一个类的实例（或指向实例的指针），使用特殊的调用运算符：

- 通过对象调用：`(object.*pFunc)(参数)`
- 通过指针调用：`(pointer->*pFunc)(参数)`

## 详细示例

```cpp
#include <iostream>

class MyClass {
public:
    void printValue(int value) {
        std::cout << "Value: " << value << std::endl;
    }
    
    double multiply(double a, double b) {
        return a * b;
    }
};

int main() {
    // 声明成员函数指针
    void (MyClass::*printFunc)(int) = &MyClass::printValue;
    double (MyClass::*calcFunc)(double, double) = &MyClass::multiply;
    
    // 创建类实例
    MyClass obj;
    MyClass* pObj = new MyClass();
    
    // 通过对象调用
    (obj.*printFunc)(42);
    
    // 通过指针调用
    double result = (pObj->*calcFunc)(3.14, 2.0);
    std::cout << "Result: " << result << std::endl;
    
    delete pObj;
    return 0;
}
```

**使用typedef简化语法**

```cpp
class MyClass {
public:
    void method1(int);
    void method2(int);
};

// 使用typedef简化成员函数指针类型
typedef void (MyClass::*MyFuncPtr)(int);

// 使用using别名（C++11及以后）
using MyFuncPtrModern = void (MyClass::*)(int);

int main() {
    MyFuncPtr fp1 = &MyClass::method1;
    MyFuncPtrModern fp2 = &MyClass::method2;
    
    MyClass obj;
    (obj.*fp1)(10);
    (obj.*fp2)(20);
    
    return 0;
}
```

## 高级应用

**1. 成员函数指针数组**

```cpp
#include <iostream>
#include <string>

class Calculator {
public:
    double add(double a, double b) { return a + b; }
    double subtract(double a, double b) { return a - b; }
    double multiply(double a, double b) { return a * b; }
    double divide(double a, double b) { return b != 0 ? a / b : 0; }
};

int main() {
    // 定义成员函数指针类型
    typedef double (Calculator::*Operation)(double, double);
    
    // 创建成员函数指针数组
    Operation operations[4] = {
        &Calculator::add,
        &Calculator::subtract,
        &Calculator::multiply,
        &Calculator::divide
    };
    
    std::string opNames[4] = {"加法", "减法", "乘法", "除法"};
    
    Calculator calc;
    double a = 10.0, b = 5.0;
    
    // 遍历并调用所有操作
    for (int i = 0; i < 4; ++i) {
        double result = (calc.*operations[i])(a, b);
        std::cout << opNames[i] << ": " << result << std::endl;
    }
    
    return 0;
}
```

**2. 在类中存储成员函数指针**

```cpp
#include <iostream>

class Button {
private:
    class Handler {
    public:
        virtual void onClick() = 0;
        virtual ~Handler() {}
    };
    
    template<class T>
    class SpecificHandler : public Handler {
    private:
        T* instance;
        void (T::*method)();
        
    public:
        SpecificHandler(T* instance, void (T::*method)())
            : instance(instance), method(method) {}
            
        void onClick() override {
            (instance->*method)();
        }
    };
    
    Handler* handler;
    
public:
    Button() : handler(nullptr) {}
    
    ~Button() {
        delete handler;
    }
    
    template<class T>
    void setClickHandler(T* instance, void (T::*method)()) {
        delete handler;
        handler = new SpecificHandler<T>(instance, method);
    }
    
    void click() {
        if (handler) {
            handler->onClick();
        }
    }
};

class Application {
public:
    void onButtonClicked() {
        std::cout << "按钮被点击了！" << std::endl;
    }
    
    void onAnotherAction() {
        std::cout << "执行另一个动作！" << std::endl;
    }
};

int main() {
    Button button;
    Application app;
    
    // 设置点击处理函数
    button.setClickHandler(&app, &Application::onButtonClicked);
    button.click();  // 输出：按钮被点击了！
    
    // 更改处理函数
    button.setClickHandler(&app, &Application::onAnotherAction);
    button.click();  // 输出：执行另一个动作！
    
    return 0;
}
```

**3. 虚成员函数指针**

```cpp
#include <iostream>

class Base {
public:
    virtual void virtualFunc(int x) {
        std::cout << "Base::virtualFunc(" << x << ")" << std::endl;
    }
};

class Derived : public Base {
public:
    void virtualFunc(int x) override {
        std::cout << "Derived::virtualFunc(" << x << ")" << std::endl;
    }
};

int main() {
    // 声明指向虚函数的成员函数指针
    void (Base::*vptr)(int) = &Base::virtualFunc;
    
    Base b;
    Derived d;
    Base* pb = &d;
    
    // 通过不同对象调用
    (b.*vptr)(1);    // 输出：Base::virtualFunc(1)
    (d.*vptr)(2);    // 输出：Derived::virtualFunc(2)
    (pb->*vptr)(3);  // 输出：Derived::virtualFunc(3) - 多态行为！
    
    return 0;
}
```

**4. 常量成员函数指针**

对于`const`成员函数，需要特别声明指针类型：

```cpp
#include <iostream>

class MyClass {
public:
    void regularMethod() {
        std::cout << "Regular method" << std::endl;
    }
    
    void constMethod() const {
        std::cout << "Const method" << std::endl;
    }
};

int main() {
    // 普通成员函数指针
    void (MyClass::*regular)() = &MyClass::regularMethod;
    
    // 常量成员函数指针
    void (MyClass::*constant)() const = &MyClass::constMethod;
    
    MyClass obj;
    const MyClass constObj;
    
    (obj.*regular)();      // 正常工作
    (obj.*constant)();     // 正常工作
    // (constObj.*regular)(); // 编译错误：不能在const对象上调用非const方法
    (constObj.*constant)(); // 正常工作
    
    return 0;
}
```

**5. 与std::function和std::bind结合使用**

在现代C++中，可以使用`std::function`和`std::bind`简化成员函数指针的使用：

```cpp
#include <iostream>
#include <functional>

class MyClass {
public:
    int multiply(int a, int b) {
        return a * b;
    }
    
    void print(const std::string& message) {
        std::cout << "Message: " << message << std::endl;
    }
};

int main() {
    MyClass obj;
    
    // 使用std::bind创建可调用对象
    auto multiplyBinder = std::bind(&MyClass::multiply, &obj, std::placeholders::_1, std::placeholders::_2);
    std::cout << "Result: " << multiplyBinder(6, 7) << std::endl;
    
    // 使用std::function存储成员函数
    std::function<void(const std::string&)> printFunc = std::bind(&MyClass::print, &obj, std::placeholders::_1);
    printFunc("Hello from std::function");
    
    // C++11 lambda也可以用来封装成员函数调用
    auto printLambda = [&obj](const std::string& msg) { obj.print(msg); };
    printLambda("Hello from lambda");
    
    return 0;
}
```

**6. 回调系统**

```cpp
#include <iostream>
#include <vector>
#include <string>

class EventListener {
public:
    virtual void onEvent(const std::string& eventName) = 0;
    virtual ~EventListener() {}
};

class EventManager {
private:
    std::vector<EventListener*> listeners;
    
public:
    void addListener(EventListener* listener) {
        listeners.push_back(listener);
    }
    
    void fireEvent(const std::string& eventName) {
        for (auto listener : listeners) {
            listener->onEvent(eventName);
        }
    }
};

class Application : public EventListener {
private:
    std::string name;
    
public:
    Application(const std::string& name) : name(name) {}
    
    void onEvent(const std::string& eventName) override {
        std::cout << name << " 收到事件: " << eventName << std::endl;
    }
};

int main() {
    EventManager manager;
    
    Application app1("应用1");
    Application app2("应用2");
    
    manager.addListener(&app1);
    manager.addListener(&app2);
    
    manager.fireEvent("系统启动");
    manager.fireEvent("用户登录");
    
    return 0;
}
```

**7. 命令模式实现**

```cpp
#include <iostream>
#include <vector>
#include <memory>

class Command {
public:
    virtual void execute() = 0;
    virtual ~Command() {}
};

template<class Receiver>
class ConcreteCommand : public Command {
private:
    Receiver* receiver;
    void (Receiver::*action)();
    
public:
    ConcreteCommand(Receiver* r, void (Receiver::*a)())
        : receiver(r), action(a) {}
        
    void execute() override {
        (receiver->*action)();
    }
};

class Light {
public:
    void turnOn() {
        std::cout << "灯已打开" << std::endl;
    }
    
    void turnOff() {
        std::cout << "灯已关闭" << std::endl;
    }
};

class Fan {
public:
    void start() {
        std::cout << "风扇开始运转" << std::endl;
    }
    
    void stop() {
        std::cout << "风扇已停止" << std::endl;
    }
};

class RemoteControl {
private:
    std::vector<std::unique_ptr<Command>> commands;
    
public:
    void addCommand(std::unique_ptr<Command> cmd) {
        commands.push_back(std::move(cmd));
    }
    
    void pressButton(int index) {
        if (index >= 0 && index < commands.size()) {
            commands[index]->execute();
        }
    }
};

int main() {
    Light light;
    Fan fan;
    RemoteControl remote;
    
    remote.addCommand(std::make_unique<ConcreteCommand<Light>>(&light, &Light::turnOn));
    remote.addCommand(std::make_unique<ConcreteCommand<Light>>(&light, &Light::turnOff));
    remote.addCommand(std::make_unique<ConcreteCommand<Fan>>(&fan, &Fan::start));
    remote.addCommand(std::make_unique<ConcreteCommand<Fan>>(&fan, &Fan::stop));
    
    remote.pressButton(0);  // 打开灯
    remote.pressButton(2);  // 启动风扇
    remote.pressButton(3);  // 停止风扇
    remote.pressButton(1);  // 关闭灯
    
    return 0;
}
```

> [!note]
>
> 1. **性能考虑**：成员函数指针的调用通常比普通函数指针或直接函数调用慢，因为需要额外的间接寻址。
>
> 2. **类型安全**：使用`typedef`或`using`定义成员函数指针类型可以提高代码可读性和类型安全性。
>
> 3. **现代替代方案**：在现代C++中，考虑使用`std::function`、`std::bind`或lambda表达式作为更灵活的替代方案。
>
> 4. **多态行为**：成员函数指针可以指向虚函数，并且会遵循C++的多态规则。
>
> 5. **内存管理**：在使用成员函数指针时，确保指向的对象在调用时仍然有效，避免悬垂指针问题。
>
> 6. **调试难度**：成员函数指针的语法复杂，可能导致调试困难，使用时应谨慎。

# 类型转换函数

类型转换函数是一种特殊的成员函数，具有以下特点：
- 函数名为`operator`后跟目标类型
- 没有显式的返回类型（返回类型隐含在函数名中）
- 不接受参数
- 通常声明为`const`

基本语法：
```cpp
operator Type() const { /* 实现 */ }
```

```cpp
class Seconds {
private:
    int value;
    
public:
    Seconds(int s) : value(s) {}
    
    // 类型转换函数：将Seconds转换为int
    operator int() const {
        return value;
    }
};

int main() {
    Seconds s(60);
    int seconds = s;  // 隐式调用operator int()，seconds = 60
    
    // 也可以显式调用
    int explicit_seconds = static_cast<int>(s);
    
    return 0;
}
```

一个类可以定义多个类型转换函数：

```cpp
class TimeSpan {
private:
    int seconds;
    
public:
    TimeSpan(int s) : seconds(s) {}
    
    // 转换为秒
    operator int() const {
        return seconds;
    }
    
    // 转换为分钟（浮点数）
    operator double() const {
        return seconds / 60.0;
    }
    
    // 转换为布尔值（检查是否有时间）
    operator bool() const {
        return seconds > 0;
    }
};
```

为了防止意外的隐式转换，可以使用`explicit`关键字：

```cpp
class Integer {
private:
    int value;
    
public:
    Integer(int v) : value(v) {}
    
    // 禁止隐式转换，只允许显式转换
    explicit operator int() const {
        return value;
    }
};

int main() {
    Integer i(42);
    
    // int x = i;  // 错误：不允许隐式转换
    int y = static_cast<int>(i);  // 正确：显式转换
    
    if (static_cast<int>(i) > 40) {  // 必须显式转换
        // ...
    }
    
    return 0;
}
```

类型转换函数也可以返回引用：

```cpp
class StringWrapper {
private:
    std::string data;
    
public:
    StringWrapper(const std::string& s) : data(s) {}
    
    // 转换为string的引用
    operator const std::string&() const {
        return data;
    }
};
```

可以转换为用户自定义类型：

```cpp
class Meters;  // 前向声明

class Feet {
private:
    double value;
    
public:
    Feet(double ft) : value(ft) {}
    double getValue() const { return value; }
    
    // 转换为Meters类型
    operator Meters() const;
};

class Meters {
private:
    double value;
    
public:
    Meters(double m) : value(m) {}
    double getValue() const { return value; }
    
    // 构造函数也可以实现从Feet到Meters的转换
    Meters(const Feet& ft) : value(ft.getValue() * 0.3048) {}
};

// 在Feet类外部定义转换函数
Feet::operator Meters() const {
    return Meters(value * 0.3048);
}
```

> [!note]
>
> 类型转换函数可能导致二义性问题：
>
> ```cpp
> class Number {
> private:
>     int value;
>     
> public:
>     Number(int v) : value(v) {}
>     
>     operator int() const { return value; }
>     operator double() const { return static_cast<double>(value); }
> };
> 
> void func(int i) { /* ... */ }
> void func(double d) { /* ... */ }
> 
> int main() {
>     Number n(42);
>     
>     // func(n);  // 错误：调用不明确，可以转换为int或double
>     
>     // 解决方法：显式指定转换
>     func(static_cast<int>(n));
>     
>     return 0;
> }
> ```
>

构造函数和类型转换函数都可以实现类型转换，但方向相反：
- 构造函数：其他类型 → 当前类
- 类型转换函数：当前类 → 其他类型

```cpp
class Integer {
private:
    int value;
    
public:
    // 构造函数：int → Integer
    Integer(int v) : value(v) {}
    
    // 类型转换函数：Integer → int
    operator int() const { return value; }
};
```

> [!tip]
>
> - 只在有明确语义的情况下使用类型转换函数
> - 对可能导致数据丢失的转换使用`explicit`
> - 避免定义过多的类型转换函数，以减少二义性
> - 确保转换的行为符合直觉
> - 考虑使用命名函数作为替代（如`toInt()`、`toString()`等）

​          

# 嵌套类

嵌套类是在另一个类内部定义的类。嵌套类是外部类的成员，可以访问外部类的私有和保护成员（在某些条件下）。嵌套类提供了更好的封装性和逻辑组织。

## 基本概念和语法

```cpp
class OuterClass {
private:
    int outerData;
    
public:
    // 嵌套类定义
    class InnerClass {
    private:
        int innerData;
        
    public:
        InnerClass(int data) : innerData(data) {}
        
        void display() {
            std::cout << "Inner data: " << innerData << std::endl;
        }
    };
    
    OuterClass(int data) : outerData(data) {}
    
    void createInner() {
        InnerClass inner(100);
        inner.display();
    }
};
```

```cpp
class OuterClass {
private:
    int privateData = 10;
    
protected:
    int protectedData = 20;
    
public:
    int publicData = 30;
    
    // 公有嵌套类
    class PublicInner {
    public:
        void accessOuter(OuterClass& outer) {
            // 嵌套类可以访问外部类的所有成员
            std::cout << "Private: " << outer.privateData << std::endl;
            std::cout << "Protected: " << outer.protectedData << std::endl;
            std::cout << "Public: " << outer.publicData << std::endl;
        }
    };
    
private:
    // 私有嵌套类
    class PrivateInner {
    public:
        void doSomething() {
            std::cout << "Private inner class method" << std::endl;
        }
    };
    
public:
    void usePrivateInner() {
        PrivateInner inner;
        inner.doSomething();
    }
};

int main() {
    OuterClass outer(0);
    
    // 可以创建公有嵌套类的实例
    OuterClass::PublicInner publicInner;
    publicInner.accessOuter(outer);
    
    // 不能直接创建私有嵌套类的实例
    // OuterClass::PrivateInner privateInner; // 编译错误
    
    // 但可以通过外部类的方法间接使用
    outer.usePrivateInner();
    
    return 0;
}
```

## 嵌套类的特性

**作用域和命名**

```cpp
class OuterClass {
public:
    class InnerClass {
    public:
        void method() {
            std::cout << "InnerClass method" << std::endl;
        }
        
        // 嵌套类中的嵌套类
        class DeeplyNested {
        public:
            void deepMethod() {
                std::cout << "Deeply nested method" << std::endl;
            }
        };
    };
};

int main() {
    // 使用作用域解析运算符访问嵌套类
    OuterClass::InnerClass inner;
    inner.method();
    
    // 访问更深层的嵌套类
    OuterClass::InnerClass::DeeplyNested deep;
    deep.deepMethod();
    
    return 0;
}
```

**前向声明**

```cpp
class OuterClass {
public:
    // 前向声明嵌套类
    class InnerClass;
    
    void useInner(InnerClass* inner);
    
    // 实际定义可以在后面
    class InnerClass {
    private:
        int data;
        
    public:
        InnerClass(int d) : data(d) {}
        int getData() const { return data; }
    };
};

// 在类外定义成员函数
void OuterClass::useInner(InnerClass* inner) {
    if (inner) {
        std::cout << "Inner data: " << inner->getData() << std::endl;
    }
}
```

## 应用场景

### 迭代器模式

```cpp
#include <iostream>
#include <vector>

template<typename T>
class MyContainer {
private:
    std::vector<T> data;
    
public:
    void add(const T& item) {
        data.push_back(item);
    }
    
    // 嵌套迭代器类
    class Iterator {
    private:
        typename std::vector<T>::iterator it;
        
    public:
        Iterator(typename std::vector<T>::iterator iter) : it(iter) {}
        
        T& operator*() {
            return *it;
        }
        
        Iterator& operator++() {
            ++it;
            return *this;
        }
        
        bool operator!=(const Iterator& other) const {
            return it != other.it;
        }
        
        bool operator==(const Iterator& other) const {
            return it == other.it;
        }
    };
    
    Iterator begin() {
        return Iterator(data.begin());
    }
    
    Iterator end() {
        return Iterator(data.end());
    }
};

int main() {
    MyContainer<int> container;
    container.add(1);
    container.add(2);
    container.add(3);
    
    // 使用自定义迭代器
    for (auto it = container.begin(); it != container.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### 状态机模式

```cpp
#include <iostream>
#include <memory>

class StateMachine {
private:
    // 抽象状态基类
    class State {
    public:
        virtual void handle(StateMachine* context) = 0;
        virtual ~State() {}
    };
    
    // 具体状态类
    class StateA : public State {
    public:
        void handle(StateMachine* context) override {
            std::cout << "处理状态A，转换到状态B" << std::endl;
            context->setState(std::make_unique<StateB>());
        }
    };
    
    class StateB : public State {
    public:
        void handle(StateMachine* context) override {
            std::cout << "处理状态B，转换到状态C" << std::endl;
            context->setState(std::make_unique<StateC>());
        }
    };
    
    class StateC : public State {
    public:
        void handle(StateMachine* context) override {
            std::cout << "处理状态C，转换到状态A" << std::endl;
            context->setState(std::make_unique<StateA>());
        }
    };
    
    std::unique_ptr<State> currentState;
    
public:
    StateMachine() : currentState(std::make_unique<StateA>()) {}
    
    void setState(std::unique_ptr<State> newState) {
        currentState = std::move(newState);
    }
    
    void request() {
        if (currentState) {
            currentState->handle(this);
        }
    }
};

int main() {
    StateMachine machine;
    
    for (int i = 0; i < 5; ++i) {
        machine.request();
    }
    
    return 0;
}
```

### 建造者模式

```cpp
#include <iostream>
#include <string>

class Computer {
private:
    std::string cpu;
    std::string memory;
    std::string storage;
    std::string graphics;
    
public:
    // 嵌套建造者类
    class Builder {
    private:
        Computer computer;
        
    public:
        Builder& setCPU(const std::string& cpu) {
            computer.cpu = cpu;
            return *this;
        }
        
        Builder& setMemory(const std::string& memory) {
            computer.memory = memory;
            return *this;
        }
        
        Builder& setStorage(const std::string& storage) {
            computer.storage = storage;
            return *this;
        }
        
        Builder& setGraphics(const std::string& graphics) {
            computer.graphics = graphics;
            return *this;
        }
        
        Computer build() {
            return computer;
        }
    };
    
    void display() const {
        std::cout << "Computer Configuration:" << std::endl;
        std::cout << "CPU: " << cpu << std::endl;
        std::cout << "Memory: " << memory << std::endl;
        std::cout << "Storage: " << storage << std::endl;
        std::cout << "Graphics: " << graphics << std::endl;
    }
    
    // 静态方法返回建造者
    static Builder builder() {
        return Builder();
    }
};

int main() {
    Computer computer = Computer::builder()
        .setCPU("Intel i7")
        .setMemory("16GB DDR4")
        .setStorage("1TB SSD")
        .setGraphics("NVIDIA RTX 3080")
        .build();
    
    computer.display();
    
    return 0;
}
```

## 嵌套类与外部类的关系

**访问外部类成员**

```cpp
class OuterClass {
private:
    int privateValue = 100;
    static int staticValue;
    
public:
    class InnerClass {
    public:
        void accessOuter() {
            // 访问静态成员不需要外部类实例
            std::cout << "Static value: " << staticValue << std::endl;
            
            // 访问非静态成员需要外部类实例
            // std::cout << privateValue << std::endl; // 编译错误
        }
        
        void accessOuter(OuterClass& outer) {
            // 通过外部类实例访问私有成员
            std::cout << "Private value: " << outer.privateValue << std::endl;
        }
        
        void accessOuter(OuterClass* outer) {
            if (outer) {
                std::cout << "Private value: " << outer->privateValue << std::endl;
            }
        }
    };
    
    void createInner() {
        InnerClass inner;
        inner.accessOuter(*this);  // 传递当前对象
    }
};

// 静态成员定义
int OuterClass::staticValue = 200;

int main() {
    OuterClass outer;
    outer.createInner();
    
    OuterClass::InnerClass inner;
    inner.accessOuter();
    inner.accessOuter(outer);
    
    return 0;
}
```

**友元关系**

```cpp
class OuterClass {
private:
    int secretData = 42;
    
    // 嵌套类自动是外部类的友元
    class InnerClass {
    public:
        void revealSecret(const OuterClass& outer) {
            std::cout << "Secret: " << outer.secretData << std::endl;
        }
    };
    
public:
    InnerClass getInner() {
        return InnerClass();
    }
};

int main() {
    OuterClass outer;
    auto inner = outer.getInner();
    inner.revealSecret(outer);
    
    return 0;
}
```

## 模板嵌套类

```cpp
template<typename T>
class OuterTemplate {
private:
    T data;
    
public:
    OuterTemplate(const T& d) : data(d) {}
    
    // 模板嵌套类
    template<typename U>
    class InnerTemplate {
    private:
        U innerData;
        
    public:
        InnerTemplate(const U& d) : innerData(d) {}
        
        void display(const OuterTemplate<T>& outer) {
            std::cout << "Outer data: " << outer.data << std::endl;
            std::cout << "Inner data: " << innerData << std::endl;
        }
    };
    
    // 非模板嵌套类
    class SimpleInner {
    public:
        void show(const OuterTemplate<T>& outer) {
            std::cout << "Outer template data: " << outer.data << std::endl;
        }
    };
};

int main() {
    OuterTemplate<int> outer(100);
    
    // 使用模板嵌套类
    OuterTemplate<int>::InnerTemplate<std::string> inner("Hello");
    inner.display(outer);
    
    // 使用非模板嵌套类
    OuterTemplate<int>::SimpleInner simple;
    simple.show(outer);
    
    return 0;
}
```

---

**避免过度嵌套**

```cpp
// 不推荐：过度嵌套
class Level1 {
public:
    class Level2 {
    public:
        class Level3 {
        public:
            class Level4 {
                // 过度嵌套，难以维护
            };
        };
    };
};

// 推荐：适度嵌套，清晰的逻辑关系
class Container {
public:
    class Iterator {
        // 逻辑上属于Container的迭代器
    };
    
    class Node {
        // 逻辑上属于Container的节点
    };
};
```

**合理使用访问控制**

```cpp
class WellDesigned {
private:
    // 实现细节的嵌套类设为私有
    class Implementation {
        // 外部不需要知道的实现细节
    };
    
public:
    // 外部需要使用的嵌套类设为公有
    class PublicInterface {
        // 外部可以使用的接口
    };
    
protected:
    // 派生类可能需要的嵌套类设为保护
    class ProtectedHelper {
        // 派生类可能需要的辅助类
    };
};
```

# 单例对象自动释放

## 利用另一个对象的生命周期管理资源

```cpp
class Singleton {
public:
    static Singleton *getInstance() {
        if (_instance == nullptr) {
            return new Singleton();
        }
        return _instance;
    }
    friend class AutoRelease;

private:
    Singleton() : _single(0) {}
    Singleton(const Singleton &rhs) = delete;
    Singleton &operator=(const Singleton &rhs) = delete;
    int _single;
    static Singleton *_instance;
};

Singleton *Singleton::_instance = nullptr;

class AutoRelease {
public:
    AutoRelease(Singleton *p) : _pS(p) {}
    ~AutoRelease() {
        if (_pS) {
            delete _pS;
            _pS = nullptr;
            Singleton::_instance = nullptr;
        }
    }

private:
    Singleton *_pS;
};
```

## 嵌套类+静态对象

```cpp
class Singleton {
public:
    static Singleton *getInstance() {
        if (_instance == nullptr) {
            return new Singleton();
        }
        return _instance;
    }

private:
    class Destructor {
        ~Destructor() {
            if (Singleton::_instance) {
                delete _instance;
            }
        }
    };
    Singleton() : _single(0) {}
    Singleton(const Singleton &rhs) = delete;
    Singleton &operator=(const Singleton &rhs) = delete;
    int _single;
    static Singleton *_instance;
    static Destructor destructor;
};

Singleton *Singleton::_instance = nullptr;
Singleton::Destructor Singleton::destructor;
```

## atexit+destroy

```cpp
class Singleton {
public:
    static Singleton *getInstance() {
        if (_instance == nullptr) {
            atexit(&destroyInstance);
            return new Singleton();
        }
        return _instance;
    }
    static void destroyInstance() {
        if (_instance) {
            delete _instance;
        }
    }

private:
    Singleton() : _single(0) {}
    Singleton(const Singleton &rhs) = delete;
    Singleton &operator=(const Singleton &rhs) = delete;
    int _single;
    static Singleton *_instance;
};

Singleton *Singleton::_instance = nullptr;
```

## atexit+pthread_once+destroy

```cpp
class Singleton {
public:
    static Singleton *getInstance() {
        pthread_once(&onceControl, &initRoutine);
        return _instance;
    }
    static void destroyInstance() {
        if (_instance) {
            delete _instance;
        }
    }

private:
    Singleton() : _single(0) {}
    Singleton(const Singleton &rhs) = delete;
    Singleton &operator=(const Singleton &rhs) = delete;
    static void initRoutine() {
        _instance = new Singleton();
        atexit(&destroyInstance);
    }
    int _single;
    static Singleton *_instance;
    static pthread_once_t onceControl;
};

Singleton *Singleton::_instance = nullptr;
pthread_once_t Singleton::onceControl = PTHREAD_ONCE_INIT;
```

## 智能指针

**std::unique_ptr**

```cpp
#include <memory>
#include <iostream>

class Singleton {
private:
    static std::unique_ptr<Singleton> instance;
    static std::once_flag initFlag;
    
    Singleton() {
        std::cout << "Singleton 构造函数被调用" << std::endl;
    }
    
public:
    ~Singleton() {
        std::cout << "Singleton 析构函数被调用" << std::endl;
    }
    
    // 禁用拷贝构造和赋值操作
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
    
    static Singleton& getInstance() {
        std::call_once(initFlag, []() {
            instance = std::unique_ptr<Singleton>(new Singleton());
        });
        return *instance;
    }
    
    void doSomething() {
        std::cout << "执行某些操作" << std::endl;
    }
};

// 静态成员定义
std::unique_ptr<Singleton> Singleton::instance = nullptr;
std::once_flag Singleton::initFlag;

int main() {
    Singleton& s1 = Singleton::getInstance();
    s1.doSomething();
    
    Singleton& s2 = Singleton::getInstance();
    s2.doSomething();
    
    // 程序结束时，unique_ptr 会自动释放对象
    return 0;
}
```

**std::shared_ptr**

```cpp
#include <memory>
#include <mutex>
#include <iostream>

class Singleton {
private:
    static std::shared_ptr<Singleton> instance;
    static std::mutex mtx;
    
    Singleton() {
        std::cout << "Singleton 构造函数被调用" << std::endl;
    }
    
public:
    ~Singleton() {
        std::cout << "Singleton 析构函数被调用" << std::endl;
    }
    
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
    
    static std::shared_ptr<Singleton> getInstance() {
        std::lock_guard<std::mutex> lock(mtx);
        if (!instance) {
            // 使用 make_shared 无法访问私有构造函数，所以使用这种方式
            instance = std::shared_ptr<Singleton>(new Singleton());
        }
        return instance;
    }
    
    void doSomething() {
        std::cout << "执行某些操作" << std::endl;
    }
};

std::shared_ptr<Singleton> Singleton::instance = nullptr;
std::mutex Singleton::mtx;

int main() {
    auto s1 = Singleton::getInstance();
    s1->doSomething();
    
    auto s2 = Singleton::getInstance();
    s2->doSomething();
    
    // shared_ptr 会在引用计数为0时自动释放对象
    return 0;
}
```

## Meyer's Singleton

利用C++11的线程安全静态局部变量特性：

```cpp
#include <iostream>

class Singleton {
private:
    Singleton() {
        std::cout << "Singleton 构造函数被调用" << std::endl;
    }
    
public:
    ~Singleton() {
        std::cout << "Singleton 析构函数被调用" << std::endl;
    }
    
    // 禁用拷贝构造和赋值操作
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
    
    static Singleton& getInstance() {
        // C++11保证静态局部变量的线程安全初始化
        static Singleton instance;
        return instance;
    }
    
    void doSomething() {
        std::cout << "执行某些操作" << std::endl;
    }
};

int main() {
    Singleton& s1 = Singleton::getInstance();
    s1.doSomething();
    
    Singleton& s2 = Singleton::getInstance();
    s2.doSomething();
    
    // 程序结束时，静态对象会自动调用析构函数
    return 0;
}
```

## RAII 和自定义删除器

```cpp
#include <memory>
#include <iostream>

class Singleton {
private:
    static std::unique_ptr<Singleton, void(*)(Singleton*)> instance;
    static std::once_flag initFlag;
    
    Singleton() {
        std::cout << "Singleton 构造函数被调用" << std::endl;
    }
    
    // 自定义删除器
    static void deleter(Singleton* ptr) {
        std::cout << "自定义删除器被调用" << std::endl;
        delete ptr;
    }
    
public:
    ~Singleton() {
        std::cout << "Singleton 析构函数被调用" << std::endl;
    }
    
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
    
    static Singleton& getInstance() {
        std::call_once(initFlag, []() {
            instance = std::unique_ptr<Singleton, void(*)(Singleton*)>(
                new Singleton(), deleter);
        });
        return *instance;
    }
    
    void doSomething() {
        std::cout << "执行某些操作" << std::endl;
    }
};

std::unique_ptr<Singleton, void(*)(Singleton*)> Singleton::instance{nullptr, Singleton::deleter};
std::once_flag Singleton::initFlag;

int main() {
    Singleton& s = Singleton::getInstance();
    s.doSomething();
    
    return 0;
}
```

## 线程安全的单例模板

```cpp
#include <iostream>
#include <memory>
#include <mutex>

template<typename T>
class SingletonBase {
protected:
    SingletonBase() = default;
    virtual ~SingletonBase() = default;
    
public:
    SingletonBase(const SingletonBase&) = delete;
    SingletonBase& operator=(const SingletonBase&) = delete;
    
    static T& getInstance() {
        static T instance;
        return instance;
    }
};

// 具体的单例类
class MyService : public SingletonBase<MyService> {
friend class SingletonBase<MyService>;

private:
    MyService() {
        std::cout << "MyService 构造函数被调用" << std::endl;
    }
    
public:
    ~MyService() {
        std::cout << "MyService 析构函数被调用" << std::endl;
    }
    
    void performService() {
        std::cout << "执行服务操作" << std::endl;
    }
};

int main() {
    MyService& service = MyService::getInstance();
    service.performService();
    
    return 0;
}
```


# std::string的底层实现

`std::string`是C++标准库中最常用的字符串类，其底层实现经历了多个版本的演进。

## 传统实现

```cpp
class basic_string {
private:
    char* data_;        // 指向字符数据的指针
    size_t size_;       // 当前字符串长度
    size_t capacity_;   // 分配的容量
    
public:
    // 构造函数、析构函数等
};
```

现代C++标准库实现通常采用以下三种策略之一。

## Small String Optimization (SSO)

这是目前最流行的优化策略，用于避免小字符串的动态内存分配：

```cpp
class string {
private:
    static constexpr size_t SSO_SIZE = 15; // 小字符串优化大小
    
    union {
        struct {
            char* ptr;          // 长字符串时指向堆内存
            size_t size;
            size_t capacity;
        } long_string;
        
        struct {
            char buffer[SSO_SIZE + 1];  // 短字符串直接存储
            unsigned char size;         // 最高位用作标志位
        } short_string;
    } data_;
    
public:
    bool is_short() const {
        // 检查标志位判断是否为短字符串
        return (data_.short_string.size & 0x80) == 0;
    }
    
    const char* c_str() const {
        return is_short() ? data_.short_string.buffer : data_.long_string.ptr;
    }
    
    size_t size() const {
        return is_short() ? (data_.short_string.size & 0x7F) : data_.long_string.size;
    }
};
```

**SSO的工作原理**

```cpp
#include <iostream>
#include <string>

void demonstrate_sso() {
    // 短字符串（通常 <= 15字符）- 使用栈内存
    std::string short_str = "Hello";
    std::cout << "短字符串地址: " << (void*)short_str.c_str() << std::endl;
    std::cout << "string对象地址: " << (void*)&short_str << std::endl;
    
    // 长字符串 - 使用堆内存
    std::string long_str = "This is a very long string that exceeds SSO limit";
    std::cout << "长字符串地址: " << (void*)long_str.c_str() << std::endl;
    std::cout << "string对象地址: " << (void*)&long_str << std::endl;
    
    // 可以看到短字符串的数据地址通常接近对象地址
    // 而长字符串的数据地址在堆上，与对象地址相差较远
}
```

## Copy-on-Write (COW) 实现

这是较老的实现策略，现在已不常用（C++11后基本废弃）：

```cpp
class cow_string {
private:
    struct StringRep {
        size_t ref_count;   // 引用计数
        size_t size;
        size_t capacity;
        char data[1];       // 柔性数组成员
        
        static StringRep* create(size_t capacity) {
            StringRep* rep = (StringRep*)malloc(sizeof(StringRep) + capacity);
            rep->ref_count = 1;
            rep->size = 0;
            rep->capacity = capacity;
            return rep;
        }
        
        void add_ref() { ++ref_count; }
        
        void release() {
            if (--ref_count == 0) {
                free(this);
            }
        }
    };
    
    StringRep* rep_;
    
public:
    cow_string(const cow_string& other) : rep_(other.rep_) {
        rep_->add_ref();  // 共享数据
    }
    
    char& operator[](size_t index) {
        if (rep_->ref_count > 1) {
            // 写时复制
            StringRep* new_rep = StringRep::create(rep_->capacity);
            memcpy(new_rep->data, rep_->data, rep_->size);
            new_rep->size = rep_->size;
            rep_->release();
            rep_ = new_rep;
        }
        return rep_->data[index];
    }
};
```

## 现代实现示例（类似libstdc++）

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

class MyString {
private:
    static constexpr size_t SSO_CAPACITY = 15;
    
    union {
        struct {
            char* ptr;
            size_t size;
            size_t capacity;
        } heap_data;
        
        struct {
            char buffer[SSO_CAPACITY + 1];
            unsigned char size;
        } stack_data;
    };
    
    bool is_sso() const {
        return (stack_data.size & 0x80) == 0;
    }
    
    void set_sso_size(size_t sz) {
        stack_data.size = static_cast<unsigned char>(sz);
    }
    
    void set_heap_size(size_t sz) {
        heap_data.size = sz;
        stack_data.size = 0x80; // 设置标志位
    }
    
public:
    MyString() {
        stack_data.buffer[0] = '\0';
        set_sso_size(0);
    }
    
    MyString(const char* str) {
        size_t len = strlen(str);
        
        if (len <= SSO_CAPACITY) {
            // 使用SSO
            memcpy(stack_data.buffer, str, len + 1);
            set_sso_size(len);
        } else {
            // 使用堆分配
            heap_data.capacity = len + 1;
            heap_data.ptr = new char[heap_data.capacity];
            memcpy(heap_data.ptr, str, len + 1);
            set_heap_size(len);
        }
    }
    
    MyString(const MyString& other) {
        if (other.is_sso()) {
            memcpy(stack_data.buffer, other.stack_data.buffer, SSO_CAPACITY + 1);
            stack_data.size = other.stack_data.size;
        } else {
            size_t len = other.heap_data.size;
            heap_data.capacity = len + 1;
            heap_data.ptr = new char[heap_data.capacity];
            memcpy(heap_data.ptr, other.heap_data.ptr, len + 1);
            set_heap_size(len);
        }
    }
    
    ~MyString() {
        if (!is_sso()) {
            delete[] heap_data.ptr;
        }
    }
    
    const char* c_str() const {
        return is_sso() ? stack_data.buffer : heap_data.ptr;
    }
    
    size_t size() const {
        return is_sso() ? (stack_data.size & 0x7F) : heap_data.size;
    }
    
    size_t capacity() const {
        return is_sso() ? SSO_CAPACITY : (heap_data.capacity - 1);
    }
    
    void reserve(size_t new_capacity) {
        if (new_capacity <= capacity()) return;
        
        if (is_sso() && new_capacity <= SSO_CAPACITY) return;
        
        // 需要重新分配
        char* new_ptr = new char[new_capacity + 1];
        size_t current_size = size();
        memcpy(new_ptr, c_str(), current_size + 1);
        
        if (!is_sso()) {
            delete[] heap_data.ptr;
        }
        
        heap_data.ptr = new_ptr;
        heap_data.capacity = new_capacity + 1;
        set_heap_size(current_size);
    }
    
    MyString& operator+=(const char* str) {
        size_t str_len = strlen(str);
        size_t current_size = size();
        size_t new_size = current_size + str_len;
        
        if (new_size > capacity()) {
            reserve(std::max(new_size, capacity() * 2));
        }
        
        char* dest = is_sso() ? stack_data.buffer : heap_data.ptr;
        memcpy(dest + current_size, str, str_len + 1);
        
        if (is_sso() && new_size <= SSO_CAPACITY) {
            set_sso_size(new_size);
        } else {
            if (is_sso()) {
                // 需要从SSO转换到堆分配
                char* new_ptr = new char[capacity() + 1];
                memcpy(new_ptr, stack_data.buffer, new_size + 1);
                heap_data.ptr = new_ptr;
                heap_data.capacity = capacity() + 1;
            }
            set_heap_size(new_size);
        }
        
        return *this;
    }
};

int main() {
    MyString s1("Hello");  // SSO
    std::cout << "s1: " << s1.c_str() << ", size: " << s1.size() 
              << ", capacity: " << s1.capacity() << std::endl;
    
    MyString s2("This is a very long string that exceeds SSO");  // 堆分配
    std::cout << "s2: " << s2.c_str() << ", size: " << s2.size() 
              << ", capacity: " << s2.capacity() << std::endl;
    
    return 0;
}
```

`std::string`的底层实现经历了从简单的指针+长度+容量结构，到COW（写时复制），再到现代的SSO（小字符串优化）的演进。现代实现主要特点：

1. **SSO优化**：小字符串直接存储在对象内部，避免堆分配
2. **联合体设计**：巧妙使用union节省内存空间
3. **标志位技巧**：使用最高位区分长短字符串模式
4. **内存对齐**：优化内存访问性能
5. **增长策略**：通常采用2倍增长避免频繁重新分配

这种设计在保持接口简单的同时，大大提升了字符串操作的性能，特别是对于常见的短字符串场景。
