# 管道

## 匿名管道

### 概述

- 半双工通信，只能在有亲缘关系的进程间使用
- **适用场景**: 父子进程间通信

```cpp
#include <unistd.h>
int pipe(int pipefd[2]);
```

**参数说明：**

- `pipefd[2]`: 文件描述符数组
  - `pipefd[0]`: 读端
  - `pipefd[1]`: 写端

**返回值：**

- 成功返回0
- 失败返回-1，并设置errno

**相关函数**

```cpp
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);
int close(int fd);
```

---

> [!note]
>
> - 读写操作默认是阻塞的
> - 内核缓冲区大小通常为64KB
> - 必须正确关闭不使用的端
> - 写入已关闭读端的管道会产生SIGPIPE

### 示例

```c++
#include <iostream>
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>

using namespace std;

int main() {
    int pipefd[2];
    pid_t pid;
    char buffer[1024];
    
    // 创建管道
    if (pipe(pipefd) == -1) {
        perror("pipe创建失败");
        return -1;
    }
    
    cout << "管道创建成功" << endl;
    cout << "读端文件描述符: " << pipefd[0] << endl;
    cout << "写端文件描述符: " << pipefd[1] << endl;
    
    // 创建子进程
    pid = fork();
    
    if (pid == -1) {
        perror("fork失败");
        return -1;
    }
    
    if (pid == 0) {
        // 子进程：读取数据
        cout << "子进程启动，PID: " << getpid() << endl;
        
        // 关闭写端
        close(pipefd[1]);
        
        // 从管道读取数据
        while (true) {
            memset(buffer, 0, sizeof(buffer));
            ssize_t bytes_read = read(pipefd[0], buffer, sizeof(buffer) - 1);
            
            if (bytes_read > 0) {
                buffer[bytes_read] = '\0';
                cout << "子进程收到: " << buffer << endl;
                
                // 如果收到"quit"则退出
                if (strcmp(buffer, "quit") == 0) {
                    break;
                }
            } else if (bytes_read == 0) {
                cout << "管道写端已关闭" << endl;
                break;
            } else {
                perror("读取失败");
                break;
            }
        }
        
        close(pipefd[0]);
        cout << "子进程结束" << endl;
        
    } else {
        // 父进程：发送数据
        cout << "父进程启动，PID: " << getpid() << endl;
        cout << "子进程PID: " << pid << endl;
        
        // 关闭读端
        close(pipefd[0]);
        
        // 向管道写入数据
        string messages[] = {
            "Hello from parent!",
            "This is message 1",
            "This is message 2",
            "quit"
        };
        
        for (const string& msg : messages) {
            cout << "父进程发送: " << msg << endl;
            write(pipefd[1], msg.c_str(), msg.length());
            sleep(1); // 延时1秒
        }
        
        close(pipefd[1]);
        
        // 等待子进程结束
        int status;
        wait(&status);
        cout << "父进程结束" << endl;
    }
    
    return 0;
}
```

## 命名管道

### 概述

- 可以在无亲缘关系的进程间使用
- **适用场景**: 不相关进程间的单向通信

```cpp
#include <sys/stat.h>
int mkfifo(const char *pathname, mode_t mode);
```

**参数说明：**

- `pathname`: FIFO文件路径
- `mode`: 文件权限（如0666）

**返回值：**

- 成功返回0
- 失败返回-1，并设置errno

**相关函数**

```cpp
#include <fcntl.h>
int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
```

**常用`flags`：**

- `O_RDONLY`: 只读模式
- `O_WRONLY`: 只写模式
- `O_RDWR`: 读写模式
- `O_NONBLOCK`: 非阻塞模式

---

> [!note]
>
> - 创建时需要设置合适的权限
> - 打开FIFO时可能阻塞，直到另一端也打开
> - 使用完毕后应删除FIFO文件
> - 多个进程可以同时访问同一个FIFO

### 示例

```c++
#include <iostream>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>

using namespace std;

const char* FIFO_PATH = "/tmp/my_fifo";

int main() {
    int fd;
    
    // 创建命名管道
    if (mkfifo(FIFO_PATH, 0666) == -1) {
        perror("mkfifo失败");
        // 如果文件已存在，继续执行
        if (errno != EEXIST) {
            return -1;
        }
    }
    
    cout << "命名管道创建成功: " << FIFO_PATH << endl;
    
    // 以写模式打开FIFO
    cout << "等待读进程连接..." << endl;
    fd = open(FIFO_PATH, O_WRONLY);
    if (fd == -1) {
        perror("打开FIFO失败");
        return -1;
    }
    
    cout << "读进程已连接，开始发送数据" << endl;
    
    // 发送消息
    string messages[] = {
        "Hello from writer process!",
        "Message 1: FIFO communication",
        "Message 2: Inter-process communication",
        "Message 3: Named pipe example",
        "quit"
    };
    
    for (const string& msg : messages) {
        cout << "发送: " << msg << endl;
        
        ssize_t bytes_written = write(fd, msg.c_str(), msg.length());
        if (bytes_written == -1) {
            perror("写入失败");
            break;
        }
        
        sleep(2); // 延时2秒
    }
    
    close(fd);
    cout << "写进程结束" << endl;
    
    return 0;
}
```

**示例代码：读进程**

```c++
#include <iostream>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>

using namespace std;

const char* FIFO_PATH = "/tmp/my_fifo";

int main() {
    int fd;
    char buffer[1024];
    
    cout << "读进程启动，PID: " << getpid() << endl;
    
    // 检查FIFO是否存在
    struct stat st;
    if (stat(FIFO_PATH, &st) != 0) {
        cout << "FIFO不存在，请先运行写进程" << endl;
        return -1;
    }
    
    // 以读模式打开FIFO
    cout << "打开FIFO: " << FIFO_PATH << endl;
    fd = open(FIFO_PATH, O_RDONLY);
    if (fd == -1) {
        perror("打开FIFO失败");
        return -1;
    }
    
    cout << "FIFO打开成功，等待数据..." << endl;
    
    // 读取数据
    while (true) {
        memset(buffer, 0, sizeof(buffer));
        ssize_t bytes_read = read(fd, buffer, sizeof(buffer) - 1);
        
        if (bytes_read > 0) {
            buffer[bytes_read] = '\0';
            cout << "收到: " << buffer << endl;
            
            // 如果收到"quit"则退出
            if (strcmp(buffer, "quit") == 0) {
                break;
            }
        } else if (bytes_read == 0) {
            cout << "写进程已关闭连接" << endl;
            break;
        } else {
            perror("读取失败");
            break;
        }
    }
    
    close(fd);
    
    // 删除FIFO文件
    if (unlink(FIFO_PATH) == -1) {
        perror("删除FIFO失败");
    } else {
        cout << "FIFO文件已删除" << endl;
    }
    
    cout << "读进程结束" << endl;
    
    return 0;
}
```

# 信号

## 概述

- 异步通信机制，用于通知进程发生了某个事件，信号是软件中断，可以在任何时候发送给进程，进程必须告诉内核如何处理每一种信号
- **函数**: `signal()`, `sigaction()`, `kill()`, `raise()`
- **适用场景**: 简单的事件通知，如进程终止、用户中断等
- **限制**: 只能传递信号类型，无法传递复杂数据

> [!note]
>
> 1. 信号可能在任何时候到达
> 2. 同类型信号在处理期间再次到达会被丢弃
> 3. 信号可能中断系统调用
> 4. 需要小心处理信号处理函数中的共享数据
> 5. 某些信号在不同系统上行为可能不同

## 常用信号类型

| 信号名  | 信号值 | 默认动作      | 说明               |
| ------- | ------ | ------------- | ------------------ |
| SIGINT  | 2      | 终止          | 中断信号(Ctrl+C)   |
| SIGQUIT | 3      | 终止+核心转储 | 退出信号(Ctrl+\)   |
| SIGKILL | 9      | 终止          | 强制杀死(不可捕获) |
| SIGTERM | 15     | 终止          | 终止信号(可捕获)   |
| SIGCHLD | 17     | 忽略          | 子进程状态改变     |
| SIGUSR1 | 10     | 终止          | 用户自定义信号1    |
| SIGUSR2 | 12     | 终止          | 用户自定义信号2    |
| SIGALRM | 14     | 终止          | 定时器信号         |

## 常用函数

**1.signal() 函数**

```cpp
#include <signal.h>
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
```

**参数说明：**

- `signum`: 信号编号
- `handler`: 信号处理函数指针，可以是：
  - 自定义函数指针
  - `SIG_DFL`: 默认处理
  - `SIG_IGN`: 忽略信号

**返回值：**

- 成功：返回之前的信号处理函数
- 失败：返回SIG_ERR

---

**2. sigaction() 函数**

```cpp
#include <signal.h>
int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);

struct sigaction {
    void (*sa_handler)(int);           // 信号处理函数
    void (*sa_sigaction)(int, siginfo_t *, void *); // 扩展处理函数
    sigset_t sa_mask;                  // 信号屏蔽集
    int sa_flags;                      // 标志位
    void (*sa_restorer)(void);         // 已废弃
};
```

**参数说明：**

- `signum`: 信号编号
- `act`: 新的信号处理方式
- `oldact`: 保存原来的信号处理方式

---

**3. kill() 函数**

```cpp
#include <signal.h>
int kill(pid_t pid, int sig);
```

**参数说明：**

- `pid`: 目标进程ID
  - `> 0`: 发送给指定进程
  - `= 0`: 发送给同组所有进程
  - `= -1`: 发送给所有有权限的进程
  - `< -1`: 发送给进程组|-pid|
- `sig`: 信号编号

---

**4. raise() 函数**

```cpp
#include <signal.h>
int raise(int sig);
```

**功能：** 向当前进程发送信号，等价于`kill(getpid(), sig)`

## 示例

```c++
#include <iostream>
#include <signal.h>
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>

using namespace std;

// 全局变量用于进程间通信
volatile sig_atomic_t message_count = 0;
volatile sig_atomic_t should_exit = 0;

// 父进程信号处理函数
void parent_handler(int sig) {
    switch(sig) {
        case SIGUSR1:
            message_count++;
            cout << "父进程收到子进程消息 #" << message_count << endl;
            break;
        case SIGUSR2:
            cout << "父进程收到子进程完成信号" << endl;
            should_exit = 1;
            break;
        case SIGCHLD:
            cout << "子进程状态改变" << endl;
            break;
    }
}

// 子进程信号处理函数
void child_handler(int sig) {
    switch(sig) {
        case SIGUSR1:
            cout << "子进程收到父进程指令" << endl;
            break;
        case SIGTERM:
            cout << "子进程收到终止信号" << endl;
            exit(0);
            break;
    }
}

int main() {
    pid_t pid;
    
    cout << "进程间信号通信示例" << endl;
    
    // 创建子进程
    pid = fork();
    
    if (pid == -1) {
        perror("fork失败");
        return -1;
    }
    
    if (pid == 0) {
        // 子进程
        cout << "子进程启动，PID: " << getpid() << endl;
        cout << "父进程PID: " << getppid() << endl;
        
        // 注册信号处理函数
        signal(SIGUSR1, child_handler);
        signal(SIGTERM, child_handler);
        
        // 子进程工作循环
        for(int i = 1; i <= 5; i++) {
            sleep(2);
            cout << "子进程工作步骤 " << i << "/5" << endl;
            
            // 向父进程发送进度信号
            kill(getppid(), SIGUSR1);
        }
        
        // 工作完成，通知父进程
        cout << "子进程工作完成" << endl;
        kill(getppid(), SIGUSR2);
        
        // 等待父进程指令
        while(true) {
            sleep(1);
        }
        
    } else {
        // 父进程
        cout << "父进程启动，PID: " << getpid() << endl;
        cout << "子进程PID: " << pid << endl;
        
        // 注册信号处理函数
        signal(SIGUSR1, parent_handler);
        signal(SIGUSR2, parent_handler);
        signal(SIGCHLD, parent_handler);
        
        // 等待子进程完成工作
        cout << "等待子进程完成工作..." << endl;
        
        while(!should_exit) {
            sleep(1);
        }
        
        cout << "总共收到 " << message_count << " 个进度消息" << endl;
        
        // 向子进程发送指令
        cout << "向子进程发送指令" << endl;
        kill(pid, SIGUSR1);
        sleep(1);
        
        // 终止子进程
        cout << "终止子进程" << endl;
        kill(pid, SIGTERM);
        
        // 等待子进程结束
        int status;
        wait(&status);
        cout << "子进程已结束，状态: " << status << endl;
    }
    
    return 0;
}
```



# 消息队列

消息队列是一种重要的进程间通信机制，允许进程通过消息进行异步通信。Linux提供了两种消息队列实现：System V消息队列和POSIX消息队列。

消息队列提供了可靠的异步通信机制，特别适合生产者-消费者模式的应用场景。

## System V消息队列
- **特点**: 消息有类型，支持优先级

### 常用函数

1. **`msgget()`** - 创建或获取消息队列

   ```cpp
   int msgget(key_t key, int msgflg);
   ```

   - `key`: 消息队列的键值（通常使用`ftok()`生成）
   - `msgflg`: 权限标志和创建标志
   - 返回值: 消息队列标识符

2. **`msgsnd()`** - 发送消息

   ```cpp
   int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
   ```

   - `msqid`: 消息队列标识符
   - `msgp`: 指向消息结构的指针
   - `msgsz`: 消息数据的大小
   - `msgflg`: 控制标志

3. **`msgrcv()`** - 接收消息

   ```cpp
   ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
   ```

   - `msgtyp`: 消息类型（0表示接收任意类型）

4. **`msgctl()`** - 控制消息队列

   ```cpp
   int msgctl(int msqid, int cmd, struct msqid_ds *buf);
   ```

   - `cmd`: 控制命令（如IPC_RMID删除队列）

### 示例

**发送端:**

```c++
#include <iostream>
#include <sys/msg.h>
#include <sys/ipc.h>
#include <cstring>
#include <unistd.h>

// 消息结构体
struct Message {
    long msg_type;      // 消息类型，必须大于0
    char msg_text[256]; // 消息内容
};

int main() {
    // 生成唯一键值
    key_t key = ftok("/tmp", 'A');
    if (key == -1) {
        perror("ftok failed");
        return 1;
    }

    // 创建或获取消息队列
    int msgid = msgget(key, IPC_CREAT | 0666);
    if (msgid == -1) {
        perror("msgget failed");
        return 1;
    }

    std::cout << "System V消息队列创建成功，ID: " << msgid << std::endl;

    Message msg;
    for (int i = 1; i <= 5; ++i) {
        msg.msg_type = i % 3 + 1;  // 消息类型1-3
        snprintf(msg.msg_text, sizeof(msg.msg_text), 
                "消息 %d，类型 %ld，PID: %d", i, msg.msg_type, getpid());

        // 发送消息
        if (msgsnd(msgid, &msg, strlen(msg.msg_text) + 1, 0) == -1) {
            perror("msgsnd failed");
            continue;
        }

        std::cout << "发送: " << msg.msg_text << std::endl;
        sleep(1);
    }

    std::cout << "所有消息发送完成" << std::endl;
    return 0;
}
```

**接收端:**

```c++
#include <iostream>
#include <sys/msg.h>
#include <sys/ipc.h>
#include <cstring>
#include <signal.h>

struct Message {
    long msg_type;
    char msg_text[256];
};

int msgid;
bool running = true;

void cleanup(int sig) {
    std::cout << "\n正在清理资源..." << std::endl;
    
    // 删除消息队列
    if (msgctl(msgid, IPC_RMID, nullptr) == -1) {
        perror("msgctl IPC_RMID failed");
    } else {
        std::cout << "消息队列已删除" << std::endl;
    }
    
    running = false;
}

int main() {
    // 设置信号处理
    signal(SIGINT, cleanup);
    signal(SIGTERM, cleanup);

    // 获取消息队列
    key_t key = ftok("/tmp", 'A');
    if (key == -1) {
        perror("ftok failed");
        return 1;
    }

    msgid = msgget(key, 0666);
    if (msgid == -1) {
        perror("msgget failed");
        return 1;
    }

    std::cout << "连接到消息队列，ID: " << msgid << std::endl;
    std::cout << "等待消息... (Ctrl+C退出)" << std::endl;

    Message msg;
    while (running) {
        // 接收任意类型的消息
        ssize_t bytes = msgrcv(msgid, &msg, sizeof(msg.msg_text), 0, IPC_NOWAIT);
        
        if (bytes > 0) {
            std::cout << "接收到消息 [类型 " << msg.msg_type << "]: " 
                      << msg.msg_text << std::endl;
        } else if (bytes == -1 && errno != ENOMSG) {
            perror("msgrcv failed");
            break;
        }
        
        usleep(100000);  // 100ms
    }

    return 0;
}
```

## POSIX消息队列

**特点**: 更现代的接口，支持异步通知

### 常用函数

1. **`mq_open()`** - 打开或创建消息队列

   ```cpp
   mqd_t mq_open(const char *name, int oflag, mode_t mode, struct mq_attr *attr);
   ```

   - `name`: 消息队列名称（以"/"开头）
   - `oflag`: 打开标志（`O_RDONLY`, `O_WRONLY`, `O_RDWR`等）

2. **`mq_send()`** - 发送消息

   ```cpp
   int mq_send(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned int msg_prio);
   ```

   - `msg_prio`: 消息优先级（0-31，数值越大优先级越高）

3. **`mq_receive()`** - 接收消息

   ```cpp
   ssize_t mq_receive(mqd_t mqdes, char *msg_ptr, size_t msg_len, unsigned int *msg_prio);
   ```

4. **`mq_close()`** - 关闭消息队列

   ```cpp
   int mq_close(mqd_t mqdes);
   ```

5. **`mq_unlink()`** - 删除消息队列

   ```cpp
   int mq_unlink(const char *name);
   ```

### 示例

**发送端:**

```c++
#include <iostream>
#include <mqueue.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <cstring>
#include <unistd.h>

int main() {
    const char* queue_name = "/test_queue";
    
    // 设置消息队列属性
    struct mq_attr attr;
    attr.mq_flags = 0;
    attr.mq_maxmsg = 10;    // 最大消息数
    attr.mq_msgsize = 256;  // 最大消息大小
    attr.mq_curmsgs = 0;

    // 创建或打开消息队列
    mqd_t mq = mq_open(queue_name, O_CREAT | O_WRONLY, 0644, &attr);
    if (mq == (mqd_t)-1) {
        perror("mq_open failed");
        return 1;
    }

    std::cout << "POSIX消息队列创建成功" << std::endl;

    // 发送不同优先级的消息
    for (int i = 1; i <= 5; ++i) {
        char message[256];
        unsigned int priority = i % 3;  // 优先级0-2
        
        snprintf(message, sizeof(message), 
                "POSIX消息 %d，优先级 %u，PID: %d", i, priority, getpid());

        if (mq_send(mq, message, strlen(message) + 1, priority) == -1) {
            perror("mq_send failed");
            continue;
        }

        std::cout << "发送: " << message << " [优先级: " << priority << "]" << std::endl;
        sleep(1);
    }

    // 关闭消息队列
    mq_close(mq);
    std::cout << "所有消息发送完成" << std::endl;
    
    return 0;
}
```

**接收端:**

```c++
#include <iostream>
#include <mqueue.h>
#include <fcntl.h>
#include <signal.h>
#include <cstring>

const char* queue_name = "/test_queue";
mqd_t mq;
bool running = true;

void cleanup(int sig) {
    std::cout << "\n正在清理资源..." << std::endl;
    
    // 关闭并删除消息队列
    mq_close(mq);
    if (mq_unlink(queue_name) == -1) {
        perror("mq_unlink failed");
    } else {
        std::cout << "消息队列已删除" << std::endl;
    }
    
    running = false;
}

int main() {
    // 设置信号处理
    signal(SIGINT, cleanup);
    signal(SIGTERM, cleanup);

    // 打开消息队列
    mq = mq_open(queue_name, O_RDONLY);
    if (mq == (mqd_t)-1) {
        perror("mq_open failed");
        return 1;
    }

    // 获取队列属性
    struct mq_attr attr;
    if (mq_getattr(mq, &attr) == -1) {
        perror("mq_getattr failed");
        return 1;
    }

    std::cout << "连接到POSIX消息队列" << std::endl;
    std::cout << "最大消息数: " << attr.mq_maxmsg << std::endl;
    std::cout << "最大消息大小: " << attr.mq_msgsize << std::endl;
    std::cout << "等待消息... (Ctrl+C退出)" << std::endl;

    char buffer[attr.mq_msgsize];
    unsigned int priority;
    
    while (running) {
        // 设置超时时间
        struct timespec timeout;
        clock_gettime(CLOCK_REALTIME, &timeout);
        timeout.tv_sec += 1;  // 1秒超时

        ssize_t bytes = mq_timedreceive(mq, buffer, attr.mq_msgsize, &priority, &timeout);
        
        if (bytes > 0) {
            buffer[bytes] = '\0';
            std::cout << "接收到消息 [优先级 " << priority << "]: " 
                      << buffer << std::endl;
        } else if (bytes == -1 && errno != ETIMEDOUT) {
            perror("mq_timedreceive failed");
            break;
        }
    }

    return 0;
}
```

# 共享内存

共享内存是最快的进程间通信方式，允许多个进程直接访问同一块物理内存区域。

> [!note]
>
> 共享内存本身不提供同步机制，需要配合其他IPC方式：
>
> 1. **信号量**: 控制对共享内存的访问
> 2. **互斥锁**: 保护临界区
> 3. **条件变量**: 等待特定条件
> 4. **文件锁**: 基于文件的锁机制

## System V共享内存

### 常用函数

1. **`shmget()`** - 创建或获取共享内存段

   ```cpp
   int shmget(key_t key, size_t size, int shmflg);
   ```

   - `key`: 共享内存的键值（通常使用`ftok()`生成）
   - `size`: 共享内存段的大小（字节）
   - `shmflg`: 权限标志和创建标志
   - 返回值: 共享内存标识符

2. **`shmat()`** - 连接共享内存段到进程地址空间

   ```cpp
   void *shmat(int shmid, const void *shmaddr, int shmflg);
   ```

   - `shmid`: 共享内存标识符
   - `shmaddr`: 指定连接地址（通常为`NULL`，让系统选择）
   - `shmflg`: 连接标志（如`SHM_RDONLY`只读）
   - 返回值: 共享内存段的起始地址

3. **`shmdt()`** - 断开共享内存段连接

   ```cpp
   int shmdt(const void *shmaddr);
   ```

   - `shmaddr`: 要断开的共享内存地址

4. **`shmctl()`** - 控制共享内存段

   ```cpp
   int shmctl(int shmid, int cmd, struct shmid_ds *buf);
   ```

   - `cmd`: 控制命令（如IPC_RMID删除共享内存）

### 示例

**写进程:**

```c++
#include <iostream>
#include <sys/shm.h>
#include <sys/ipc.h>
#include <cstring>
#include <unistd.h>
#include <signal.h>

// 共享数据结构
struct SharedData {
    int counter;
    char message[256];
    bool ready;
    bool finished;
};

int shmid;
SharedData* shared_data;

void cleanup(int sig) {
    std::cout << "\n正在清理资源..." << std::endl;
    
    if (shared_data) {
        shared_data->finished = true;
        shmdt(shared_data);
    }
    
    // 删除共享内存
    if (shmctl(shmid, IPC_RMID, nullptr) == -1) {
        perror("shmctl IPC_RMID failed");
    } else {
        std::cout << "共享内存已删除" << std::endl;
    }
    
    exit(0);
}

int main() {
    // 设置信号处理
    signal(SIGINT, cleanup);
    signal(SIGTERM, cleanup);

    // 生成唯一键值
    key_t key = ftok("/tmp", 'S');
    if (key == -1) {
        perror("ftok failed");
        return 1;
    }

    // 创建共享内存段
    shmid = shmget(key, sizeof(SharedData), IPC_CREAT | 0666);
    if (shmid == -1) {
        perror("shmget failed");
        return 1;
    }

    // 连接共享内存
    shared_data = (SharedData*)shmat(shmid, nullptr, 0);
    if (shared_data == (SharedData*)-1) {
        perror("shmat failed");
        return 1;
    }

    std::cout << "System V共享内存创建成功，ID: " << shmid << std::endl;
    std::cout << "共享内存地址: " << shared_data << std::endl;

    // 初始化共享数据
    shared_data->counter = 0;
    shared_data->ready = false;
    shared_data->finished = false;
    strcpy(shared_data->message, "初始化消息");

    // 写入数据
    for (int i = 1; i <= 10; ++i) {
        shared_data->counter = i;
        snprintf(shared_data->message, sizeof(shared_data->message),
                "写进程消息 %d，PID: %d", i, getpid());
        shared_data->ready = true;

        std::cout << "写入: counter=" << shared_data->counter 
                  << ", message=" << shared_data->message << std::endl;
        
        sleep(2);
        
        // 等待读进程处理
        while (shared_data->ready && !shared_data->finished) {
            usleep(100000);  // 100ms
        }
        
        if (shared_data->finished) {
            break;
        }
    }

    shared_data->finished = true;
    std::cout << "写进程完成" << std::endl;
    
    // 保持程序运行，等待手动清理
    std::cout << "按Ctrl+C退出并清理资源" << std::endl;
    while (true) {
        sleep(1);
    }

    return 0;
}
```

**读进程:**

```c++
#include <iostream>
#include <sys/shm.h>
#include <sys/ipc.h>
#include <unistd.h>
#include <signal.h>

struct SharedData {
    int counter;
    char message[256];
    bool ready;
    bool finished;
};

SharedData* shared_data;
bool running = true;

void cleanup(int sig) {
    std::cout << "\n读进程退出" << std::endl;
    if (shared_data) {
        shmdt(shared_data);
    }
    running = false;
}

int main() {
    signal(SIGINT, cleanup);
    signal(SIGTERM, cleanup);

    // 获取共享内存
    key_t key = ftok("/tmp", 'S');
    if (key == -1) {
        perror("ftok failed");
        return 1;
    }

    int shmid = shmget(key, sizeof(SharedData), 0666);
    if (shmid == -1) {
        perror("shmget failed - 请先运行写进程");
        return 1;
    }

    // 连接共享内存
    shared_data = (SharedData*)shmat(shmid, nullptr, 0);
    if (shared_data == (SharedData*)-1) {
        perror("shmat failed");
        return 1;
    }

    std::cout << "连接到共享内存，ID: " << shmid << std::endl;
    std::cout << "共享内存地址: " << shared_data << std::endl;
    std::cout << "等待数据... (Ctrl+C退出)" << std::endl;

    int last_counter = -1;
    
    while (running && !shared_data->finished) {
        if (shared_data->ready && shared_data->counter != last_counter) {
            std::cout << "读取: counter=" << shared_data->counter 
                      << ", message=" << shared_data->message << std::endl;
            
            last_counter = shared_data->counter;
            shared_data->ready = false;  // 标记已处理
        }
        
        usleep(100000);  // 100ms
    }

    std::cout << "读进程完成" << std::endl;
    shmdt(shared_data);
    return 0;
}
```

## POSIX共享内存

- **特点**: 基于文件系统，更易使用

### 常用函数

1. **`shm_open()`** - 创建或打开共享内存对象

   ```cpp
   int shm_open(const char *name, int oflag, mode_t mode);
   ```

   - `name`: 共享内存对象名称（以"/"开头）
   - `oflag`: 打开标志（`O_CREAT`, `O_RDWR`等）
   - `mode`: 权限模式
   - 返回值: 文件描述符

2. **`ftruncate()`** - 设置共享内存对象大小

   ```cpp
   int ftruncate(int fd, off_t length);
   ```

3. **`mmap()`** - 将共享内存映射到进程地址空间

   ```cpp
   void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
   ```

   - `prot`: 内存保护标志（`PROT_READ`, `PROT_WRITE`等）
   - `flags`: 映射标志（`MAP_SHARED`等）

4. **`munmap()`** - 取消内存映射

   ```cpp
   int munmap(void *addr, size_t length);
   ```

5. **`shm_unlink()`** - 删除共享内存对象

   ```cpp
   int shm_unlink(const char *name);
   ```

### 示例

**写进程:**

```c++
#include <iostream>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <cstring>
#include <signal.h>
#include <semaphore.h>

struct SharedData {
    int counter;
    char message[256];
    bool finished;
};

const char* shm_name = "/posix_shared_memory";
const char* sem_name = "/posix_semaphore";
int shm_fd;
SharedData* shared_data;
sem_t* semaphore;

void cleanup(int sig) {
    std::cout << "\n正在清理资源..." << std::endl;
    
    if (shared_data) {
        shared_data->finished = true;
        munmap(shared_data, sizeof(SharedData));
    }
    
    if (shm_fd != -1) {
        close(shm_fd);
    }
    
    // 删除共享内存和信号量
    shm_unlink(shm_name);
    sem_close(semaphore);
    sem_unlink(sem_name);
    
    std::cout << "POSIX共享内存和信号量已删除" << std::endl;
    exit(0);
}

int main() {
    signal(SIGINT, cleanup);
    signal(SIGTERM, cleanup);

    // 创建信号量用于同步
    semaphore = sem_open(sem_name, O_CREAT, 0644, 1);
    if (semaphore == SEM_FAILED) {
        perror("sem_open failed");
        return 1;
    }

    // 创建共享内存对象
    shm_fd = shm_open(shm_name, O_CREAT | O_RDWR, 0644);
    if (shm_fd == -1) {
        perror("shm_open failed");
        return 1;
    }

    // 设置共享内存大小
    if (ftruncate(shm_fd, sizeof(SharedData)) == -1) {
        perror("ftruncate failed");
        return 1;
    }

    // 映射共享内存
    shared_data = (SharedData*)mmap(nullptr, sizeof(SharedData),
                                   PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    if (shared_data == MAP_FAILED) {
        perror("mmap failed");
        return 1;
    }

    std::cout << "POSIX共享内存创建成功" << std::endl;
    std::cout << "共享内存地址: " << shared_data << std::endl;

    // 初始化共享数据
    shared_data->counter = 0;
    shared_data->finished = false;
    strcpy(shared_data->message, "POSIX初始化消息");

    // 写入数据
    for (int i = 1; i <= 10; ++i) {
        // 获取信号量
        sem_wait(semaphore);
        
        shared_data->counter = i;
        snprintf(shared_data->message, sizeof(shared_data->message),
                "POSIX写进程消息 %d，PID: %d", i, getpid());

        std::cout << "写入: counter=" << shared_data->counter 
                  << ", message=" << shared_data->message << std::endl;
        
        // 释放信号量
        sem_post(semaphore);
        
        sleep(2);
        
        if (shared_data->finished) {
            break;
        }
    }

    shared_data->finished = true;
    std::cout << "写进程完成，按Ctrl+C退出并清理资源" << std::endl;
    
    // 保持程序运行
    while (true) {
        sleep(1);
    }

    return 0;
}
```

**读进程:**

```c++
#include <iostream>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>
#include <semaphore.h>

struct SharedData {
    int counter;
    char message[256];
    bool finished;
};

const char* shm_name = "/posix_shared_memory";
const char* sem_name = "/posix_semaphore";
SharedData* shared_data;
sem_t* semaphore;
bool running = true;

void cleanup(int sig) {
    std::cout << "\n读进程退出" << std::endl;
    if (shared_data) {
        munmap(shared_data, sizeof(SharedData));
    }
    if (semaphore) {
        sem_close(semaphore);
    }
    running = false;
}

int main() {
    signal(SIGINT, cleanup);
    signal(SIGTERM, cleanup);

    // 打开信号量
    semaphore = sem_open(sem_name, 0);
    if (semaphore == SEM_FAILED) {
        perror("sem_open failed - 请先运行写进程");
        return 1;
    }

    // 打开共享内存对象
    int shm_fd = shm_open(shm_name, O_RDONLY, 0644);
    if (shm_fd == -1) {
        perror("shm_open failed - 请先运行写进程");
        return 1;
    }

    // 映射共享内存
    shared_data = (SharedData*)mmap(nullptr, sizeof(SharedData),
                                   PROT_READ, MAP_SHARED, shm_fd, 0);
    if (shared_data == MAP_FAILED) {
        perror("mmap failed");
        return 1;
    }

    close(shm_fd);  // 映射后可以关闭文件描述符

    std::cout << "连接到POSIX共享内存" << std::endl;
    std::cout << "共享内存地址: " << shared_data << std::endl;
    std::cout << "等待数据... (Ctrl+C退出)" << std::endl;

    int last_counter = -1;
    
    while (running && !shared_data->finished) {
        // 获取信号量
        if (sem_trywait(semaphore) == 0) {
            if (shared_data->counter != last_counter) {
                std::cout << "读取: counter=" << shared_data->counter 
                          << ", message=" << shared_data->message << std::endl;
                last_counter = shared_data->counter;
            }
            
            // 释放信号量
            sem_post(semaphore);
        }
        
        usleep(500000);  // 500ms
    }

    std::cout << "读进程完成" << std::endl;
    cleanup(0);
    return 0;
}
```



# 信号量

信号量是一种用于进程同步的重要机制，主要用于控制对共享资源的访问。

## System V信号量
- **特点**: 支持信号量集合

### 常用函数

1. **`semget()`** - 创建或获取信号量集

   ```cpp
   int semget(key_t key, int nsems, int semflg);
   ```

   - `key`: 信号量集的键值（通常使用`ftok()`生成）
   - `nsems`: 信号量集中信号量的数量
   - `semflg`: 权限标志和创建标志
   - 返回值: 信号量集标识符

2. **`semop()`** - 对信号量进行操作

   ```cpp
   int semop(int semid, struct sembuf *sops, size_t nsops);
   ```

   - `semid`: 信号量集标识符
   - `sops`: 指向操作数组的指针
   - `nsops`: 操作数量

3. **`semctl()`** - 控制信号量集

   ```cpp
   int semctl(int semid, int semnum, int cmd, ...);
   ```

   - `semnum`: 信号量编号
   - `cmd`: 控制命令（如SETVAL设置值、IPC_RMID删除）

**sembuf结构体**

```cpp
struct sembuf {
    unsigned short sem_num;  // 信号量编号
    short sem_op;           // 操作值
    short sem_flg;          // 操作标志
};
```

### 示例

**生产者-消费者模型**

```c++
#include <iostream>
#include <sys/sem.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <unistd.h>
#include <signal.h>
#include <cstring>

// 信号量索引
#define SEM_MUTEX 0     // 互斥信号量
#define SEM_EMPTY 1     // 空缓冲区数量
#define SEM_FULL  2     // 满缓冲区数量

// 共享缓冲区
struct SharedBuffer {
    int buffer[10];
    int in;   // 生产者索引
    int out;  // 消费者索引
    int count; // 当前元素数量
};

int semid, shmid;
SharedBuffer* shared_buf;

// 信号量操作辅助函数
void sem_wait(int semid, int sem_num) {
    struct sembuf sb;
    sb.sem_num = sem_num;
    sb.sem_op = -1;  // P操作（等待）
    sb.sem_flg = 0;
    semop(semid, &sb, 1);
}

void sem_signal(int semid, int sem_num) {
    struct sembuf sb;
    sb.sem_num = sem_num;
    sb.sem_op = 1;   // V操作（信号）
    sb.sem_flg = 0;
    semop(semid, &sb, 1);
}

void cleanup(int sig) {
    std::cout << "\n正在清理资源..." << std::endl;
    
    if (shared_buf) {
        shmdt(shared_buf);
    }
    
    // 删除信号量集和共享内存
    semctl(semid, 0, IPC_RMID);
    shmctl(shmid, IPC_RMID, nullptr);
    
    std::cout << "资源清理完成" << std::endl;
    exit(0);
}

int main() {
    signal(SIGINT, cleanup);
    signal(SIGTERM, cleanup);

    // 生成键值
    key_t key = ftok("/tmp", 'P');
    if (key == -1) {
        perror("ftok failed");
        return 1;
    }

    // 创建信号量集（3个信号量）
    semid = semget(key, 3, IPC_CREAT | 0666);
    if (semid == -1) {
        perror("semget failed");
        return 1;
    }

    // 初始化信号量
    semctl(semid, SEM_MUTEX, SETVAL, 1);  // 互斥信号量初始值为1
    semctl(semid, SEM_EMPTY, SETVAL, 10); // 空缓冲区初始值为10
    semctl(semid, SEM_FULL, SETVAL, 0);   // 满缓冲区初始值为0

    // 创建共享内存
    shmid = shmget(key + 1, sizeof(SharedBuffer), IPC_CREAT | 0666);
    if (shmid == -1) {
        perror("shmget failed");
        return 1;
    }

    shared_buf = (SharedBuffer*)shmat(shmid, nullptr, 0);
    if (shared_buf == (SharedBuffer*)-1) {
        perror("shmat failed");
        return 1;
    }

    // 初始化共享缓冲区
    shared_buf->in = 0;
    shared_buf->out = 0;
    shared_buf->count = 0;
    memset(shared_buf->buffer, 0, sizeof(shared_buf->buffer));

    std::cout << "System V信号量生产者启动" << std::endl;
    std::cout << "信号量集ID: " << semid << ", 共享内存ID: " << shmid << std::endl;

    // 生产数据
    for (int i = 1; i <= 20; ++i) {
        // 等待空缓冲区
        sem_wait(semid, SEM_EMPTY);
        
        // 获取互斥锁
        sem_wait(semid, SEM_MUTEX);
        
        // 临界区：生产数据
        shared_buf->buffer[shared_buf->in] = i;
        std::cout << "生产: " << i << " -> buffer[" << shared_buf->in << "]" 
                  << ", 当前数量: " << (shared_buf->count + 1) << std::endl;
        shared_buf->in = (shared_buf->in + 1) % 10;
        shared_buf->count++;
        
        // 释放互斥锁
        sem_signal(semid, SEM_MUTEX);
        
        // 信号满缓冲区
        sem_signal(semid, SEM_FULL);
        
        sleep(1);
    }

    std::cout << "生产完成，按Ctrl+C退出" << std::endl;
    
    // 保持程序运行
    while (true) {
        sleep(1);
    }

    return 0;
}
```

**消费者:**

```c++
#include <iostream>
#include <sys/sem.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <unistd.h>
#include <signal.h>

#define SEM_MUTEX 0
#define SEM_EMPTY 1
#define SEM_FULL  2

struct SharedBuffer {
    int buffer[10];
    int in;
    int out;
    int count;
};

SharedBuffer* shared_buf;
bool running = true;

void sem_wait(int semid, int sem_num) {
    struct sembuf sb;
    sb.sem_num = sem_num;
    sb.sem_op = -1;
    sb.sem_flg = 0;
    semop(semid, &sb, 1);
}

void sem_signal(int semid, int sem_num) {
    struct sembuf sb;
    sb.sem_num = sem_num;
    sb.sem_op = 1;
    sb.sem_flg = 0;
    semop(semid, &sb, 1);
}

void cleanup(int sig) {
    std::cout << "\n消费者退出" << std::endl;
    if (shared_buf) {
        shmdt(shared_buf);
    }
    running = false;
}

int main() {
    signal(SIGINT, cleanup);
    signal(SIGTERM, cleanup);

    // 获取信号量集和共享内存
    key_t key = ftok("/tmp", 'P');
    if (key == -1) {
        perror("ftok failed");
        return 1;
    }

    int semid = semget(key, 3, 0666);
    if (semid == -1) {
        perror("semget failed - 请先运行生产者");
        return 1;
    }

    int shmid = shmget(key + 1, sizeof(SharedBuffer), 0666);
    if (shmid == -1) {
        perror("shmget failed");
        return 1;
    }

    shared_buf = (SharedBuffer*)shmat(shmid, nullptr, 0);
    if (shared_buf == (SharedBuffer*)-1) {
        perror("shmat failed");
        return 1;
    }

    std::cout << "System V信号量消费者启动" << std::endl;
    std::cout << "等待数据... (Ctrl+C退出)" << std::endl;

    int consumed_count = 0;
    
    while (running) {
        // 等待满缓冲区
        struct sembuf sb;
        sb.sem_num = SEM_FULL;
        sb.sem_op = -1;
        sb.sem_flg = IPC_NOWAIT;  // 非阻塞
        
        if (semop(semid, &sb, 1) == -1) {
            if (errno == EAGAIN) {
                usleep(100000);  // 100ms
                continue;
            } else {
                perror("semop failed");
                break;
            }
        }
        
        // 获取互斥锁
        sem_wait(semid, SEM_MUTEX);
        
        // 临界区：消费数据
        int data = shared_buf->buffer[shared_buf->out];
        std::cout << "消费: " << data << " <- buffer[" << shared_buf->out << "]" 
                  << ", 剩余数量: " << (shared_buf->count - 1) << std::endl;
        shared_buf->out = (shared_buf->out + 1) % 10;
        shared_buf->count--;
        consumed_count++;
        
        // 释放互斥锁
        sem_signal(semid, SEM_MUTEX);
        
        // 信号空缓冲区
        sem_signal(semid, SEM_EMPTY);
        
        sleep(2);  // 消费速度比生产慢
    }

    std::cout << "总共消费了 " << consumed_count << " 个数据" << std::endl;
    return 0;
}
```

## POSIX信号量
- **特点**: 更简单的接口

### 常用函数

1. **`sem_open()`** - 创建或打开命名信号量

   ```cpp
   sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value);
   ```

   - `name`: 信号量名称（以"/"开头）
   - `oflag`: 打开标志（O_CREAT等）
   - `value`: 初始值

2. **`sem_wait()`** - 等待信号量（P操作）

   ```cpp
   int sem_wait(sem_t *sem);
   ```

3. **`sem_trywait()`** - 非阻塞等待

   ```cpp
   int sem_trywait(sem_t *sem);
   ```

4. **`sem_post()`** - 释放信号量（V操作）

   ```cpp
   int sem_post(sem_t *sem);
   ```

5. **`sem_close()`** - 关闭信号量

   ```cpp
   int sem_close(sem_t *sem);
   ```

6. **`sem_unlink()`** - 删除命名信号量

   ```cpp
   int sem_unlink(const char *name);
   ```

### 示例

**生产者:**

```c++
#include <iostream>
#include <semaphore.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>
#include <cstring>

struct SharedBuffer {
    int buffer[10];
    int in;
    int out;
    int count;
};

const char* shm_name = "/posix_buffer";
const char* sem_mutex_name = "/posix_mutex";
const char* sem_empty_name = "/posix_empty";
const char* sem_full_name = "/posix_full";

int shm_fd;
SharedBuffer* shared_buf;
sem_t *sem_mutex, *sem_empty, *sem_full;

void cleanup(int sig) {
    std::cout << "\n正在清理资源..." << std::endl;
    
    if (shared_buf) {
        munmap(shared_buf, sizeof(SharedBuffer));
    }
    
    if (shm_fd != -1) {
        close(shm_fd);
    }
    
    // 删除信号量和共享内存
    sem_close(sem_mutex);
    sem_close(sem_empty);
    sem_close(sem_full);
    
    sem_unlink(sem_mutex_name);
    sem_unlink(sem_empty_name);
    sem_unlink(sem_full_name);
    shm_unlink(shm_name);
    
    std::cout << "POSIX资源清理完成" << std::endl;
    exit(0);
}

int main() {
    signal(SIGINT, cleanup);
    signal(SIGTERM, cleanup);

    // 创建信号量
    sem_mutex = sem_open(sem_mutex_name, O_CREAT, 0644, 1);  // 互斥
    sem_empty = sem_open(sem_empty_name, O_CREAT, 0644, 10); // 空缓冲区
    sem_full = sem_open(sem_full_name, O_CREAT, 0644, 0);    // 满缓冲区
    
    if (sem_mutex == SEM_FAILED || sem_empty == SEM_FAILED || sem_full == SEM_FAILED) {
        perror("sem_open failed");
        return 1;
    }

    // 创建共享内存
    shm_fd = shm_open(shm_name, O_CREAT | O_RDWR, 0644);
    if (shm_fd == -1) {
        perror("shm_open failed");
        return 1;
    }

    if (ftruncate(shm_fd, sizeof(SharedBuffer)) == -1) {
        perror("ftruncate failed");
        return 1;
    }

    shared_buf = (SharedBuffer*)mmap(nullptr, sizeof(SharedBuffer),
                                    PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    if (shared_buf == MAP_FAILED) {
        perror("mmap failed");
        return 1;
    }

    // 初始化共享缓冲区
    shared_buf->in = 0;
    shared_buf->out = 0;
    shared_buf->count = 0;
    memset(shared_buf->buffer, 0, sizeof(shared_buf->buffer));

    std::cout << "POSIX信号量生产者启动" << std::endl;

    // 生产数据
    for (int i = 1; i <= 20; ++i) {
        // 等待空缓冲区
        sem_wait(sem_empty);
        
        // 获取互斥锁
        sem_wait(sem_mutex);
        
        // 临界区：生产数据
        shared_buf->buffer[shared_buf->in] = i;
        std::cout << "生产: " << i << " -> buffer[" << shared_buf->in << "]" 
                  << ", 当前数量: " << (shared_buf->count + 1) << std::endl;
        shared_buf->in = (shared_buf->in + 1) % 10;
        shared_buf->count++;
        
        // 释放互斥锁
        sem_post(sem_mutex);
        
        // 信号满缓冲区
        sem_post(sem_full);
        
        sleep(1);
    }

    std::cout << "生产完成，按Ctrl+C退出" << std::endl;
    
    // 保持程序运行
    while (true) {
        sleep(1);
    }

    return 0;
}
```

**消费者:**

```c++
#include <iostream>
#include <semaphore.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>

struct SharedBuffer {
    int buffer[10];
    int in;
    int out;
    int count;
};

const char* shm_name = "/posix_buffer";
const char* sem_mutex_name = "/posix_mutex";
const char* sem_empty_name = "/posix_empty";
const char* sem_full_name = "/posix_full";

SharedBuffer* shared_buf;
sem_t *sem_mutex, *sem_empty, *sem_full;
bool running = true;

void cleanup(int sig) {
    std::cout << "\n消费者退出" << std::endl;
    
    if (shared_buf) {
        munmap(shared_buf, sizeof(SharedBuffer));
    }
    
    if (sem_mutex) sem_close(sem_mutex);
    if (sem_empty) sem_close(sem_empty);
    if (sem_full) sem_close(sem_full);
    
    running = false;
}

int main() {
    signal(SIGINT, cleanup);
    signal(SIGTERM, cleanup);

    // 打开信号量
    sem_mutex = sem_open(sem_mutex_name, 0);
    sem_empty = sem_open(sem_empty_name, 0);
    sem_full = sem_open(sem_full_name, 0);
    
    if (sem_mutex == SEM_FAILED || sem_empty == SEM_FAILED || sem_full == SEM_FAILED) {
        perror("sem_open failed - 请先运行生产者");
        return 1;
    }

    // 打开共享内存
    int shm_fd = shm_open(shm_name, O_RDWR, 0644);
    if (shm_fd == -1) {
        perror("shm_open failed");
        return 1;
    }

    shared_buf = (SharedBuffer*)mmap(nullptr, sizeof(SharedBuffer),
                                    PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    if (shared_buf == MAP_FAILED) {
        perror("mmap failed");
        return 1;
    }

    close(shm_fd);

    std::cout << "POSIX信号量消费者启动" << std::endl;
    std::cout << "等待数据... (Ctrl+C退出)" << std::endl;

    int consumed_count = 0;
    
    while (running) {
        // 非阻塞等待满缓冲区
        if (sem_trywait(sem_full) == -1) {
            if (errno == EAGAIN) {
                usleep(100000);  // 100ms
                continue;
            } else {
                perror("sem_trywait failed");
                break;
            }
        }
        
        // 获取互斥锁
        sem_wait(sem_mutex);
        
        // 临界区：消费数据
        int data = shared_buf->buffer[shared_buf->out];
        std::cout << "消费: " << data << " <- buffer[" << shared_buf->out << "]" 
                  << ", 剩余数量: " << (shared_buf->count - 1) << std::endl;
        shared_buf->out = (shared_buf->out + 1) % 10;
        shared_buf->count--;
        consumed_count++;
        
        // 释放互斥锁
        sem_post(sem_mutex);
        
        // 信号空缓冲区
        sem_post(sem_empty);
        
        sleep(2);  // 消费速度比生产慢
    }

    std::cout << "总共消费了 " << consumed_count << " 个数据" << std::endl;
    cleanup(0);
    return 0;
}
```

## 信号量操作类型

**P操作（等待/减少）**

- **System V**: `sem_op = -1`
- **POSIX**: `sem_wait()`
- 如果信号量值 > 0，则减1并继续
- 如果信号量值 = 0，则阻塞等待

---

**V操作（信号/增加）**

- **System V**: `sem_op = 1`
- **POSIX**: `sem_post()`
- 信号量值加1
- 如果有等待的进程，唤醒一个

# 套接字

## Unix域套接字

### 概述与常用函数

Unix域套接字（Unix Domain Socket）是一种高效的本地进程间通信机制，它使用文件系统路径作为地址，仅在本地机器上工作，性能优于网络套接字。

- **特点**: 本地进程间通信，性能优于网络套接字

- 套接字类型

  1. `SOCK_STREAM` - 流式套接字
     - 提供可靠的、有序的、双向的字节流
     - 类似于TCP，但用于本地通信
     - 面向连接

  2. `SOCK_DGRAM` - 数据报套接字
     
     - 提供无连接的数据报服务
     - 类似于UDP，但用于本地通信
     - 保证数据完整性，但不保证顺序

- 地址结构

```cpp
struct sockaddr_un {
    sa_family_t sun_family;  // AF_UNIX
    char sun_path[108];      // 套接字文件路径
};
```

**常用函数**

1. **`socket()`** - 创建套接字

   ```cpp
   int socket(int domain, int type, int protocol);
   ```

   - `domain`: AF_UNIX（Unix域）
   - `type`: `SOCK_STREAM` 或 `SOCK_DGRAM`
   - `protocol`: 通常为0

2. **`bind()`** - 绑定地址

   ```cpp
   int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
   ```

3. **`listen()`** - 监听连接（仅`SOCK_STREAM`）

   ```cpp
   int listen(int sockfd, int backlog);
   ```

4. **`accept()`** - 接受连接（仅`SOCK_STREAM`）

   ```cpp
   int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
   ```

5. **`connect()`** - 连接到服务器

   ```cpp
   int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
   ```

6. **`send()`/`recv()`** - 发送/接收数据

   ```cpp
   ssize_t send(int sockfd, const void *buf, size_t len, int flags);
   ssize_t recv(int sockfd, void *buf, size_t len, int flags);
   ```

7. **`sendto()`/`recvfrom()`** - 数据报发送/接收

   ```cpp
   ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                  const struct sockaddr *dest_addr, socklen_t addrlen);
   ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                    struct sockaddr *src_addr, socklen_t *addrlen);
   ```

### 示例

**服务器端**

```c++
#include <iostream>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>
#include <signal.h>
#include <cstring>
#include <thread>
#include <vector>

const char* SOCKET_PATH = "/tmp/unix_stream_socket";
int server_fd;
std::vector<std::thread> client_threads;

void cleanup(int sig) {
    std::cout << "\n正在清理资源..." << std::endl;
    
    // 关闭服务器套接字
    if (server_fd != -1) {
        close(server_fd);
    }
    
    // 删除套接字文件
    unlink(SOCKET_PATH);
    
    std::cout << "服务器已关闭" << std::endl;
    exit(0);
}

void handle_client(int client_fd, int client_id) {
    char buffer[1024];
    
    std::cout << "客户端 " << client_id << " 已连接" << std::endl;
    
    while (true) {
        ssize_t bytes = recv(client_fd, buffer, sizeof(buffer) - 1, 0);
        
        if (bytes <= 0) {
            if (bytes == 0) {
                std::cout << "客户端 " << client_id << " 断开连接" << std::endl;
            } else {
                perror("recv failed");
            }
            break;
        }
        
        buffer[bytes] = '\0';
        std::cout << "客户端 " << client_id << ": " << buffer << std::endl;
        
        // 回显消息
        std::string response = "服务器回复[客户端" + std::to_string(client_id) + "]: " + std::string(buffer);
        send(client_fd, response.c_str(), response.length(), 0);
    }
    
    close(client_fd);
}

int main() {
    signal(SIGINT, cleanup);
    signal(SIGTERM, cleanup);

    // 删除可能存在的旧套接字文件
    unlink(SOCKET_PATH);

    // 创建套接字
    server_fd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (server_fd == -1) {
        perror("socket failed");
        return 1;
    }

    // 设置地址
    struct sockaddr_un addr;
    memset(&addr, 0, sizeof(addr));
    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, SOCKET_PATH, sizeof(addr.sun_path) - 1);

    // 绑定地址
    if (bind(server_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1) {
        perror("bind failed");
        close(server_fd);
        return 1;
    }

    // 监听连接
    if (listen(server_fd, 5) == -1) {
        perror("listen failed");
        close(server_fd);
        unlink(SOCKET_PATH);
        return 1;
    }

    std::cout << "Unix域流式套接字服务器启动" << std::endl;
    std::cout << "套接字路径: " << SOCKET_PATH << std::endl;
    std::cout << "等待客户端连接... (Ctrl+C退出)" << std::endl;

    int client_id = 1;
    
    while (true) {
        // 接受客户端连接
        int client_fd = accept(server_fd, nullptr, nullptr);
        if (client_fd == -1) {
            perror("accept failed");
            continue;
        }

        // 为每个客户端创建线程
        client_threads.emplace_back(handle_client, client_fd, client_id++);
        client_threads.back().detach();
    }

    return 0;
}
```

**客户端**

```c++
#include <iostream>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>
#include <cstring>
#include <thread>

const char* SOCKET_PATH = "/tmp/unix_stream_socket";

void receive_messages(int sockfd) {
    char buffer[1024];
    
    while (true) {
        ssize_t bytes = recv(sockfd, buffer, sizeof(buffer) - 1, 0);
        
        if (bytes <= 0) {
            if (bytes == 0) {
                std::cout << "服务器关闭连接" << std::endl;
            } else {
                perror("recv failed");
            }
            break;
        }
        
        buffer[bytes] = '\0';
        std::cout << buffer << std::endl;
    }
}

int main() {
    // 创建套接字
    int sockfd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sockfd == -1) {
        perror("socket failed");
        return 1;
    }

    // 设置服务器地址
    struct sockaddr_un addr;
    memset(&addr, 0, sizeof(addr));
    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, SOCKET_PATH, sizeof(addr.sun_path) - 1);

    // 连接到服务器
    if (connect(sockfd, (struct sockaddr*)&addr, sizeof(addr)) == -1) {
        perror("connect failed - 请先启动服务器");
        close(sockfd);
        return 1;
    }

    std::cout << "已连接到Unix域流式套接字服务器" << std::endl;
    std::cout << "输入消息 (输入'quit'退出): " << std::endl;

    // 启动接收线程
    std::thread recv_thread(receive_messages, sockfd);
    recv_thread.detach();

    // 发送消息
    std::string message;
    while (std::getline(std::cin, message)) {
        if (message == "quit") {
            break;
        }
        
        if (!message.empty()) {
            if (send(sockfd, message.c_str(), message.length(), 0) == -1) {
                perror("send failed");
                break;
            }
        }
    }

    close(sockfd);
    std::cout << "客户端已断开连接" << std::endl;
    return 0;
}
```

## 网络套接字
- **特点**: 可以跨网络通信，也可用于本地通信
- **协议**: TCP、UDP

# 内存映射

内存映射（Memory Mapping）是一种高效的进程间通信机制，它将文件或设备映射到进程的虚拟地址空间，使得多个进程可以通过共享内存的方式访问同一个文件。

- **特点**: 将文件映射到内存，多个进程可以共享
- **适用场景**: 大文件共享，数据库系统

## 常用函数

**`mmap()` - 创建内存映射**

```cpp
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
```

**参数说明：**

- `addr`: 指定映射的起始地址（通常为NULL，让系统选择）
- `length`: 映射的长度（字节数）
- `prot`: 内存保护标志
  - `PROT_READ`: 可读
  - `PROT_WRITE`: 可写
  - `PROT_EXEC`: 可执行
  - `PROT_NONE`: 不可访问
- `flags`: 映射标志
  - `MAP_SHARED`: 共享映射（多进程可见）
  - `MAP_PRIVATE`: 私有映射（写时复制）
  - `MAP_ANONYMOUS`: 匿名映射（不基于文件）
  - `MAP_FIXED`: 固定地址映射
- `fd`: 文件描述符
- `offset`: 文件偏移量

**返回值：**

- 成功：映射区域的起始地址
- 失败：`MAP_FAILED`

---

**`munmap()` - 取消内存映射**

```cpp
int munmap(void *addr, size_t length);
```

**参数说明：**

- `addr`: 映射区域的起始地址
- `length`: 映射的长度

**返回值：**

- 成功：0
- 失败：-1

---

**`msync()` - 同步映射区域到文件**

```cpp
int msync(void *addr, size_t length, int flags);
```

- `MS_ASYNC`: 异步同步
- `MS_SYNC`: 同步同步
- `MS_INVALIDATE`: 使其他映射无效

**`mprotect()` - 修改内存保护属性**

```cpp
int mprotect(void *addr, size_t len, int prot);
```

**`madvise()` - 提供内存使用建议**

```cpp
int madvise(void *addr, size_t length, int advice);
```

## mmap原理

### 虚拟内存管理

1. **页表映射**
   - mmap在进程的虚拟地址空间中分配一段连续的虚拟地址
   - 建立虚拟地址到物理页面的映射关系
   - 通过页表（Page Table）管理这种映射

2. **延迟加载（Lazy Loading）**
   - mmap调用时并不立即加载文件内容到内存
   - 只有当进程访问某个页面时才触发页面错误（Page Fault）
   - 内核此时才从文件中读取对应页面到物理内存

3. **写时复制（Copy-on-Write）**
   - 对于`MAP_PRIVATE`映射，多个进程可以共享同一物理页面
   - 当某个进程尝试写入时，内核创建页面的私有副本
   - 实现了内存的高效利用

### 内核实现机制

1. **VMA（Virtual Memory Area）**
   - 内核为每个映射创建VMA结构
   - 记录映射的起始地址、长度、权限、文件信息等
   - 链接到进程的内存描述符中

2. **页面缓存（Page Cache）**
   - 文件页面在内存中的缓存
   - 多个进程映射同一文件时共享相同的物理页面
   - 提高了内存利用率和访问效率

3. **脏页管理**
   - 跟踪被修改的页面（脏页）
   - 定期或在特定条件下将脏页写回文件
   - 确保数据一致性

## 内存映射与共享内存的区别

**内存映射（mmap）**是一种**通用的内存管理机制**, 可以映射文件、设备或匿名内存, 是底层的系统调用。

**POSIX共享内存**是一种**专门的IPC机制**，是基于mmap实现的高层抽象，专门用于进程间通信。

**普通文件映射**存储在普通文件系统，**共享内存**存储在专用的共享内存文件系统。

可以这样理解：**POSIX共享内存是基于mmap实现的专门IPC机制，而mmap是更通用的内存管理工具**。就像汽车和交通工具的关系——汽车是基于交通工具概念实现的专门载具，但交通工具包含更广泛的概念。

| 特性         | 内存映射（mmap） | POSIX共享内存        |
| ------------ | ---------------- | -------------------- |
| **底层实现** | 直接系统调用     | 基于mmap + shm_open  |
| **命名方式** | 文件路径         | POSIX名称（/name）   |
| **存储位置** | 任意文件系统     | 专用共享内存文件系统 |
| **生命周期** | 跟随文件         | 独立于进程           |
| **权限管理** | 文件系统权限     | POSIX权限            |
| **可移植性** | 平台相关         | POSIX标准            |
| **用途**     | 通用内存管理     | 专门IPC              |

## 示例

**写进程**

```c++
#include <iostream>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <cstring>
#include <signal.h>

struct SharedData {
    int counter;
    char message[256];
    bool finished;
    pid_t writer_pid;
};

const char* SHARED_FILE = "/tmp/mmap_shared_file";
int fd;
SharedData* shared_data;

void cleanup(int sig) {
    std::cout << "\n正在清理资源..." << std::endl;
    
    if (shared_data) {
        shared_data->finished = true;
        // 同步数据到文件
        msync(shared_data, sizeof(SharedData), MS_SYNC);
        munmap(shared_data, sizeof(SharedData));
    }
    
    if (fd != -1) {
        close(fd);
    }
    
    std::cout << "写进程已退出" << std::endl;
    exit(0);
}

int main() {
    signal(SIGINT, cleanup);
    signal(SIGTERM, cleanup);

    // 创建或打开共享文件
    fd = open(SHARED_FILE, O_CREAT | O_RDWR, 0644);
    if (fd == -1) {
        perror("open failed");
        return 1;
    }

    // 设置文件大小
    if (ftruncate(fd, sizeof(SharedData)) == -1) {
        perror("ftruncate failed");
        close(fd);
        return 1;
    }

    // 创建内存映射
    shared_data = (SharedData*)mmap(nullptr, sizeof(SharedData),
                                   PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (shared_data == MAP_FAILED) {
        perror("mmap failed");
        close(fd);
        return 1;
    }

    std::cout << "文件映射写进程启动" << std::endl;
    std::cout << "共享文件: " << SHARED_FILE << std::endl;
    std::cout << "映射地址: " << shared_data << std::endl;
    std::cout << "映射大小: " << sizeof(SharedData) << " 字节" << std::endl;

    // 初始化共享数据
    shared_data->counter = 0;
    shared_data->finished = false;
    shared_data->writer_pid = getpid();
    strcpy(shared_data->message, "初始化消息");

    // 强制同步到文件
    msync(shared_data, sizeof(SharedData), MS_SYNC);

    // 写入数据
    for (int i = 1; i <= 20; ++i) {
        shared_data->counter = i;
        snprintf(shared_data->message, sizeof(shared_data->message),
                "mmap消息 %d，写进程PID: %d", i, getpid());

        std::cout << "写入: counter=" << shared_data->counter 
                  << ", message=" << shared_data->message << std::endl;

        // 异步同步到文件
        msync(shared_data, sizeof(SharedData), MS_ASYNC);
        
        sleep(2);
        
        if (shared_data->finished) {
            break;
        }
    }

    shared_data->finished = true;
    msync(shared_data, sizeof(SharedData), MS_SYNC);
    
    std::cout << "写入完成，按Ctrl+C退出" << std::endl;
    
    // 保持程序运行
    while (true) {
        sleep(1);
    }

    return 0;
}
```

**读进程**

```c++
#include <iostream>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>

struct SharedData {
    int counter;
    char message[256];
    bool finished;
    pid_t writer_pid;
};

const char* SHARED_FILE = "/tmp/mmap_shared_file";
SharedData* shared_data;
bool running = true;

void cleanup(int sig) {
    std::cout << "\n读进程退出" << std::endl;
    if (shared_data) {
        munmap(shared_data, sizeof(SharedData));
    }
    running = false;
}

int main() {
    signal(SIGINT, cleanup);
    signal(SIGTERM, cleanup);

    // 等待共享文件创建
    int fd;
    while ((fd = open(SHARED_FILE, O_RDONLY)) == -1) {
        std::cout << "等待共享文件创建..." << std::endl;
        sleep(1);
    }

    // 获取文件大小
    struct stat file_stat;
    if (fstat(fd, &file_stat) == -1) {
        perror("fstat failed");
        close(fd);
        return 1;
    }

    if (file_stat.st_size < sizeof(SharedData)) {
        std::cout << "文件大小不足，等待写进程初始化..." << std::endl;
        close(fd);
        sleep(2);
        return main();  // 重新尝试
    }

    // 创建只读内存映射
    shared_data = (SharedData*)mmap(nullptr, sizeof(SharedData),
                                   PROT_READ, MAP_SHARED, fd, 0);
    if (shared_data == MAP_FAILED) {
        perror("mmap failed");
        close(fd);
        return 1;
    }

    close(fd);  // 映射后可以关闭文件描述符

    std::cout << "文件映射读进程启动" << std::endl;
    std::cout << "共享文件: " << SHARED_FILE << std::endl;
    std::cout << "映射地址: " << shared_data << std::endl;
    std::cout << "写进程PID: " << shared_data->writer_pid << std::endl;
    std::cout << "等待数据... (Ctrl+C退出)" << std::endl;

    int last_counter = -1;
    
    while (running && !shared_data->finished) {
        if (shared_data->counter != last_counter) {
            std::cout << "读取: counter=" << shared_data->counter 
                      << ", message=" << shared_data->message << std::endl;
            last_counter = shared_data->counter;
        }
        
        usleep(500000);  // 500ms
    }

    if (shared_data->finished) {
        std::cout << "写进程已完成，最终数据:" << std::endl;
        std::cout << "  counter=" << shared_data->counter << std::endl;
        std::cout << "  message=" << shared_data->message << std::endl;
    }

    cleanup(0);
    return 0;
}
```

# 文件锁

文件锁是一种通过对文件加锁来实现进程同步和互斥访问的IPC机制。它可以防止多个进程同时修改同一个文件，确保数据的一致性。

- **特点**: 通过文件锁实现进程同步

**锁的类型**

- **建议锁（Advisory Lock）**：不强制执行，依赖程序自觉遵守
- **强制锁（Mandatory Lock）**：由内核强制执行（Linux默认不支持）

**锁的模式**

- **共享锁（读锁，F_RDLCK）**：多个进程可以同时持有
- **排他锁（写锁，F_WRLCK）**：只有一个进程可以持有
- **解锁（F_UNLCK）**：释放锁

## 常用函数

**1. fcntl() 函数**

```cpp
#include <fcntl.h>
int fcntl(int fd, int cmd, struct flock *lock);
```

**参数说明：**

- `fd`：文件描述符
- `cmd`：操作命令
  - `F_SETLK`：设置锁（非阻塞）
  - `F_SETLKW`：设置锁（阻塞等待）
  - `F_GETLK`：获取锁信息
- `lock`：flock结构体指针

**flock结构体：**

```cpp
struct flock {
    short l_type;    // 锁类型：F_RDLCK, F_WRLCK, F_UNLCK
    short l_whence;  // 偏移量基准：SEEK_SET, SEEK_CUR, SEEK_END
    off_t l_start;   // 相对偏移量
    off_t l_len;     // 锁定长度（0表示到文件末尾）
    pid_t l_pid;     // 持有锁的进程ID（仅F_GETLK时有效）
};
```

**2. flock() 函数**

```cpp
#include <sys/file.h>
int flock(int fd, int operation);
```

**参数说明：**

- `fd`：文件描述符
- `operation`：操作类型
  - `LOCK_SH`：共享锁
  - `LOCK_EX`：排他锁
  - `LOCK_UN`：解锁
  - `LOCK_NB`：非阻塞（与上述选项组合使用）

### 示例

```c++
#include <iostream>
#include <fcntl.h>
#include <unistd.h>
#include <cstring>
#include <sys/wait.h>

class FileLock {
private:
    int fd;
    struct flock lock_info;
    
public:
    FileLock(const char* filename) {
        fd = open(filename, O_RDWR | O_CREAT, 0666);
        if (fd == -1) {
            perror("open");
            exit(1);
        }
    }
    
    ~FileLock() {
        if (fd != -1) {
            close(fd);
        }
    }
    
    bool setLock(short type, bool blocking = true) {
        lock_info.l_type = type;
        lock_info.l_whence = SEEK_SET;
        lock_info.l_start = 0;
        lock_info.l_len = 0;  // 锁定整个文件
        lock_info.l_pid = getpid();
        
        int cmd = blocking ? F_SETLKW : F_SETLK;
        
        if (fcntl(fd, cmd, &lock_info) == -1) {
            if (!blocking && (errno == EACCES || errno == EAGAIN)) {
                std::cout << "文件已被锁定，无法获取锁" << std::endl;
                return false;
            }
            perror("fcntl");
            return false;
        }
        return true;
    }
    
    bool unlock() {
        lock_info.l_type = F_UNLCK;
        if (fcntl(fd, F_SETLK, &lock_info) == -1) {
            perror("unlock");
            return false;
        }
        return true;
    }
    
    void writeData(const std::string& data) {
        lseek(fd, 0, SEEK_END);
        write(fd, data.c_str(), data.length());
        fsync(fd);  // 强制写入磁盘
    }
    
    void checkLock() {
        struct flock check_lock;
        check_lock.l_type = F_WRLCK;
        check_lock.l_whence = SEEK_SET;
        check_lock.l_start = 0;
        check_lock.l_len = 0;
        
        if (fcntl(fd, F_GETLK, &check_lock) == -1) {
            perror("F_GETLK");
            return;
        }
        
        if (check_lock.l_type == F_UNLCK) {
            std::cout << "文件未被锁定" << std::endl;
        } else {
            std::cout << "文件被进程 " << check_lock.l_pid 
                      << " 锁定，锁类型: " 
                      << (check_lock.l_type == F_RDLCK ? "读锁" : "写锁") 
                      << std::endl;
        }
    }
};

int main() {
    const char* filename = "shared_file.txt";
    
    // 创建子进程演示锁竞争
    pid_t pid = fork();
    
    if (pid == 0) {
        // 子进程
        sleep(1);  // 让父进程先获取锁
        
        FileLock file_lock(filename);
        std::cout << "[子进程] 尝试获取写锁..." << std::endl;
        
        file_lock.checkLock();
        
        if (file_lock.setLock(F_WRLCK, false)) {  // 非阻塞
            std::cout << "[子进程] 获取写锁成功" << std::endl;
            file_lock.writeData("子进程写入的数据\n");
            sleep(2);
            file_lock.unlock();
            std::cout << "[子进程] 释放锁" << std::endl;
        } else {
            std::cout << "[子进程] 无法获取锁，等待中..." << std::endl;
            file_lock.setLock(F_WRLCK, true);  // 阻塞等待
            std::cout << "[子进程] 等待后获取写锁成功" << std::endl;
            file_lock.writeData("子进程等待后写入的数据\n");
            file_lock.unlock();
        }
    } else if (pid > 0) {
        // 父进程
        FileLock file_lock(filename);
        std::cout << "[父进程] 获取写锁" << std::endl;
        
        file_lock.setLock(F_WRLCK);
        file_lock.writeData("父进程写入的数据\n");
        
        std::cout << "[父进程] 持有锁3秒..." << std::endl;
        sleep(3);
        
        file_lock.unlock();
        std::cout << "[父进程] 释放锁" << std::endl;
        
        wait(nullptr);  // 等待子进程结束
    } else {
        perror("fork");
        return 1;
    }
    
    return 0;
}
```


# eventfd

`eventfd` 是Linux内核提供的一种轻量级的事件通知机制，用于进程间或线程间的同步和通信。它创建一个特殊的文件描述符，可以用于事件计数和通知。

## 概述

**eventfd** 是一个内核对象，通过文件描述符进行访问，其内部维护一个64位无符号整数计数器，支持读写操作来进行事件通知和同步。可以与epoll、select、poll等IO多路复用机制配合使用

**eventfd系统调用返回的是文件描述符，该文件描述符可以读、写、监听。**

>- 使用eventfd时，内核中会维护一个计数器
>
>
>- 对eventfd执行以下函数
>
>  read函数：如果计数器的值不为0时，读取成功，获得到该值；如果计数器的值为0，非阻塞模式时，会直接返回失败，并把error置为EINVAL；如果为阻塞模式，一直会阻塞到A为非0为止。
>  write函数：将缓冲区写入的8字节整型值<font color=red>**加到**</font>内核计数器上（累加效果），即会增加8字节的整数在计数器上，如果其值达到0xfffffffffffffffe时，就会阻塞（在阻塞模式下），直到计数器的值被read。
>
>通过对eventfd函数返回的文件描述符进行通信。一个进程或者线程A执行read操作，如果内核计数器的值为0，并且是阻塞模式，那么A就会阻塞；另外一个进程或者线程B执行write操作，就会向内核计数器写，那么阻塞的A发现内核计数器的值不为0，就会被触发，那么两个进程或者线程A与B就达到通信的目的了**（通知）**

## 常用函数

**1. eventfd() 函数**

```cpp
#include <sys/eventfd.h>
int eventfd(unsigned int initval, int flags);
```

**参数说明：**
- `initval`：计数器初始值
- `flags`：标志位
  - `EFD_CLOEXEC`：执行exec时关闭文件描述符
  - `EFD_NONBLOCK`：非阻塞模式
  - `EFD_SEMAPHORE`：信号量模式

**返回值：**
- 成功：返回文件描述符
- 失败：返回-1

**2. 读写操作**

```cpp
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);
```

## 工作模式

**1. 计数器模式（默认）**

- 写入：将值累加到计数器
- 读取：返回当前计数器值并重置为0
- 如果计数器为0，读操作会阻塞

**2. 信号量模式（EFD_SEMAPHORE）**

- 写入：将值累加到计数器
- 读取：计数器减1，返回值总是1
- 如果计数器为0，读操作会阻塞

## 示例

```c++
#include <iostream>
#include <sys/eventfd.h>
#include <sys/epoll.h>
#include <unistd.h>
#include <thread>
#include <chrono>
#include <vector>

class EventLoop {
private:
    int epoll_fd;
    bool running;
    
public:
    EventLoop() : running(false) {
        epoll_fd = epoll_create1(EPOLL_CLOEXEC);
        if (epoll_fd == -1) {
            perror("epoll_create1");
            exit(1);
        }
    }
    
    ~EventLoop() {
        if (epoll_fd != -1) {
            close(epoll_fd);
        }
    }
    
    bool addEventFd(int event_fd, void* data = nullptr) {
        struct epoll_event ev;
        ev.events = EPOLLIN | EPOLLET;  // 边缘触发
        ev.data.ptr = data;
        ev.data.fd = event_fd;
        
        if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, event_fd, &ev) == -1) {
            perror("epoll_ctl");
            return false;
        }
        return true;
    }
    
    void run() {
        running = true;
        const int MAX_EVENTS = 10;
        struct epoll_event events[MAX_EVENTS];
        
        std::cout << "[事件循环] 开始运行" << std::endl;
        
        while (running) {
            int nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, 1000);
            
            if (nfds == -1) {
                if (errno == EINTR) continue;
                perror("epoll_wait");
                break;
            }
            
            for (int i = 0; i < nfds; ++i) {
                int fd = events[i].data.fd;
                
                if (events[i].events & EPOLLIN) {
                    uint64_t value;
                    ssize_t result = read(fd, &value, sizeof(value));
                    if (result == sizeof(value)) {
                        std::cout << "[事件循环] 接收到事件，fd=" << fd 
                                  << ", 值=" << value << std::endl;
                        
                        // 特殊值用于停止事件循环
                        if (value == 999) {
                            std::cout << "[事件循环] 接收到停止信号" << std::endl;
                            running = false;
                        }
                    }
                }
            }
        }
        
        std::cout << "[事件循环] 结束运行" << std::endl;
    }
    
    void stop() {
        running = false;
    }
};

class EventProducer {
private:
    int event_fd;
    
public:
    EventProducer() {
        event_fd = eventfd(0, EFD_NONBLOCK);
        if (event_fd == -1) {
            perror("eventfd");
            exit(1);
        }
    }
    
    ~EventProducer() {
        if (event_fd != -1) {
            close(event_fd);
        }
    }
    
    void sendEvent(uint64_t value) {
        ssize_t result = write(event_fd, &value, sizeof(value));
        if (result != sizeof(value)) {
            perror("write eventfd");
        } else {
            std::cout << "[生产者] 发送事件: " << value << std::endl;
        }
    }
    
    int getFd() const { return event_fd; }
};

void producerThread(EventProducer& producer) {
    // 发送一系列事件
    for (int i = 1; i <= 5; ++i) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
        producer.sendEvent(i * 10);
    }
    
    // 发送停止信号
    std::this_thread::sleep_for(std::chrono::seconds(1));
    producer.sendEvent(999);
}

int main() {
    std::cout << "=== EventFD 与 Epoll 集成示例 ===" << std::endl;
    
    EventLoop event_loop;
    EventProducer producer;
    
    // 将eventfd添加到epoll
    event_loop.addEventFd(producer.getFd());
    
    // 启动生产者线程
    std::thread producer_thread(producerThread, std::ref(producer));
    
    // 运行事件循环
    event_loop.run(); 
    
    // 等待生产者线程完成
    producer_thread.join();
    
    std::cout << "=== 示例完成 ===" << std::endl;
    return 0;
}
```

# 定时器timerfd

timerfd 是Linux内核提供的一种基于文件描述符的定时器机制。它将定时器抽象为文件描述符，可以与epoll、select、poll等IO多路复用机制集成，实现高效的异步定时器处理。

> [!note]
>
> timerfd是一种时间同步和事件通知机制 ，而不是传统意义上的数据传输IPC。

## 常用函数

**1. timerfd_create() 函数**

```cpp
#include <sys/timerfd.h>
int timerfd_create(int clockid, int flags);
```

**参数说明：**

- `clockid`：时钟类型
  - `CLOCK_REALTIME`：系统实时时钟
  - `CLOCK_MONOTONIC`：单调递增时钟（推荐）
  - `CLOCK_BOOTTIME`：包含休眠时间的启动时钟
- `flags`：标志位
  - `TFD_CLOEXEC`：执行exec时关闭
  - `TFD_NONBLOCK`：非阻塞模式

**2. timerfd_settime() 函数**

```cpp
int timerfd_settime(int fd, int flags, 
                   const struct itimerspec *new_value,
                   struct itimerspec *old_value);
```

**参数说明：**

- `fd`：timerfd文件描述符
- `flags`：
  - `0`：相对时间
  - `TFD_TIMER_ABSTIME`：绝对时间
- `new_value`：新的定时器设置
- `old_value`：返回之前的设置（可为NULL）

**3. timerfd_gettime() 函数**

```cpp
int timerfd_gettime(int fd, struct itimerspec *curr_value);
```

**4. itimerspec 结构体**

```cpp
struct itimerspec {
    struct timespec it_interval;  // 周期间隔
    struct timespec it_value;     // 初始到期时间
};

struct timespec {
    time_t  tv_sec;   // 秒
    long    tv_nsec;  // 纳秒
};
```

## 示例

```c++
#include <iostream>
#include <sys/timerfd.h>
#include <sys/epoll.h>
#include <unistd.h>
#include <vector>
#include <chrono>
#include <iomanip>

class TimerManager {
private:
    int epoll_fd;
    struct TimerInfo {
        int fd;
        int id;
        std::string name;
        bool periodic;
    };
    std::vector<TimerInfo> timers;
    
public:
    TimerManager() {
        epoll_fd = epoll_create1(EPOLL_CLOEXEC);
        if (epoll_fd == -1) {
            perror("epoll_create1");
            exit(1);
        }
    }
    
    ~TimerManager() {
        for (const auto& timer : timers) {
            close(timer.fd);
        }
        if (epoll_fd != -1) {
            close(epoll_fd);
        }
    }
    
    int addTimer(const std::string& name, int initial_sec, long initial_nsec,
                int interval_sec = 0, long interval_nsec = 0) {
        int timer_fd = timerfd_create(CLOCK_MONOTONIC, TFD_CLOEXEC);
        if (timer_fd == -1) {
            perror("timerfd_create");
            return -1;
        }
        
        struct itimerspec timer_spec;
        timer_spec.it_value.tv_sec = initial_sec;
        timer_spec.it_value.tv_nsec = initial_nsec;
        timer_spec.it_interval.tv_sec = interval_sec;
        timer_spec.it_interval.tv_nsec = interval_nsec;
        
        if (timerfd_settime(timer_fd, 0, &timer_spec, nullptr) == -1) {
            perror("timerfd_settime");
            close(timer_fd);
            return -1;
        }
        
        struct epoll_event ev;
        ev.events = EPOLLIN;
        ev.data.fd = timer_fd;
        
        if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, timer_fd, &ev) == -1) {
            perror("epoll_ctl");
            close(timer_fd);
            return -1;
        }
        
        int timer_id = timers.size();
        timers.push_back({timer_fd, timer_id, name, 
                         (interval_sec > 0 || interval_nsec > 0)});
        
        return timer_id;
    }
    
    void run(int max_events = 10, int timeout_ms = -1) {
        struct epoll_event events[max_events];
        
        std::cout << "[定时器管理器] 开始运行" << std::endl;
        
        while (true) {
            int nfds = epoll_wait(epoll_fd, events, max_events, timeout_ms);
            
            if (nfds == -1) {
                if (errno == EINTR) continue;
                perror("epoll_wait");
                break;
            }
            
            if (nfds == 0) {
                std::cout << "[定时器管理器] 超时" << std::endl;
                continue;
            }
            
            for (int i = 0; i < nfds; ++i) {
                int fd = events[i].data.fd;
                
                if (events[i].events & EPOLLIN) {
                    handleTimerEvent(fd);
                }
            }
        }
    }
    
private:
    void handleTimerEvent(int fd) {
        uint64_t expirations;
        ssize_t result = read(fd, &expirations, sizeof(expirations));
        if (result != sizeof(expirations)) {
            perror("read timerfd");
            return;
        }
        
        // 查找对应的定时器
        for (const auto& timer : timers) {
            if (timer.fd == fd) {
                printCurrentTime();
                std::cout << "定时器 [" << timer.name << "] 触发，过期次数: " 
                          << expirations << std::endl;
                
                // 如果是一次性定时器，可以选择移除
                if (!timer.periodic) {
                    std::cout << "一次性定时器 [" << timer.name << "] 完成" << std::endl;
                }
                break;
            }
        }
    }
    
    void printCurrentTime() {
        auto now = std::chrono::system_clock::now();
        auto time_t = std::chrono::system_clock::to_time_t(now);
        std::cout << "[" << std::put_time(std::localtime(&time_t), "%H:%M:%S") << "] ";
    }
};

int main() {
    std::cout << "=== TimerFD 与 Epoll 集成示例 ===" << std::endl;
    
    TimerManager manager;
    
    // 添加多个定时器
    manager.addTimer("快速定时器", 1, 0, 2, 0);        // 1秒后开始，每2秒触发
    manager.addTimer("慢速定时器", 3, 0, 5, 0);        // 3秒后开始，每5秒触发
    manager.addTimer("一次性定时器1", 4, 0);           // 4秒后触发一次
    manager.addTimer("一次性定时器2", 7, 0);           // 7秒后触发一次
    manager.addTimer("高频定时器", 2, 0, 0, 500000000); // 2秒后开始，每500毫秒触发
    
    // 运行事件循环（15秒后超时）
    manager.run(10, 15000);
    
    std::cout << "\n=== 示例完成 ===" << std::endl;
    return 0;
}
```

