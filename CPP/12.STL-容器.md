# STL

STL（Standard Template Library）是C++中的标准模板库组件，由容器、迭代器、算法、适配器、函数对象和空间配置器组成。

1. 容器用于存储和管理数据对象,也就是数据结构。容器分为序列式容器、有序关联式容器和无序关联式容器。序列式容器中元素的顺序由插入的位置决定，主要有vector, deque和list等。有序关联式容器会对插入的元素进行排序，默认为升序，主要有set，map等。无序关联式容器基于哈希表，提供快速查找的功能，但是元素为乱序，主要有unordered_set和unordered_map。
2. 迭代器是连接容器和算法的桥梁，是为了便于访问容器中的元素而设计出来的一种统一的访问接口，可以将其看成是一种指针，称为泛型指针。
3. 算法提供一些通用的函数，用于操作容器中的元素，比如查找元素、排序元素和进行数值运算。
4. 适配器用于修改其他组件的接口，起到适配的作用，比如容器适配器、迭代器适配器和函数适配器。
5. 函数对象是重载了operator()的类，可以像函数一样调用，用于做定制化的操作。
6. 空间配置器负责内存的分配和释放，为容器提供内存管理。


# vector

`std::vector` 是C++ STL中最常用的序列容器，提供动态数组功能。它是一个模板类，可以存储任意类型的元素。

## 基本特性

- **动态大小**：运行时可以改变大小
- **连续内存**：元素在内存中连续存储
- **随机访问**：支持O(1)时间复杂度的随机访问
- **自动内存管理**：自动处理内存分配和释放

```cpp
#include <vector>
using namespace std;  // 或使用 std::vector
```

## 声明和初始化

```cpp
// 空vector
std::vector<int> vec1;

// 指定大小
std::vector<int> vec2(10);           // 10个元素，默认值为0
std::vector<int> vec3(10, 5);        // 10个元素，每个值为5

// 初始化列表（C++11）
std::vector<int> vec4 = {1, 2, 3, 4, 5};
std::vector<int> vec5{1, 2, 3, 4, 5};

// 拷贝构造
std::vector<int> vec6(vec4);
std::vector<int> vec7 = vec4;

// 移动构造（C++11）
std::vector<int> vec8 = std::move(vec4);

// 从数组初始化
int arr[] = {1, 2, 3, 4, 5};
std::vector<int> vec9(arr, arr + 5);

// 从其他容器初始化
std::vector<int> vec10(vec4.begin(), vec4.end());
```

```cpp
// 二维vector
std::vector<std::vector<int>> matrix;

// 指定大小的二维vector
std::vector<std::vector<int>> matrix2(3, std::vector<int>(4, 0));
// 3行4列，每个元素初始化为0

// 初始化列表
std::vector<std::vector<int>> matrix3 = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
```

## 基本操作

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};

// 下标访问（不检查边界）
int val1 = vec[0];        // 第一个元素
int val2 = vec[4];        // 最后一个元素
vec[0] = 10;              // 修改元素

// at()访问（检查边界，抛出异常）
int val3 = vec.at(0);
try {
    int val4 = vec.at(10);  // 越界，抛出std::out_of_range
} catch(const std::out_of_range& e) {
    std::cout << "Index out of range: " << e.what() << std::endl;
}

// 首尾元素访问
int first = vec.front();  // 第一个元素
int last = vec.back();    // 最后一个元素

// 获取底层数组指针
int* ptr = vec.data();    // C++11
```

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};

// 大小相关
size_t size = vec.size();           // 当前元素个数
size_t capacity = vec.capacity();   // 当前容量
size_t max_size = vec.max_size();   // 理论最大容量
bool empty = vec.empty();           // 是否为空

// 容量管理
vec.reserve(100);                   // 预留容量，避免频繁重新分配
vec.shrink_to_fit();               // 释放多余容量（C++11）

std::cout << "Size: " << vec.size() << std::endl;
std::cout << "Capacity: " << vec.capacity() << std::endl;
```

```cpp
std::vector<int> vec;

// 尾部添加
vec.push_back(1);                   // 添加单个元素
vec.emplace_back(2);               // 就地构造（C++11）

// 插入元素
vec.insert(vec.begin(), 0);         // 在开头插入0
vec.insert(vec.begin() + 1, 5, 10); // 在位置1插入5个10
vec.insert(vec.end(), {7, 8, 9});   // 在末尾插入初始化列表

// 从其他容器插入
std::vector<int> other = {20, 21, 22};
vec.insert(vec.end(), other.begin(), other.end());

// emplace插入（C++11）
vec.emplace(vec.begin() + 2, 15);   // 在位置2就地构造元素15
```

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5, 3, 6};

// 删除尾部元素
vec.pop_back();

// 删除指定位置元素
vec.erase(vec.begin());             // 删除第一个元素
vec.erase(vec.begin() + 1, vec.begin() + 3); // 删除范围[1,3)

// 删除所有等于某值的元素
vec.erase(std::remove(vec.begin(), vec.end(), 3), vec.end());

// 清空所有元素
vec.clear();
```

```cpp
std::vector<int> vec = {1, 2, 3};

// 调整大小
vec.resize(5);          // 扩大到5个元素，新元素默认初始化
vec.resize(7, 10);      // 扩大到7个元素，新元素初始化为10
vec.resize(3);          // 缩小到3个元素

// 赋值操作
vec.assign(5, 100);     // 赋值为5个100
vec.assign({1, 2, 3, 4}); // 赋值为初始化列表

std::vector<int> other = {10, 20, 30};
vec.assign(other.begin(), other.end()); // 从其他容器赋值
```

## 迭代器

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};

// 正向迭代器
std::vector<int>::iterator it = vec.begin();
std::vector<int>::const_iterator cit = vec.cbegin();

// 反向迭代器
std::vector<int>::reverse_iterator rit = vec.rbegin();
std::vector<int>::const_reverse_iterator crit = vec.crbegin();

// auto关键字（C++11）
auto it2 = vec.begin();
auto cit2 = vec.cbegin();
```

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};

// 传统for循环
for(auto it = vec.begin(); it != vec.end(); ++it) {
    std::cout << *it << " ";
    *it *= 2;  // 修改元素
}

// 范围for循环（C++11）
for(const auto& element : vec) {
    std::cout << element << " ";
}

// 修改版本
for(auto& element : vec) {
    element *= 2;
}

// 反向遍历
for(auto rit = vec.rbegin(); rit != vec.rend(); ++rit) {
    std::cout << *rit << " ";
}
```

## 算法

```cpp
#include <algorithm>
#include <numeric>

std::vector<int> vec = {5, 2, 8, 1, 9, 3};

// 排序
std::sort(vec.begin(), vec.end());                    // 升序
std::sort(vec.begin(), vec.end(), std::greater<int>()); // 降序

// 查找
auto it = std::find(vec.begin(), vec.end(), 5);
if(it != vec.end()) {
    std::cout << "Found at position: " << it - vec.begin() << std::endl;
}

// 计数
int count = std::count(vec.begin(), vec.end(), 5);

// 累加
int sum = std::accumulate(vec.begin(), vec.end(), 0);

// 变换
std::transform(vec.begin(), vec.end(), vec.begin(), 
               [](int x) { return x * 2; });

// 过滤（移除）
vec.erase(std::remove_if(vec.begin(), vec.end(), 
                        [](int x) { return x % 2 == 0; }), 
          vec.end());

// 二分查找（需要先排序）
std::sort(vec.begin(), vec.end());
bool found = std::binary_search(vec.begin(), vec.end(), 5);
```

## 内部实现原理

### 内存布局
```cpp
// vector的典型实现包含三个指针
template<typename T>
class vector {
private:
    T* start;        // 指向第一个元素
    T* finish;       // 指向最后一个元素的下一位置
    T* end_of_storage; // 指向分配内存的末尾
    
public:
    size_t size() const { return finish - start; }
    size_t capacity() const { return end_of_storage - start; }
    bool empty() const { return start == finish; }
};
```

![vector](../img/cpp_img/vector.png)

### 动态扩容机制

```cpp
// 扩容示例
void demonstrate_capacity() {
    std::vector<int> vec;
    
    for(int i = 0; i < 20; ++i) {
        vec.push_back(i);
        std::cout << "Size: " << vec.size() 
                  << ", Capacity: " << vec.capacity() << std::endl;
    }
    
    // 输出可能类似：
    // Size: 1, Capacity: 1
    // Size: 2, Capacity: 2
    // Size: 3, Capacity: 4
    // Size: 4, Capacity: 4
    // Size: 5, Capacity: 8
    // ...
}
```

**扩容策略**

- **增长因子**：通常为1.5或2
- **重新分配**：当容量不足时，分配新的更大内存块
- **元素移动**：将旧元素移动到新内存位置
- **释放旧内存**：释放原来的内存块

| 操作              | 时间复杂度 | 说明               |
| ----------------- | ---------- | ------------------ |
| 随机访问          | O(1)       | 通过下标或迭代器   |
| 尾部插入/删除     | O(1) 摊销  | push_back/pop_back |
| 任意位置插入/删除 | O(n)       | 需要移动元素       |
| 查找              | O(n)       | 线性查找           |
| 排序              | O(n log n) | 使用std::sort      |

## 应用

```cpp
// 读取不定数量的输入
std::vector<int> read_numbers() {
    std::vector<int> numbers;
    int num;
    
    while(std::cin >> num) {
        numbers.push_back(num);
    }
    
    return numbers;
}

// 矩阵运算
class Matrix {
private:
    std::vector<std::vector<double>> data;
    size_t rows, cols;
    
public:
    Matrix(size_t r, size_t c) : rows(r), cols(c) {
        data.resize(rows, std::vector<double>(cols, 0.0));
    }
    
    double& operator()(size_t i, size_t j) {
        return data[i][j];
    }
    
    const double& operator()(size_t i, size_t j) const {
        return data[i][j];
    }
};

// 缓存系统
template<typename T>
class Cache {
private:
    std::vector<T> buffer;
    size_t capacity;
    size_t current_size;
    
public:
    Cache(size_t cap) : capacity(cap), current_size(0) {
        buffer.reserve(capacity);
    }
    
    void add(const T& item) {
        if(current_size < capacity) {
            buffer.push_back(item);
            ++current_size;
        } else {
            // 实现LRU或其他替换策略
        }
    }
};
```

## 总结

选择vector的场景：
- 需要随机访问元素
- 主要在尾部进行插入/删除操作
- 需要连续内存布局
- 元素数量动态变化

避免使用vector的场景：
- 频繁在中间或开头插入/删除
- 需要稳定的迭代器和引用
- 对内存使用有严格限制


# deque

`std::deque`（double-ended queue，双端队列）是C++ STL中的一个序列容器，支持在两端进行高效的插入和删除操作。

## 基本特性

- **双端操作**：在头部和尾部都能进行O(1)的插入和删除
- **随机访问**：支持O(1)时间复杂度的随机访问
- **动态大小**：运行时可以改变大小
- **分段连续**：内部使用分段的连续内存块
- **稳定的迭代器**：中间插入/删除不会使两端的迭代器失效

```cpp
#include <deque>
using namespace std;  // 或使用 std::deque
```

## 声明和初始化

```cpp
// 空deque
std::deque<int> dq1;

// 指定大小
std::deque<int> dq2(10);           // 10个元素，默认值为0
std::deque<int> dq3(10, 5);        // 10个元素，每个值为5

// 初始化列表（C++11）
std::deque<int> dq4 = {1, 2, 3, 4, 5};
std::deque<int> dq5{1, 2, 3, 4, 5};

// 拷贝构造
std::deque<int> dq6(dq4);
std::deque<int> dq7 = dq4;

// 移动构造（C++11）
std::deque<int> dq8 = std::move(dq4);

// 从数组初始化
int arr[] = {1, 2, 3, 4, 5};
std::deque<int> dq9(arr, arr + 5);

// 从其他容器初始化
std::vector<int> vec = {1, 2, 3, 4, 5};
std::deque<int> dq10(vec.begin(), vec.end());
```

## 基本操作

```cpp
std::deque<int> dq = {1, 2, 3, 4, 5};

// 下标访问（不检查边界）
int val1 = dq[0];        // 第一个元素
int val2 = dq[4];        // 最后一个元素
dq[0] = 10;              // 修改元素

// at()访问（检查边界，抛出异常）
int val3 = dq.at(0);
try {
    int val4 = dq.at(10);  // 越界，抛出std::out_of_range
} catch(const std::out_of_range& e) {
    std::cout << "Index out of range: " << e.what() << std::endl;
}

// 首尾元素访问
int first = dq.front();  // 第一个元素
int last = dq.back();    // 最后一个元素
```

```cpp
std::deque<int> dq = {1, 2, 3, 4, 5};

// 大小相关
size_t size = dq.size();           // 当前元素个数
size_t max_size = dq.max_size();   // 理论最大容量
bool empty = dq.empty();           // 是否为空

std::cout << "Size: " << dq.size() << std::endl;
std::cout << "Empty: " << (dq.empty() ? "Yes" : "No") << std::endl;
```

**双端插入和删除**

```cpp
std::deque<int> dq;

// 尾部操作
dq.push_back(1);                   // 尾部添加
dq.push_back(2);
dq.emplace_back(3);               // 就地构造（C++11）
std::cout << dq.back() << std::endl; // 访问尾部元素
dq.pop_back();                     // 删除尾部元素

// 头部操作
dq.push_front(0);                  // 头部添加
dq.push_front(-1);
dq.emplace_front(-2);             // 就地构造（C++11）
std::cout << dq.front() << std::endl; // 访问头部元素
dq.pop_front();                    // 删除头部元素

// 结果：dq = {-1, 0, 1, 2}
```

**任意位置插入和删除**

```cpp
std::deque<int> dq = {1, 2, 3, 4, 5};

// 插入元素
dq.insert(dq.begin(), 0);          // 在开头插入0
dq.insert(dq.begin() + 2, 5, 10);  // 在位置2插入5个10
dq.insert(dq.end(), {7, 8, 9});     // 在末尾插入初始化列表

// 从其他容器插入
std::vector<int> other = {20, 21, 22};
dq.insert(dq.end(), other.begin(), other.end());

// emplace插入（C++11）
dq.emplace(dq.begin() + 2, 15);     // 在位置2就地构造元素15

// 删除元素
dq.erase(dq.begin());               // 删除第一个元素
dq.erase(dq.begin() + 1, dq.begin() + 3); // 删除范围[1,3)

// 清空所有元素
dq.clear();
```

**调整大小和赋值**

```cpp
std::deque<int> dq = {1, 2, 3};

// 调整大小
dq.resize(5);          // 扩大到5个元素，新元素默认初始化
dq.resize(7, 10);      // 扩大到7个元素，新元素初始化为10
dq.resize(3);          // 缩小到3个元素

// 赋值操作
dq.assign(5, 100);     // 赋值为5个100
dq.assign({1, 2, 3, 4}); // 赋值为初始化列表

std::vector<int> vec = {10, 20, 30};
dq.assign(vec.begin(), vec.end()); // 从其他容器赋值
```

## 迭代器

```cpp
std::deque<int> dq = {1, 2, 3, 4, 5};

// 正向迭代器
std::deque<int>::iterator it = dq.begin();
std::deque<int>::const_iterator cit = dq.cbegin();

// 反向迭代器
std::deque<int>::reverse_iterator rit = dq.rbegin();
std::deque<int>::const_reverse_iterator crit = dq.crbegin();

// auto关键字（C++11）
auto it2 = dq.begin();
auto cit2 = dq.cbegin();
```

```cpp
std::deque<int> dq = {1, 2, 3, 4, 5};

// 传统for循环
for(auto it = dq.begin(); it != dq.end(); ++it) {
    std::cout << *it << " ";
    *it *= 2;  // 修改元素
}

// 范围for循环（C++11）
for(const auto& element : dq) {
    std::cout << element << " ";
}

// 修改版本
for(auto& element : dq) {
    element *= 2;
}

// 反向遍历
for(auto rit = dq.rbegin(); rit != dq.rend(); ++rit) {
    std::cout << *rit << " ";
}
```

## 内部实现原理

```cpp
// deque的典型实现结构
template<typename T>
class deque {
private:
    T** map;              // 指向块指针数组的指针
    size_t map_size;      // map数组的大小
    
    iterator start;       // 指向第一个元素
    iterator finish;      // 指向最后一个元素的下一位置
    
    static const size_t buffer_size = 512 / sizeof(T);
    
public:
    // 迭代器实现
    class iterator {
        T* cur;           // 当前元素指针
        T* first;         // 当前块的开始
        T* last;          // 当前块的结束
        T** node;         // 指向当前块的map节点
    };
};
```

---

deque是由多个片段组成的，片段内部是连续的，但是片段之间不连续的，分散的，多个片段被一个称为中控器的结构控制（也称为map，但跟std::map不是一回事）。

所以说deque是<font color=red>**在物理上是不连续的，但是逻辑上是连续的**</font>。

初始化deque时，根据元素的个数分配一些缓冲区片段

在缓冲区片段中存放实际的元素，这里以int型元素为例。通常情况下，在初始化时第一个元素会被放置在第一个缓冲区中相对靠前的位置（而非第一个缓冲区的首地址，这样方便在头部添加元素）。

前后相邻的两个元素在逻辑上是连续的，但是物理层面上可能并不是连续的。

同时还会生成一个数组中控器（map），存放每个缓冲区片段的首地址。（注意map中的元素是int*，而不是严格意义的数组指针，这一点从源码中可以进行理解）

通常情况下，第一个缓冲区片段的首地址被放在中控器map的居中位置。

---

deque初始化完成后，进行添加元素的操作：

**如果在尾部添加元素value**

找到最后一个存放着元素的缓冲区片段，在其中最后一个元素的后面添加元素value。

如果此时最后的缓冲区片段是满的，那么就再申请一个新的缓冲区片段，将要添加的元素value存放在新片段的首个位置。同时中控器也加上一个元素（新片段的首地址），让中控器与新片段联系起来。

如果此时中控器已经满了，还要添加内容，那么开辟新的更大的空间作为中控器，将原本中控器中记录的地址值复制到新的中控器，并将最后一个缓冲区片段的首地址加入。

---

**如果是在deque的头部添加元素value**

找到已经存储的第一个元素的位置，在它的前面存放新元素value。

经过若干次头部添加元素之后，如果第一个缓冲区片段满了，还要继续在头部添加元素，则新开辟一个缓冲区片段（作为第一个片段），将value存在这个片段中的最后一个位置。同时在中控器的相应位置存放新的缓冲片段的首地址。

如果一直往deque头部添加元素，中控器的前半部分已经满了，后半部分还没满，就将中控器中记录的地址全都后移，将这个第一个缓冲区的首地址存入中控器的第一个位置。如果中控器全都满了，那就再开辟新的更大的空间作为中控器。

![deque](../img/cpp_img/deque.png)

> [!tip]
>
> 每个缓冲区片段的大小是多大？
>
> 如果deque存放的元素类型的大小小于 512 字节。每个缓冲区片段的大小为 512 字节，512 除以元素类型的大小，就可以得到每个缓冲区片段能够存放的元素数量。
> 例如元素类型是 int，在 64 位系统中，sizeof(int)= 4 字节。**那么 deque_buf_size(4) 的结果就是 512 / 4 = 128，即每个缓冲区片段可以存放 128 个 int 类型的元素。**
> 这种设计的好处是，对于较小的元素类型，每个缓冲区可以存放较多的元素，减少了缓冲区的数量，从而降低了中控器（用于管理缓冲区的数组）的管理开销。
>
> 如果元素类型大小大于等于 512 字节，函数返回 1。这表示每个缓冲区片段只存放一个元素。
> 比如自定义类型A的对象作为deque的元素，单个元素的大小超过了 512 字节，那么 __deque_buf_size(sizeof(A)) 的结果就是 1，每个缓冲区片段只会存放一个 A类型的元素。

> [!note]
>
> deque的迭代器底层是和vector一样吗？
>
> deque的迭代器比vector的迭代器复杂得多，`vector<T>`的迭代器实际是对T*的包装，但deque的迭代器实际应该视为对象，数据成员包含四个指针，并且进行了一系列的运算符重载，使得迭代器能够像指针一样被使用。
>
> ![deque_start](../img/cpp_img/deque_start.png)
>
> ![deque_finish](../img/cpp_img/deque_finish.png)

| 操作              | 时间复杂度 | 说明                 |
| ----------------- | ---------- | -------------------- |
| 随机访问          | O(1)       | 通过下标或迭代器     |
| 头部插入/删除     | O(1)       | push_front/pop_front |
| 尾部插入/删除     | O(1)       | push_back/pop_back   |
| 任意位置插入/删除 | O(n)       | 需要移动元素         |
| 查找              | O(n)       | 线性查找             |

| 需求             | 推荐容器     | 原因                     |
| ---------------- | ------------ | ------------------------ |
| 频繁尾部操作     | vector       | 最佳性能，连续内存       |
| 频繁双端操作     | deque        | 双端O(1)操作             |
| 频繁中间插入删除 | list         | 任意位置O(1)操作         |
| 需要随机访问     | vector/deque | 支持O(1)随机访问         |
| 内存使用敏感     | vector       | 最少的内存开销           |
| 迭代器稳定性     | list         | 插入删除不影响其他迭代器 |

## 算法

```cpp
#include <algorithm>
#include <numeric>

std::deque<int> dq = {5, 2, 8, 1, 9, 3};

// 排序
std::sort(dq.begin(), dq.end());                    // 升序
std::sort(dq.begin(), dq.end(), std::greater<int>()); // 降序

// 查找
auto it = std::find(dq.begin(), dq.end(), 5);
if(it != dq.end()) {
    std::cout << "Found at position: " << it - dq.begin() << std::endl;
}

// 计数
int count = std::count(dq.begin(), dq.end(), 5);

// 累加
int sum = std::accumulate(dq.begin(), dq.end(), 0);

// 变换
std::transform(dq.begin(), dq.end(), dq.begin(), 
               [](int x) { return x * 2; });

// 过滤（移除）
dq.erase(std::remove_if(dq.begin(), dq.end(), 
                        [](int x) { return x % 2 == 0; }), 
         dq.end());

// 旋转
std::rotate(dq.begin(), dq.begin() + 2, dq.end());
```

## 应用

### 滑动窗口
```cpp
// 滑动窗口最大值
std::vector<int> maxSlidingWindow(std::vector<int>& nums, int k) {
    std::deque<int> dq;  // 存储数组下标
    std::vector<int> result;
    
    for(int i = 0; i < nums.size(); ++i) {
        // 移除超出窗口的元素
        while(!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }
        
        // 移除比当前元素小的元素
        while(!dq.empty() && nums[dq.back()] <= nums[i]) {
            dq.pop_back();
        }
        
        dq.push_back(i);
        
        // 窗口形成后记录最大值
        if(i >= k - 1) {
            result.push_back(nums[dq.front()]);
        }
    }
    
    return result;
}
```

### 双端队列应用
```cpp
// 回文检查
bool isPalindrome(const std::string& str) {
    std::deque<char> dq;
    
    // 只添加字母和数字
    for(char c : str) {
        if(std::isalnum(c)) {
            dq.push_back(std::tolower(c));
        }
    }
    
    // 从两端比较
    while(dq.size() > 1) {
        if(dq.front() != dq.back()) {
            return false;
        }
        dq.pop_front();
        dq.pop_back();
    }
    
    return true;
}

// 工作窃取队列
template<typename T>
class WorkStealingQueue {
private:
    std::deque<T> queue;
    mutable std::mutex mtx;
    
public:
    void push(T item) {
        std::lock_guard<std::mutex> lock(mtx);
        queue.push_back(std::move(item));
    }
    
    bool pop(T& item) {
        std::lock_guard<std::mutex> lock(mtx);
        if(queue.empty()) return false;
        
        item = std::move(queue.back());
        queue.pop_back();
        return true;
    }
    
    bool steal(T& item) {
        std::lock_guard<std::mutex> lock(mtx);
        if(queue.empty()) return false;
        
        item = std::move(queue.front());
        queue.pop_front();
        return true;
    }
};
```

### 缓存系统
```cpp
// LRU缓存（使用deque实现）
template<typename Key, typename Value>
class LRUCache {
private:
    struct CacheItem {
        Key key;
        Value value;
        CacheItem(const Key& k, const Value& v) : key(k), value(v) {}
    };
    
    std::deque<CacheItem> cache;
    std::unordered_map<Key, typename std::deque<CacheItem>::iterator> index;
    size_t capacity;
    
public:
    LRUCache(size_t cap) : capacity(cap) {}
    
    Value get(const Key& key) {
        auto it = index.find(key);
        if(it == index.end()) {
            throw std::runtime_error("Key not found");
        }
        
        // 移动到前面（最近使用）
        CacheItem item = *it->second;
        cache.erase(it->second);
        cache.push_front(item);
        index[key] = cache.begin();
        
        return item.value;
    }
    
    void put(const Key& key, const Value& value) {
        auto it = index.find(key);
        
        if(it != index.end()) {
            // 更新现有项
            cache.erase(it->second);
        } else if(cache.size() >= capacity) {
            // 移除最久未使用的项
            index.erase(cache.back().key);
            cache.pop_back();
        }
        
        cache.emplace_front(key, value);
        index[key] = cache.begin();
    }
};
```

## 总结

`std::deque` 是一个功能强大的容器，具有以下优势：

- **双端高效操作**：头部和尾部插入删除都是O(1)
- **随机访问支持**：支持O(1)的随机访问
- **内存效率**：相比vector，不需要预留大量连续内存
- **迭代器稳定性**：中间操作对两端迭代器影响较小

**适用场景**

- 需要频繁在两端进行插入删除操作
- 需要随机访问但不想预分配大量内存
- 实现队列、双端队列等数据结构
- 滑动窗口算法
- 工作窃取队列

**注意事项**

- 中间插入删除性能不如list
- 随机访问性能略逊于vector
- 内存布局不如vector紧凑
- 迭代器在某些操作后可能失效

选择deque的关键是：**当需要双端操作的高效性，同时又需要随机访问能力时**，deque是最佳选择。


# list

`std::list` 是 C++ STL 中的双向链表容器，提供了高效的插入和删除操作。

## 基本特性

- **双向遍历**：支持前向和后向迭代
- **非连续存储**：元素在内存中不连续存储
- **动态大小**：可以在运行时动态增长和收缩
- **稳定的迭代器**：插入和删除操作不会使其他位置的迭代器失效

- **O(1) 插入删除**：在任意位置插入/删除元素的时间复杂度为常数
- **无随机访问**：不支持下标访问，只能通过迭代器顺序访问
- **内存效率**：只在需要时分配内存，无预分配开销

## 声明和初始化

```cpp
#include <list>
#include <iostream>

// 基本声明
std::list<int> lst1;                    // 空链表
std::list<int> lst2(5);                 // 5个默认值元素
std::list<int> lst3(5, 10);             // 5个值为10的元素
std::list<int> lst4{1, 2, 3, 4, 5};     // 初始化列表
std::list<int> lst5(lst4);              // 拷贝构造
std::list<int> lst6(lst4.begin(), lst4.end()); // 迭代器范围构造

// 自定义类型
std::list<std::string> strList{"hello", "world", "list"};
```

## 基本操作

```cpp
std::list<int> lst{1, 2, 3, 4, 5};

// 访问首尾元素
int front = lst.front();    // 获取第一个元素：1
int back = lst.back();      // 获取最后一个元素：5

// 注意：list不支持随机访问，没有operator[]
// lst[2];  // 编译错误！
```

```cpp
std::list<int> lst{1, 2, 3};

bool isEmpty = lst.empty();     // 检查是否为空
size_t size = lst.size();       // 获取元素个数：3
// list没有capacity概念，因为是链表结构
```

```cpp
std::list<int> lst;

// 前端添加
lst.push_front(1);              // [1]
lst.push_front(0);              // [0, 1]

// 后端添加
lst.push_back(2);               // [0, 1, 2]
lst.push_back(3);               // [0, 1, 2, 3]

// 就地构造
lst.emplace_front(-1);          // [-1, 0, 1, 2, 3]
lst.emplace_back(4);            // [-1, 0, 1, 2, 3, 4]

// 任意位置插入
auto it = lst.begin();
std::advance(it, 2);            // 移动到第3个位置
lst.insert(it, 99);             // [-1, 0, 99, 1, 2, 3, 4]
lst.insert(it, 3, 88);          // 插入3个88
lst.insert(it, {77, 66});       // 插入初始化列表
```

```cpp
std::list<int> lst{1, 2, 3, 2, 4, 2, 5};

// 删除首尾元素
lst.pop_front();                // 删除第一个元素
lst.pop_back();                 // 删除最后一个元素

// 删除指定位置
auto it = lst.begin();
std::advance(it, 1);
lst.erase(it);                  // 删除第2个元素

// 删除范围
auto start = lst.begin();
auto end = lst.begin();
std::advance(end, 2);
lst.erase(start, end);          // 删除前两个元素

// 删除特定值
lst.remove(2);                  // 删除所有值为2的元素

// 条件删除
lst.remove_if([](int x) { return x > 3; }); // 删除所有大于3的元素

// 清空
lst.clear();                    // 删除所有元素
```

```cpp
std::list<int> lst;

// 调整大小
lst.resize(5);                  // 调整为5个元素，新元素为默认值
lst.resize(8, 99);              // 调整为8个元素，新元素为99
lst.resize(3);                  // 缩小到3个元素

// 赋值操作
lst.assign(5, 10);              // 赋值为5个10
lst.assign({1, 2, 3, 4});       // 赋值为初始化列表

std::list<int> other{7, 8, 9};
lst.assign(other.begin(), other.end()); // 赋值为其他容器的范围
```

## 迭代器

```cpp
std::list<int> lst{1, 2, 3, 4, 5};

// 双向迭代器
std::list<int>::iterator it = lst.begin();
std::list<int>::const_iterator cit = lst.cbegin();
std::list<int>::reverse_iterator rit = lst.rbegin();
std::list<int>::const_reverse_iterator crit = lst.crbegin();

// C++11 auto简化
auto it2 = lst.begin();
auto cit2 = lst.cbegin();
```

```cpp
std::list<int> lst{1, 2, 3, 4, 5};

// 前向遍历
for (auto it = lst.begin(); it != lst.end(); ++it) {
    std::cout << *it << " ";
}

// 反向遍历
for (auto rit = lst.rbegin(); rit != lst.rend(); ++rit) {
    std::cout << *rit << " ";
}

// 范围for循环（推荐）
for (const auto& elem : lst) {
    std::cout << elem << " ";
}

// 迭代器移动
auto it = lst.begin();
++it;                           // 前进一步
--it;                           // 后退一步
std::advance(it, 3);            // 前进3步
std::advance(it, -2);           // 后退2步
```

## list特有操作

**1. 拼接操作**

```cpp
std::list<int> lst1{1, 2, 3};
std::list<int> lst2{4, 5, 6};
std::list<int> lst3{7, 8, 9};

// 拼接整个链表
lst1.splice(lst1.end(), lst2);  // lst1: [1,2,3,4,5,6], lst2: []

// 拼接单个元素
auto it = lst3.begin();
lst1.splice(lst1.begin(), lst3, it); // 移动lst3的第一个元素到lst1开头

// 拼接范围
auto start = lst3.begin();
auto end = lst3.end();
lst1.splice(lst1.end(), lst3, start, end); // 移动lst3剩余元素到lst1末尾
```

**2. 排序和去重**

```cpp
std::list<int> lst{3, 1, 4, 1, 5, 9, 2, 6};

// 排序
lst.sort();                     // 升序排序：[1,1,2,3,4,5,6,9]
lst.sort(std::greater<int>());  // 降序排序

// 自定义比较器
lst.sort([](int a, int b) { return a > b; });

// 去重（需要先排序）
lst.sort();
lst.unique();                   // 删除连续的重复元素

// 条件去重
lst.unique([](int a, int b) { return std::abs(a - b) < 2; });
```

**3. 合并操作**

```cpp
std::list<int> lst1{1, 3, 5, 7};
std::list<int> lst2{2, 4, 6, 8};

// 合并已排序的链表
lst1.merge(lst2);               // lst1: [1,2,3,4,5,6,7,8], lst2: []

// 自定义合并条件
std::list<int> lst3{8, 6, 4, 2};
std::list<int> lst4{7, 5, 3, 1};
lst3.merge(lst4, std::greater<int>()); // 降序合并
```

**4. 反转**

```cpp
std::list<int> lst{1, 2, 3, 4, 5};
lst.reverse();                  // [5, 4, 3, 2, 1]
```

## 算法

```cpp
#include <algorithm>
#include <numeric>

std::list<int> lst{1, 2, 3, 4, 5};

// 查找
auto it = std::find(lst.begin(), lst.end(), 3);
if (it != lst.end()) {
    std::cout << "Found: " << *it << std::endl;
}

// 计数
int count = std::count(lst.begin(), lst.end(), 2);

// 累加
int sum = std::accumulate(lst.begin(), lst.end(), 0);

// 变换
std::list<int> result;
std::transform(lst.begin(), lst.end(), std::back_inserter(result),
               [](int x) { return x * 2; });

// 条件查找
auto it2 = std::find_if(lst.begin(), lst.end(),
                        [](int x) { return x > 3; });
```

## 内部实现原理

```cpp
// 简化的list节点结构
template<typename T>
struct ListNode {
    T data;
    ListNode* prev;
    ListNode* next;
    
    ListNode(const T& value) : data(value), prev(nullptr), next(nullptr) {}
};
```

- **非连续存储**：每个节点独立分配内存
- **双向链接**：每个节点包含指向前后节点的指针
- **哨兵节点**：通常使用哨兵节点简化边界处理
- **内存开销**：每个元素额外需要两个指针的空间

```cpp
// 简化的list迭代器
template<typename T>
class ListIterator {
    ListNode<T>* node;
public:
    ListIterator& operator++() {
        node = node->next;
        return *this;
    }
    
    ListIterator& operator--() {
        node = node->prev;
        return *this;
    }
    
    T& operator*() { return node->data; }
    // ... 其他操作
};
```

| 操作                  | 时间复杂度 | 说明           |
| --------------------- | ---------- | -------------- |
| 插入/删除（任意位置） | O(1)       | 已知迭代器位置 |
| 查找                  | O(n)       | 需要线性搜索   |
| 访问首尾元素          | O(1)       | 直接访问       |
| 排序                  | O(n log n) | 归并排序       |
| 拼接                  | O(1)       | 指针操作       |
| 大小获取              | O(1)       | 维护计数器     |

## 应用

### LRU缓存实现
```cpp
#include <list>
#include <unordered_map>

template<typename K, typename V>
class LRUCache {
private:
    int capacity;
    std::list<std::pair<K, V>> cache;
    std::unordered_map<K, typename std::list<std::pair<K, V>>::iterator> map;
    
public:
    LRUCache(int cap) : capacity(cap) {}
    
    V get(const K& key) {
        auto it = map.find(key);
        if (it == map.end()) {
            return V{}; // 未找到
        }
        
        // 移动到前端
        cache.splice(cache.begin(), cache, it->second);
        return it->second->second;
    }
    
    void put(const K& key, const V& value) {
        auto it = map.find(key);
        if (it != map.end()) {
            // 更新现有键
            it->second->second = value;
            cache.splice(cache.begin(), cache, it->second);
        } else {
            // 添加新键
            if (cache.size() >= capacity) {
                // 删除最久未使用的
                map.erase(cache.back().first);
                cache.pop_back();
            }
            cache.emplace_front(key, value);
            map[key] = cache.begin();
        }
    }
};
```

### 音乐播放列表
```cpp
class Playlist {
private:
    std::list<std::string> songs;
    std::list<std::string>::iterator current;
    
public:
    void addSong(const std::string& song) {
        songs.push_back(song);
        if (songs.size() == 1) {
            current = songs.begin();
        }
    }
    
    void removeSong(const std::string& song) {
        auto it = std::find(songs.begin(), songs.end(), song);
        if (it != songs.end()) {
            if (it == current) {
                ++current;
                if (current == songs.end()) {
                    current = songs.begin();
                }
            }
            songs.erase(it);
        }
    }
    
    std::string nextSong() {
        if (!songs.empty()) {
            ++current;
            if (current == songs.end()) {
                current = songs.begin();
            }
            return *current;
        }
        return "";
    }
    
    std::string prevSong() {
        if (!songs.empty()) {
            if (current == songs.begin()) {
                current = songs.end();
            }
            --current;
            return *current;
        }
        return "";
    }
};
```

### 撤销/重做功能
```cpp
template<typename Command>
class UndoRedoManager {
private:
    std::list<Command> history;
    typename std::list<Command>::iterator current;
    
public:
    UndoRedoManager() {
        current = history.end();
    }
    
    void execute(const Command& cmd) {
        // 删除当前位置之后的所有命令
        history.erase(current, history.end());
        
        // 添加新命令
        history.push_back(cmd);
        current = history.end();
        
        // 执行命令
        cmd.execute();
    }
    
    bool undo() {
        if (current != history.begin()) {
            --current;
            current->undo();
            return true;
        }
        return false;
    }
    
    bool redo() {
        if (current != history.end()) {
            current->execute();
            ++current;
            return true;
        }
        return false;
    }
};
```

## 总结

**优势**

1. **高效插入删除**：任意位置O(1)时间复杂度
2. **稳定迭代器**：插入删除不影响其他迭代器
3. **灵活拼接**：高效的链表合并操作
4. **内存效率**：按需分配，无预分配浪费

**劣势**

1. **无随机访问**：不能通过下标直接访问元素
2. **内存开销大**：每个元素需要额外的指针空间
3. **缓存不友好**：非连续内存布局影响性能
4. **遍历较慢**：相比连续容器，遍历性能较差

**适用场景**

- 频繁的中间插入/删除操作
- 需要稳定的迭代器
- 实现LRU缓存、撤销重做等功能
- 不需要随机访问的序列操作
- 需要高效拼接的场景

`std::list` 是实现双向链表的标准容器，在需要频繁插入删除且不需要随机访问的场景下是最佳选择。


# set

`std::set` 是 C++ STL 中的关联容器，基于红黑树实现，存储唯一的有序元素。

## 基本特性

**核心特征**

- **唯一性**：不允许重复元素
- **有序性**：元素按照比较函数自动排序
- **关联性**：元素本身就是键值
- **不可修改**：元素一旦插入就不能直接修改
- **对数时间复杂度**：查找、插入、删除都是 O(log n)

**底层实现**

- **红黑树**：自平衡二叉搜索树
- **双向迭代器**：支持前向和后向遍历
- **稳定的迭代器**：插入删除不会使其他迭代器失效（除了被删除的元素）

## 声明和初始化

```cpp
#include <set>
#include <iostream>
#include <string>

// 基本声明
std::set<int> s1;                          // 空集合
std::set<int> s2{3, 1, 4, 1, 5, 9};        // 初始化列表，重复元素会被忽略
std::set<int> s3(s2);                      // 拷贝构造
std::set<int> s4(s2.begin(), s2.end());    // 迭代器范围构造

// 自定义比较器
std::set<int, std::greater<int>> s5{1, 2, 3}; // 降序排列

// 字符串集合
std::set<std::string> strSet{"apple", "banana", "cherry"};

// 自定义类型
struct Person {
    std::string name;
    int age;
    
    bool operator<(const Person& other) const {
        return age < other.age; // 按年龄排序
    }
};
std::set<Person> personSet;
```

## 基本操作

**插入操作**

```cpp
std::set<int> s;

// 插入单个元素
auto result1 = s.insert(10);        // 返回 pair<iterator, bool>
if (result1.second) {
    std::cout << "插入成功: " << *result1.first << std::endl;
}

// 插入多个元素
s.insert({20, 30, 40, 20});         // 重复的20只会插入一次

// 指定位置插入（提示位置，可能提高效率）
auto it = s.find(20);
s.insert(it, 25);                   // 在20附近插入25

// 范围插入
std::vector<int> vec{50, 60, 70};
s.insert(vec.begin(), vec.end());

// 就地构造
s.emplace(80);                      // 等价于insert(80)
s.emplace_hint(s.end(), 90);       // 带提示的就地构造
```

**查找操作**

```cpp
std::set<int> s{1, 2, 3, 4, 5};

// 查找元素
auto it = s.find(3);
if (it != s.end()) {
    std::cout << "找到: " << *it << std::endl;
}

// 计数（对于set总是0或1）
if (s.count(4) > 0) {
    std::cout << "4存在于集合中" << std::endl;
}

// C++20: contains方法
// if (s.contains(5)) {
//     std::cout << "5存在于集合中" << std::endl;
// }

// 边界查找
auto lower = s.lower_bound(3);      // 第一个不小于3的元素
auto upper = s.upper_bound(3);      // 第一个大于3的元素
auto range = s.equal_range(3);      // 等于3的元素范围

std::cout << "lower_bound(3): " << *lower << std::endl;
std::cout << "upper_bound(3): " << *upper << std::endl;
```

**删除操作**

```cpp
std::set<int> s{1, 2, 3, 4, 5, 6, 7, 8, 9};

// 按值删除
size_t removed = s.erase(5);        // 返回删除的元素个数
std::cout << "删除了 " << removed << " 个元素" << std::endl;

// 按迭代器删除
auto it = s.find(3);
if (it != s.end()) {
    s.erase(it);                    // 删除迭代器指向的元素
}

// 范围删除
auto start = s.find(6);
auto end = s.find(9);
s.erase(start, end);               // 删除[6, 9)范围的元素

// 清空
s.clear();                         // 删除所有元素
```

**大小和状态**

```cpp
std::set<int> s{1, 2, 3};

bool isEmpty = s.empty();           // 检查是否为空
size_t size = s.size();             // 获取元素个数
size_t maxSize = s.max_size();      // 获取最大可能大小

std::cout << "大小: " << size << std::endl;
std::cout << "是否为空: " << (isEmpty ? "是" : "否") << std::endl;
```

## 迭代器

```cpp
std::set<int> s{5, 2, 8, 1, 9};

// 各种迭代器类型
std::set<int>::iterator it = s.begin();
std::set<int>::const_iterator cit = s.cbegin();
std::set<int>::reverse_iterator rit = s.rbegin();
std::set<int>::const_reverse_iterator crit = s.crbegin();

// C++11 auto简化
auto it2 = s.begin();
auto cit2 = s.cbegin();
```

```cpp
std::set<int> s{5, 2, 8, 1, 9};

// 正向遍历（自动有序）
std::cout << "正向遍历: ";
for (auto it = s.begin(); it != s.end(); ++it) {
    std::cout << *it << " ";        // 输出: 1 2 5 8 9
}
std::cout << std::endl;

// 反向遍历
std::cout << "反向遍历: ";
for (auto rit = s.rbegin(); rit != s.rend(); ++rit) {
    std::cout << *rit << " ";       // 输出: 9 8 5 2 1
}
std::cout << std::endl;

// 范围for循环（推荐）
std::cout << "范围for: ";
for (const auto& elem : s) {
    std::cout << elem << " ";
}
std::cout << std::endl;
```

## 自定义比较器

**1. 函数对象比较器**

```cpp
// 降序比较器
struct DescendingCompare {
    bool operator()(int a, int b) const {
        return a > b;  // 降序
    }
};

std::set<int, DescendingCompare> descSet{3, 1, 4, 1, 5};
// 结果: {5, 4, 3, 1}

// 字符串长度比较器
struct StringLengthCompare {
    bool operator()(const std::string& a, const std::string& b) const {
        if (a.length() != b.length()) {
            return a.length() < b.length();
        }
        return a < b;  // 长度相同时按字典序
    }
};

std::set<std::string, StringLengthCompare> strSet{"apple", "hi", "banana", "a"};
// 结果: {"a", "hi", "apple", "banana"}
```

**2. Lambda表达式比较器**

```cpp
// 使用lambda作为比较器
auto cmp = [](int a, int b) { return a > b; };
std::set<int, decltype(cmp)> lambdaSet(cmp);
lambdaSet.insert({1, 3, 2, 5, 4});
// 结果: {5, 4, 3, 2, 1}

// 复杂对象的lambda比较器
struct Point {
    int x, y;
    Point(int x, int y) : x(x), y(y) {}
};

auto pointCmp = [](const Point& a, const Point& b) {
    if (a.x != b.x) return a.x < b.x;
    return a.y < b.y;
};

std::set<Point, decltype(pointCmp)> pointSet(pointCmp);
pointSet.emplace(1, 2);
pointSet.emplace(1, 1);
pointSet.emplace(2, 1);
```

**3. 函数指针比较器**

```cpp
// 函数指针比较器
bool descendingCompare(int a, int b) {
    return a > b;
}

std::set<int, bool(*)(int, int)> funcPtrSet(descendingCompare);
funcPtrSet.insert({1, 3, 2, 5, 4});
```

## 集合运算

**1. 使用STL算法进行集合运算**

```cpp
#include <algorithm>

std::set<int> set1{1, 2, 3, 4, 5};
std::set<int> set2{3, 4, 5, 6, 7};
std::set<int> result;

// 并集
std::set_union(set1.begin(), set1.end(),
               set2.begin(), set2.end(),
               std::inserter(result, result.begin()));
// result: {1, 2, 3, 4, 5, 6, 7}

result.clear();

// 交集
std::set_intersection(set1.begin(), set1.end(),
                      set2.begin(), set2.end(),
                      std::inserter(result, result.begin()));
// result: {3, 4, 5}

result.clear();

// 差集（set1 - set2）
std::set_difference(set1.begin(), set1.end(),
                    set2.begin(), set2.end(),
                    std::inserter(result, result.begin()));
// result: {1, 2}

result.clear();

// 对称差集（并集 - 交集）
std::set_symmetric_difference(set1.begin(), set1.end(),
                              set2.begin(), set2.end(),
                              std::inserter(result, result.begin()));
// result: {1, 2, 6, 7}
```

**2. 自定义集合运算函数**

```cpp
template<typename T>
std::set<T> setUnion(const std::set<T>& s1, const std::set<T>& s2) {
    std::set<T> result = s1;
    result.insert(s2.begin(), s2.end());
    return result;
}

template<typename T>
std::set<T> setIntersection(const std::set<T>& s1, const std::set<T>& s2) {
    std::set<T> result;
    std::set_intersection(s1.begin(), s1.end(),
                          s2.begin(), s2.end(),
                          std::inserter(result, result.begin()));
    return result;
}

template<typename T>
bool isSubset(const std::set<T>& subset, const std::set<T>& superset) {
    return std::includes(superset.begin(), superset.end(),
                         subset.begin(), subset.end());
}

// 使用示例
std::set<int> s1{1, 2, 3};
std::set<int> s2{2, 3, 4};

auto unionSet = setUnion(s1, s2);           // {1, 2, 3, 4}
auto intersectionSet = setIntersection(s1, s2); // {2, 3}
bool isS1SubsetOfS2 = isSubset(s1, s2);     // false
```

## 算法

```cpp
#include <algorithm>
#include <numeric>

std::set<int> s{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

// 查找算法
auto it = std::find(s.begin(), s.end(), 5);
if (it != s.end()) {
    std::cout << "找到: " << *it << std::endl;
}

// 条件查找
auto evenIt = std::find_if(s.begin(), s.end(),
                           [](int x) { return x % 2 == 0; });
if (evenIt != s.end()) {
    std::cout << "第一个偶数: " << *evenIt << std::endl;
}

// 计数算法
int evenCount = std::count_if(s.begin(), s.end(),
                              [](int x) { return x % 2 == 0; });
std::cout << "偶数个数: " << evenCount << std::endl;

// 累加算法
int sum = std::accumulate(s.begin(), s.end(), 0);
std::cout << "元素总和: " << sum << std::endl;

// 变换算法（注意：不能直接修改set元素）
std::vector<int> doubled;
std::transform(s.begin(), s.end(), std::back_inserter(doubled),
               [](int x) { return x * 2; });

// 检查算法
bool allPositive = std::all_of(s.begin(), s.end(),
                               [](int x) { return x > 0; });
bool anyEven = std::any_of(s.begin(), s.end(),
                          [](int x) { return x % 2 == 0; });
bool noneNegative = std::none_of(s.begin(), s.end(),
                                 [](int x) { return x < 0; });
```

## 内部实现原理

**1. 红黑树结构**

```cpp
// 简化的红黑树节点结构
template<typename T>
struct RBTreeNode {
    T data;
    RBTreeNode* parent;
    RBTreeNode* left;
    RBTreeNode* right;
    bool isRed;  // 红黑树颜色
    
    RBTreeNode(const T& value) 
        : data(value), parent(nullptr), left(nullptr), 
          right(nullptr), isRed(true) {}
};
```

**2. 红黑树性质**

1. **节点颜色**：每个节点要么是红色，要么是黑色
2. **根节点**：根节点是黑色
3. **叶节点**：所有叶节点（NIL）都是黑色
4. **红色节点**：红色节点的子节点必须是黑色
5. **黑色高度**：从任一节点到其叶节点的所有路径包含相同数量的黑色节点

| 操作 | 平均时间复杂度 | 最坏时间复杂度 |
| ---- | -------------- | -------------- |
| 查找 | O(log n)       | O(log n)       |
| 插入 | O(log n)       | O(log n)       |
| 删除 | O(log n)       | O(log n)       |
| 遍历 | O(n)           | O(n)           |

## 应用

### 去重和排序
```cpp
// 从向量中去除重复元素并排序
std::vector<int> vec{3, 1, 4, 1, 5, 9, 2, 6, 5};
std::set<int> uniqueSet(vec.begin(), vec.end());
vec.assign(uniqueSet.begin(), uniqueSet.end());
// vec现在是: {1, 2, 3, 4, 5, 6, 9}

// 函数形式
template<typename T>
std::vector<T> removeDuplicatesAndSort(const std::vector<T>& input) {
    std::set<T> uniqueSet(input.begin(), input.end());
    return std::vector<T>(uniqueSet.begin(), uniqueSet.end());
}
```

### 词频统计
```cpp
#include <map>
#include <sstream>

class TextAnalyzer {
private:
    std::map<std::string, int> wordCount;
    std::set<std::string> uniqueWords;
    
public:
    void addText(const std::string& text) {
        std::istringstream iss(text);
        std::string word;
        
        while (iss >> word) {
            // 简单的单词清理
            word.erase(std::remove_if(word.begin(), word.end(),
                                      [](char c) { return !std::isalnum(c); }),
                       word.end());
            
            if (!word.empty()) {
                std::transform(word.begin(), word.end(), word.begin(), ::tolower);
                wordCount[word]++;
                uniqueWords.insert(word);
            }
        }
    }
    
    std::set<std::string> getUniqueWords() const {
        return uniqueWords;
    }
    
    int getWordCount(const std::string& word) const {
        auto it = wordCount.find(word);
        return (it != wordCount.end()) ? it->second : 0;
    }
    
    void printStatistics() const {
        std::cout << "总共有 " << uniqueWords.size() << " 个不同的单词:" << std::endl;
        for (const auto& word : uniqueWords) {
            std::cout << word << ": " << wordCount.at(word) << std::endl;
        }
    }
};
```

### 权限管理系统
```cpp
class PermissionManager {
private:
    std::map<std::string, std::set<std::string>> userPermissions;
    std::set<std::string> allPermissions;
    
public:
    void addPermission(const std::string& permission) {
        allPermissions.insert(permission);
    }
    
    void grantPermission(const std::string& user, const std::string& permission) {
        if (allPermissions.count(permission)) {
            userPermissions[user].insert(permission);
        }
    }
    
    void revokePermission(const std::string& user, const std::string& permission) {
        userPermissions[user].erase(permission);
    }
    
    bool hasPermission(const std::string& user, const std::string& permission) const {
        auto it = userPermissions.find(user);
        if (it != userPermissions.end()) {
            return it->second.count(permission) > 0;
        }
        return false;
    }
    
    std::set<std::string> getUserPermissions(const std::string& user) const {
        auto it = userPermissions.find(user);
        return (it != userPermissions.end()) ? it->second : std::set<std::string>();
    }
    
    std::set<std::string> getCommonPermissions(const std::string& user1, 
                                               const std::string& user2) const {
        auto perms1 = getUserPermissions(user1);
        auto perms2 = getUserPermissions(user2);
        std::set<std::string> common;
        
        std::set_intersection(perms1.begin(), perms1.end(),
                              perms2.begin(), perms2.end(),
                              std::inserter(common, common.begin()));
        return common;
    }
};
```

### 图的邻接表表示
```cpp
class Graph {
private:
    std::map<int, std::set<int>> adjacencyList;
    
public:
    void addVertex(int vertex) {
        adjacencyList[vertex]; // 创建空的邻接集合
    }
    
    void addEdge(int from, int to) {
        adjacencyList[from].insert(to);
        adjacencyList[to].insert(from); // 无向图
    }
    
    void removeEdge(int from, int to) {
        adjacencyList[from].erase(to);
        adjacencyList[to].erase(from);
    }
    
    bool hasEdge(int from, int to) const {
        auto it = adjacencyList.find(from);
        if (it != adjacencyList.end()) {
            return it->second.count(to) > 0;
        }
        return false;
    }
    
    std::set<int> getNeighbors(int vertex) const {
        auto it = adjacencyList.find(vertex);
        return (it != adjacencyList.end()) ? it->second : std::set<int>();
    }
    
    int getDegree(int vertex) const {
        return getNeighbors(vertex).size();
    }
    
    std::set<int> getAllVertices() const {
        std::set<int> vertices;
        for (const auto& pair : adjacencyList) {
            vertices.insert(pair.first);
        }
        return vertices;
    }
};
```

### 区间集合
```cpp
#include <iostream>

struct Interval {
    int start, end;
    
    Interval(int s, int e) : start(s), end(e) {}
    
    bool operator<(const Interval& other) const {
        return start < other.start;
    }
    
    bool overlaps(const Interval& other) const {
        return !(end < other.start || other.end < start);
    }
    
    Interval merge(const Interval& other) const {
        return Interval(std::min(start, other.start), 
                       std::max(end, other.end));
    }
};

class IntervalSet {
private:
    std::set<Interval> intervals;
    
public:
    void addInterval(const Interval& newInterval) {
        auto it = intervals.lower_bound(newInterval);
        
        // 向前查找重叠的区间
        while (it != intervals.begin()) {
            auto prev = std::prev(it);
            if (prev->overlaps(newInterval)) {
                it = prev;
            } else {
                break;
            }
        }
        
        // 合并所有重叠的区间
        Interval merged = newInterval;
        while (it != intervals.end() && it->overlaps(merged)) {
            merged = merged.merge(*it);
            it = intervals.erase(it);
        }
        
        intervals.insert(merged);
    }
    
    void printIntervals() const {
        for (const auto& interval : intervals) {
            std::cout << "[" << interval.start << ", " 
                      << interval.end << "] ";
        }
        std::cout << std::endl;
    }
};
```

## 总结

**优势**

1. **自动排序**：元素始终保持有序状态
2. **唯一性保证**：自动去重，避免重复元素
3. **对数时间复杂度**：查找、插入、删除都是O(log n)
4. **稳定的迭代器**：插入删除不会使其他迭代器失效
5. **丰富的查找功能**：支持范围查找、边界查找
6. **集合运算支持**：配合STL算法进行集合运算

**劣势**

1. **内存开销大**：每个节点需要额外的指针和颜色信息
2. **无随机访问**：不能通过下标直接访问元素
3. **插入性能**：比哈希表慢，比vector的尾部插入慢
4. **缓存不友好**：非连续内存布局影响性能
5. **元素不可修改**：插入后不能直接修改元素值

**适用场景**

- 需要自动排序的唯一元素集合
- 频繁的查找、插入、删除操作
- 需要进行集合运算（并集、交集、差集）
- 需要范围查询功能
- 实现索引、去重、权限管理等功能
- 对元素顺序有要求的场景

`std::set` 是实现有序唯一集合的理想选择，在需要自动排序和去重的场景下表现优异。


# map

`std::map` 是 C++ STL 中的关联容器，基于红黑树实现，存储键值对并按键自动排序。

## 基本特性

**1. 核心特征**

- **键值对存储**：存储 `std::pair<const Key, Value>` 类型的元素
- **唯一键**：每个键只能出现一次
- **自动排序**：按键的比较函数自动排序
- **关联性**：通过键快速访问对应的值
- **对数时间复杂度**：查找、插入、删除都是 O(log n)

**2. 底层实现**

- **红黑树**：自平衡二叉搜索树
- **双向迭代器**：支持前向和后向遍历
- **稳定的迭代器**：插入删除不会使其他迭代器失效（除了被删除的元素）

## 声明和初始化

```cpp
#include <map>
#include <iostream>
#include <string>

// 基本声明
std::map<int, std::string> m1;                    // 空映射
std::map<int, std::string> m2{{1, "one"}, {2, "two"}, {3, "three"}}; // 初始化列表
std::map<int, std::string> m3(m2);                // 拷贝构造
std::map<int, std::string> m4(m2.begin(), m2.end()); // 迭代器范围构造

// 自定义比较器
std::map<int, std::string, std::greater<int>> m5; // 降序排列

// 字符串键的映射
std::map<std::string, int> wordCount;

// 自定义类型作为键
struct Person {
    std::string name;
    int age;
    
    bool operator<(const Person& other) const {
        if (name != other.name) return name < other.name;
        return age < other.age;
    }
};
std::map<Person, std::string> personInfo;
```

## 基本操作

**1. 插入操作**

```cpp
std::map<int, std::string> m;

// 使用下标操作符插入/修改
m[1] = "one";                    // 插入新元素
m[1] = "ONE";                    // 修改现有元素

// 使用insert插入
auto result1 = m.insert({2, "two"});           // 返回 pair<iterator, bool>
if (result1.second) {
    std::cout << "插入成功: " << result1.first->second << std::endl;
}

// 使用insert插入pair
auto result2 = m.insert(std::make_pair(3, "three"));

// 指定位置插入（提示位置）
auto it = m.find(2);
m.insert(it, {4, "four"});      // 在2附近插入4

// 范围插入
std::map<int, std::string> other{{5, "five"}, {6, "six"}};
m.insert(other.begin(), other.end());

// 就地构造
m.emplace(7, "seven");           // 直接构造pair
m.emplace_hint(m.end(), 8, "eight"); // 带提示的就地构造

// try_emplace (C++17)
m.try_emplace(9, "nine");        // 只在键不存在时插入
m.try_emplace(9, "NINE");        // 键已存在，不会插入

// insert_or_assign (C++17)
m.insert_or_assign(10, "ten");   // 插入或赋值
m.insert_or_assign(10, "TEN");   // 键已存在，会更新值
```

**2. 访问操作**

```cpp
std::map<int, std::string> m{{1, "one"}, {2, "two"}, {3, "three"}};

// 下标访问
std::string value1 = m[1];       // 获取键1对应的值
m[4] = "four";                   // 如果键不存在，会插入新元素

// at方法（安全访问）
try {
    std::string value2 = m.at(2); // 安全访问，键不存在会抛异常
    std::string value3 = m.at(10); // 抛出 std::out_of_range
} catch (const std::out_of_range& e) {
    std::cout << "键不存在: " << e.what() << std::endl;
}

// 查找
auto it = m.find(3);
if (it != m.end()) {
    std::cout << "找到: " << it->first << " -> " << it->second << std::endl;
}

// 计数（对于map总是0或1）
if (m.count(2) > 0) {
    std::cout << "键2存在" << std::endl;
}

// C++20: contains方法
// if (m.contains(3)) {
//     std::cout << "键3存在" << std::endl;
// }

// 边界查找
auto lower = m.lower_bound(2);   // 第一个不小于2的元素
auto upper = m.upper_bound(2);   // 第一个大于2的元素
auto range = m.equal_range(2);   // 等于2的元素范围
```

**3. 删除操作**

```cpp
std::map<int, std::string> m{{1, "one"}, {2, "two"}, {3, "three"}, {4, "four"}};

// 按键删除
size_t removed = m.erase(2);     // 返回删除的元素个数
std::cout << "删除了 " << removed << " 个元素" << std::endl;

// 按迭代器删除
auto it = m.find(3);
if (it != m.end()) {
    m.erase(it);                 // 删除迭代器指向的元素
}

// 范围删除
auto start = m.find(1);
auto end = m.find(4);
m.erase(start, end);             // 删除[1, 4)范围的元素

// 清空
m.clear();                       // 删除所有元素
```

**4. 大小和状态**

```cpp
std::map<int, std::string> m{{1, "one"}, {2, "two"}};

bool isEmpty = m.empty();        // 检查是否为空
size_t size = m.size();          // 获取元素个数
size_t maxSize = m.max_size();   // 获取最大可能大小

std::cout << "大小: " << size << std::endl;
std::cout << "是否为空: " << (isEmpty ? "是" : "否") << std::endl;
```

## 迭代器

```cpp
std::map<int, std::string> m{{3, "three"}, {1, "one"}, {2, "two"}};

// 各种迭代器类型
std::map<int, std::string>::iterator it = m.begin();
std::map<int, std::string>::const_iterator cit = m.cbegin();
std::map<int, std::string>::reverse_iterator rit = m.rbegin();
std::map<int, std::string>::const_reverse_iterator crit = m.crbegin();

// C++11 auto简化
auto it2 = m.begin();
auto cit2 = m.cbegin();
```

```cpp
std::map<int, std::string> m{{3, "three"}, {1, "one"}, {2, "two"}};

// 正向遍历（自动按键排序）
std::cout << "正向遍历: " << std::endl;
for (auto it = m.begin(); it != m.end(); ++it) {
    std::cout << it->first << " -> " << it->second << std::endl;
    // 输出: 1 -> one, 2 -> two, 3 -> three
}

// 反向遍历
std::cout << "反向遍历: " << std::endl;
for (auto rit = m.rbegin(); rit != m.rend(); ++rit) {
    std::cout << rit->first << " -> " << rit->second << std::endl;
    // 输出: 3 -> three, 2 -> two, 1 -> one
}

// 范围for循环（推荐）
std::cout << "范围for: " << std::endl;
for (const auto& pair : m) {
    std::cout << pair.first << " -> " << pair.second << std::endl;
}

// 结构化绑定 (C++17)
std::cout << "结构化绑定: " << std::endl;
for (const auto& [key, value] : m) {
    std::cout << key << " -> " << value << std::endl;
}

// 只遍历键或值
std::cout << "只遍历键: ";
for (const auto& pair : m) {
    std::cout << pair.first << " ";
}
std::cout << std::endl;

std::cout << "只遍历值: ";
for (const auto& pair : m) {
    std::cout << pair.second << " ";
}
std::cout << std::endl;
```

## 自定义比较器

**1. 函数对象比较器**

```cpp
// 降序比较器
struct DescendingCompare {
    bool operator()(int a, int b) const {
        return a > b;  // 降序
    }
};

std::map<int, std::string, DescendingCompare> descMap;
descMap[1] = "one";
descMap[3] = "three";
descMap[2] = "two";
// 遍历结果: 3->three, 2->two, 1->one

// 字符串长度比较器
struct StringLengthCompare {
    bool operator()(const std::string& a, const std::string& b) const {
        if (a.length() != b.length()) {
            return a.length() < b.length();
        }
        return a < b;  // 长度相同时按字典序
    }
};

std::map<std::string, int, StringLengthCompare> lengthMap;
lengthMap["a"] = 1;
lengthMap["hi"] = 2;
lengthMap["apple"] = 5;
lengthMap["banana"] = 6;
// 按字符串长度排序
```

**2. Lambda表达式比较器**

```cpp
// 使用lambda作为比较器
auto cmp = [](int a, int b) { return a > b; };
std::map<int, std::string, decltype(cmp)> lambdaMap(cmp);
lambdaMap[1] = "one";
lambdaMap[3] = "three";
lambdaMap[2] = "two";
// 降序排列

// 复杂对象的lambda比较器
struct Point {
    int x, y;
    Point(int x, int y) : x(x), y(y) {}
};

auto pointCmp = [](const Point& a, const Point& b) {
    if (a.x != b.x) return a.x < b.x;
    return a.y < b.y;
};

std::map<Point, std::string, decltype(pointCmp)> pointMap(pointCmp);
pointMap.emplace(std::piecewise_construct,
                 std::forward_as_tuple(1, 2),
                 std::forward_as_tuple("point1"));
```

**3. 函数指针比较器**

```cpp
// 函数指针比较器
bool descendingCompare(int a, int b) {
    return a > b;
}

std::map<int, std::string, bool(*)(int, int)> funcPtrMap(descendingCompare);
funcPtrMap[1] = "one";
funcPtrMap[3] = "three";
funcPtrMap[2] = "two";
```

## 高级用法

### 嵌套map
```cpp
// 二维映射
std::map<std::string, std::map<std::string, int>> nestedMap;
nestedMap["fruits"]["apple"] = 5;
nestedMap["fruits"]["banana"] = 3;
nestedMap["vegetables"]["carrot"] = 10;
nestedMap["vegetables"]["potato"] = 8;

// 访问嵌套值
int appleCount = nestedMap["fruits"]["apple"];

// 安全访问嵌套值
try {
    int count = nestedMap.at("fruits").at("orange");
} catch (const std::out_of_range& e) {
    std::cout << "键不存在" << std::endl;
}
```

### map作为计数器
```cpp
#include <sstream>

// 词频统计
std::string text = "hello world hello cpp world";
std::map<std::string, int> wordCount;
std::istringstream iss(text);
std::string word;

while (iss >> word) {
    wordCount[word]++;  // 自动初始化为0然后递增
}

// 输出词频
for (const auto& [word, count] : wordCount) {
    std::cout << word << ": " << count << std::endl;
}

// 字符频率统计
std::string str = "hello";
std::map<char, int> charCount;
for (char c : str) {
    charCount[c]++;
}
```

### map的值为复杂类型
```cpp
// 值为vector
std::map<std::string, std::vector<int>> categoryNumbers;
categoryNumbers["even"].push_back(2);
categoryNumbers["even"].push_back(4);
categoryNumbers["odd"].push_back(1);
categoryNumbers["odd"].push_back(3);

// 值为自定义结构
struct StudentInfo {
    std::string name;
    int age;
    std::vector<int> grades;
};

std::map<int, StudentInfo> students;
students[1001] = {"Alice", 20, {85, 90, 88}};
students[1002] = {"Bob", 21, {78, 82, 85}};

// 访问学生信息
std::cout << "学生1001的姓名: " << students[1001].name << std::endl;
students[1001].grades.push_back(92);  // 添加新成绩
```

## 算法

```cpp
#include <algorithm>
#include <numeric>

std::map<std::string, int> scores{{"Alice", 85}, {"Bob", 92}, {"Charlie", 78}, {"David", 95}};

// 查找算法
auto it = std::find_if(scores.begin(), scores.end(),
                       [](const auto& pair) { return pair.second > 90; });
if (it != scores.end()) {
    std::cout << "第一个高分学生: " << it->first << " (" << it->second << ")" << std::endl;
}

// 计数算法
int highScoreCount = std::count_if(scores.begin(), scores.end(),
                                   [](const auto& pair) { return pair.second >= 90; });
std::cout << "高分学生数量: " << highScoreCount << std::endl;

// 累加算法
int totalScore = std::accumulate(scores.begin(), scores.end(), 0,
                                 [](int sum, const auto& pair) {
                                     return sum + pair.second;
                                 });
std::cout << "总分: " << totalScore << std::endl;
double averageScore = static_cast<double>(totalScore) / scores.size();
std::cout << "平均分: " << averageScore << std::endl;

// 变换算法
std::vector<std::string> names;
std::transform(scores.begin(), scores.end(), std::back_inserter(names),
               [](const auto& pair) { return pair.first; });

std::vector<int> scoreValues;
std::transform(scores.begin(), scores.end(), std::back_inserter(scoreValues),
               [](const auto& pair) { return pair.second; });

// 检查算法
bool allPassed = std::all_of(scores.begin(), scores.end(),
                             [](const auto& pair) { return pair.second >= 60; });
bool anyExcellent = std::any_of(scores.begin(), scores.end(),
                                [](const auto& pair) { return pair.second >= 95; });
bool noneFailed = std::none_of(scores.begin(), scores.end(),
                               [](const auto& pair) { return pair.second < 60; });

std::cout << "所有人都及格: " << (allPassed ? "是" : "否") << std::endl;
std::cout << "有人优秀: " << (anyExcellent ? "是" : "否") << std::endl;
std::cout << "没有人不及格: " << (noneFailed ? "是" : "否") << std::endl;
```

## 内部实现原理

**1. 红黑树节点结构**

```cpp
// 简化的红黑树节点结构
template<typename Key, typename Value>
struct MapNode {
    std::pair<const Key, Value> data;  // 键值对数据
    MapNode* parent;
    MapNode* left;
    MapNode* right;
    bool isRed;  // 红黑树颜色
    
    MapNode(const Key& k, const Value& v) 
        : data(k, v), parent(nullptr), left(nullptr), 
          right(nullptr), isRed(true) {}
};
```

**2. 时间复杂度分析**

| 操作     | 平均时间复杂度 | 最坏时间复杂度 |
| -------- | -------------- | -------------- |
| 查找     | O(log n)       | O(log n)       |
| 插入     | O(log n)       | O(log n)       |
| 删除     | O(log n)       | O(log n)       |
| 遍历     | O(n)           | O(n)           |
| 下标访问 | O(log n)       | O(log n)       |

**3. 内存布局**

- **非连续存储**：每个节点独立分配内存
- **额外开销**：每个节点需要存储3个指针和颜色信息
- **键的常量性**：键被声明为const，确保不能修改

## 应用

### 配置管理系统
```cpp
class ConfigManager {
private:
    std::map<std::string, std::string> stringConfigs;
    std::map<std::string, int> intConfigs;
    std::map<std::string, bool> boolConfigs;
    
public:
    void setString(const std::string& key, const std::string& value) {
        stringConfigs[key] = value;
    }
    
    void setInt(const std::string& key, int value) {
        intConfigs[key] = value;
    }
    
    void setBool(const std::string& key, bool value) {
        boolConfigs[key] = value;
    }
    
    std::string getString(const std::string& key, const std::string& defaultValue = "") const {
        auto it = stringConfigs.find(key);
        return (it != stringConfigs.end()) ? it->second : defaultValue;
    }
    
    int getInt(const std::string& key, int defaultValue = 0) const {
        auto it = intConfigs.find(key);
        return (it != intConfigs.end()) ? it->second : defaultValue;
    }
    
    bool getBool(const std::string& key, bool defaultValue = false) const {
        auto it = boolConfigs.find(key);
        return (it != boolConfigs.end()) ? it->second : defaultValue;
    }
    
    void loadFromFile(const std::string& filename) {
        // 实现从文件加载配置的逻辑
    }
    
    void saveToFile(const std::string& filename) const {
        // 实现保存配置到文件的逻辑
    }
    
    void printAllConfigs() const {
        std::cout << "String Configs:" << std::endl;
        for (const auto& [key, value] : stringConfigs) {
            std::cout << "  " << key << " = " << value << std::endl;
        }
        
        std::cout << "Int Configs:" << std::endl;
        for (const auto& [key, value] : intConfigs) {
            std::cout << "  " << key << " = " << value << std::endl;
        }
        
        std::cout << "Bool Configs:" << std::endl;
        for (const auto& [key, value] : boolConfigs) {
            std::cout << "  " << key << " = " << (value ? "true" : "false") << std::endl;
        }
    }
};
```

### 学生成绩管理系统
```cpp
struct Student {
    std::string name;
    int age;
    std::map<std::string, int> grades;  // 科目 -> 成绩
    
    double getAverageGrade() const {
        if (grades.empty()) return 0.0;
        
        int total = 0;
        for (const auto& [subject, grade] : grades) {
            total += grade;
        }
        return static_cast<double>(total) / grades.size();
    }
    
    void addGrade(const std::string& subject, int grade) {
        grades[subject] = grade;
    }
    
    int getGrade(const std::string& subject) const {
        auto it = grades.find(subject);
        return (it != grades.end()) ? it->second : -1;
    }
};

class GradeManager {
private:
    std::map<int, Student> students;  // 学号 -> 学生信息
    
public:
    void addStudent(int id, const std::string& name, int age) {
        students[id] = {name, age, {}};
    }
    
    void addGrade(int studentId, const std::string& subject, int grade) {
        auto it = students.find(studentId);
        if (it != students.end()) {
            it->second.addGrade(subject, grade);
        }
    }
    
    double getStudentAverage(int studentId) const {
        auto it = students.find(studentId);
        return (it != students.end()) ? it->second.getAverageGrade() : 0.0;
    }
    
    std::map<std::string, double> getSubjectAverages() const {
        std::map<std::string, std::vector<int>> subjectGrades;
        
        // 收集所有科目的成绩
        for (const auto& [id, student] : students) {
            for (const auto& [subject, grade] : student.grades) {
                subjectGrades[subject].push_back(grade);
            }
        }
        
        // 计算每个科目的平均分
        std::map<std::string, double> averages;
        for (const auto& [subject, grades] : subjectGrades) {
            int total = std::accumulate(grades.begin(), grades.end(), 0);
            averages[subject] = static_cast<double>(total) / grades.size();
        }
        
        return averages;
    }
    
    void printStudentReport(int studentId) const {
        auto it = students.find(studentId);
        if (it != students.end()) {
            const auto& student = it->second;
            std::cout << "学生报告 - ID: " << studentId << std::endl;
            std::cout << "姓名: " << student.name << ", 年龄: " << student.age << std::endl;
            std::cout << "成绩:" << std::endl;
            
            for (const auto& [subject, grade] : student.grades) {
                std::cout << "  " << subject << ": " << grade << std::endl;
            }
            
            std::cout << "平均分: " << student.getAverageGrade() << std::endl;
        }
    }
};
```

### 缓存系统
```cpp
template<typename Key, typename Value>
class LRUCache {
private:
    size_t capacity;
    std::list<std::pair<Key, Value>> cache;
    std::map<Key, typename std::list<std::pair<Key, Value>>::iterator> keyToIter;
    
public:
    LRUCache(size_t cap) : capacity(cap) {}
    
    Value get(const Key& key) {
        auto mapIt = keyToIter.find(key);
        if (mapIt == keyToIter.end()) {
            throw std::runtime_error("Key not found");
        }
        
        // 移动到前端
        auto listIt = mapIt->second;
        cache.splice(cache.begin(), cache, listIt);
        
        return listIt->second;
    }
    
    void put(const Key& key, const Value& value) {
        auto mapIt = keyToIter.find(key);
        
        if (mapIt != keyToIter.end()) {
            // 更新现有键
            auto listIt = mapIt->second;
            listIt->second = value;
            cache.splice(cache.begin(), cache, listIt);
        } else {
            // 添加新键
            if (cache.size() >= capacity) {
                // 删除最久未使用的
                auto last = cache.back();
                keyToIter.erase(last.first);
                cache.pop_back();
            }
            
            cache.emplace_front(key, value);
            keyToIter[key] = cache.begin();
        }
    }
    
    bool contains(const Key& key) const {
        return keyToIter.find(key) != keyToIter.end();
    }
    
    size_t size() const {
        return cache.size();
    }
    
    void printCache() const {
        std::cout << "Cache contents (most recent first):" << std::endl;
        for (const auto& [key, value] : cache) {
            std::cout << "  " << key << " -> " << value << std::endl;
        }
    }
};
```

### 状态机实现
```cpp
enum class State { IDLE, RUNNING, PAUSED, STOPPED };
enum class Event { START, PAUSE, RESUME, STOP, RESET };

class StateMachine {
private:
    State currentState;
    std::map<std::pair<State, Event>, State> transitions;
    std::map<State, std::function<void()>> stateActions;
    
public:
    StateMachine() : currentState(State::IDLE) {
        // 定义状态转换
        transitions[{State::IDLE, Event::START}] = State::RUNNING;
        transitions[{State::RUNNING, Event::PAUSE}] = State::PAUSED;
        transitions[{State::RUNNING, Event::STOP}] = State::STOPPED;
        transitions[{State::PAUSED, Event::RESUME}] = State::RUNNING;
        transitions[{State::PAUSED, Event::STOP}] = State::STOPPED;
        transitions[{State::STOPPED, Event::RESET}] = State::IDLE;
        
        // 定义状态动作
        stateActions[State::IDLE] = []() { std::cout << "进入空闲状态" << std::endl; };
        stateActions[State::RUNNING] = []() { std::cout << "进入运行状态" << std::endl; };
        stateActions[State::PAUSED] = []() { std::cout << "进入暂停状态" << std::endl; };
        stateActions[State::STOPPED] = []() { std::cout << "进入停止状态" << std::endl; };
    }
    
    bool processEvent(Event event) {
        auto key = std::make_pair(currentState, event);
        auto it = transitions.find(key);
        
        if (it != transitions.end()) {
            currentState = it->second;
            
            // 执行状态动作
            auto actionIt = stateActions.find(currentState);
            if (actionIt != stateActions.end()) {
                actionIt->second();
            }
            
            return true;
        }
        
        std::cout << "无效的状态转换" << std::endl;
        return false;
    }
    
    State getCurrentState() const {
        return currentState;
    }
    
    std::string getStateName(State state) const {
        static std::map<State, std::string> stateNames = {
            {State::IDLE, "IDLE"},
            {State::RUNNING, "RUNNING"},
            {State::PAUSED, "PAUSED"},
            {State::STOPPED, "STOPPED"}
        };
        
        auto it = stateNames.find(state);
        return (it != stateNames.end()) ? it->second : "UNKNOWN";
    }
};
```

### 惰性求值映射
```cpp
template<typename Key, typename Value>
class LazyMap {
private:
    mutable std::map<Key, std::optional<Value>> cache_;
    std::function<Value(const Key&)> generator_;
    
public:
    LazyMap(std::function<Value(const Key&)> gen) : generator_(gen) {}
    
    const Value& operator[](const Key& key) const {
        auto it = cache_.find(key);
        if (it == cache_.end() || !it->second.has_value()) {
            cache_[key] = generator_(key);
        }
        return cache_[key].value();
    }
    
    void invalidate(const Key& key) {
        cache_.erase(key);
    }
    
    void clear() {
        cache_.clear();
    }
};

// 使用示例
LazyMap<int, std::string> numberNames([](int n) {
    return "Number " + std::to_string(n);
});

std::cout << numberNames[42] << std::endl;  // 第一次计算
std::cout << numberNames[42] << std::endl;  // 使用缓存值
```

## 总结

**优势**

1. **自动排序**：键值对按键自动排序
2. **唯一键约束**：确保每个键只出现一次
3. **对数时间复杂度**：查找、插入、删除都是O(log n)
4. **稳定的迭代器**：插入删除不会使其他迭代器失效
5. **丰富的查找功能**：支持范围查找、边界查找
6. **直观的接口**：下标操作符提供直观的访问方式

**劣势**

1. **内存开销大**：每个节点需要额外的指针和颜色信息
2. **无随机访问**：不能通过索引直接访问元素
3. **插入性能**：比哈希表慢
4. **缓存不友好**：非连续内存布局影响性能
5. **下标操作副作用**：可能意外插入新元素

**适用场景**

- 需要键值对的有序存储
- 频繁的查找、插入、删除操作
- 需要范围查询功能
- 实现配置管理、索引、缓存等功能
- 对键的顺序有要求的场景
- 需要稳定迭代器的场景

`std::map` 是实现有序键值映射的理想选择，在需要自动排序和唯一键约束的场景下表现优异。


# unordered_set

`std::unordered_set` 是 C++11 引入的基于哈希表实现的关联容器，用于存储唯一元素的无序集合。

## 基本特性

**核心特征**

- **唯一性**：不允许重复元素
- **无序性**：元素没有特定的排列顺序
- **基于哈希**：使用哈希表实现，提供平均 O(1) 的操作时间
- **动态大小**：可以动态增长和收缩
- **不可修改元素**：插入后不能直接修改元素值

**底层实现**

- **哈希表**：通常使用链地址法处理冲突
- **桶（Bucket）**：哈希表的存储单元
- **负载因子**：元素数量与桶数量的比值
- **自动扩容**：当负载因子超过阈值时自动扩容

## 声明和初始化

```cpp
#include <unordered_set>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main() {
    // 1. 默认构造
    unordered_set<int> set1;
    
    // 2. 初始化列表构造
    unordered_set<int> set2 = {1, 2, 3, 4, 5};
    unordered_set<string> set3{"apple", "banana", "orange"};
    
    // 3. 范围构造
    vector<int> vec = {10, 20, 30, 40};
    unordered_set<int> set4(vec.begin(), vec.end());
    
    // 4. 拷贝构造
    unordered_set<int> set5(set2);
    
    // 5. 移动构造
    unordered_set<int> set6(std::move(set5));
    
    return 0;
}
```

**自定义哈希和相等比较**

```cpp
// 自定义类型
struct Person {
    string name;
    int age;
    
    Person(const string& n, int a) : name(n), age(a) {}
    
    // unordered_set默认使用equal_to判等，所以重载operator==()
    bool operator==(const Person& other) const {
        return name == other.name && age == other.age;
    }
};

// 自定义哈希函数
struct PersonHash {
    size_t operator()(const Person& p) const {
        return hash<string>{}(p.name) ^ (hash<int>{}(p.age) << 1);
    }
};

// 使用自定义哈希
unordered_set<Person, PersonHash> person_set;
person_set.insert(Person("Alice", 25));
person_set.insert(Person("Bob", 30));

// 或者使用 Lambda 表达式
auto person_hash = [](const Person& p) {
    return hash<string>{}(p.name) ^ (hash<int>{}(p.age) << 1);
};

auto person_equal = [](const Person& a, const Person& b) {
    return a.name == b.name && a.age == b.age;
};

unordered_set<Person, decltype(person_hash), decltype(person_equal)> 
    person_set2(0, person_hash, person_equal);
```

## 基本操作

**插入操作**

```cpp
void demonstrate_insert() {
    unordered_set<int> uset;
    
    // 1. insert() - 返回 pair<iterator, bool>
    auto result1 = uset.insert(10);
    cout << "Inserted: " << result1.second << endl; // true
    cout << "Value: " << *result1.first << endl;    // 10
    
    auto result2 = uset.insert(10); // 重复插入
    cout << "Inserted: " << result2.second << endl; // false
    
    // 2. insert() - 范围插入
    vector<int> values = {20, 30, 40, 20}; // 20重复
    uset.insert(values.begin(), values.end());
    
    // 3. insert() - 初始化列表
    uset.insert({50, 60, 70});
    
    // 4. emplace() - 就地构造
    uset.emplace(80);
    
    // 5. emplace_hint() - 带提示的就地构造
    auto hint = uset.find(50);
    uset.emplace_hint(hint, 55);
    
    // 打印结果
    cout << "Set contents: ";
    for (int val : uset) {
        cout << val << " ";
    }
    cout << endl;
}
```

**查找操作**

```cpp
void demonstrate_search() {
    unordered_set<string> uset = {"apple", "banana", "orange", "grape"};
    
    // 1. find() - 返回迭代器
    auto it = uset.find("banana");
    if (it != uset.end()) {
        cout << "Found: " << *it << endl;
    }
    
    // 2. count() - 返回元素个数（0或1）
    if (uset.count("apple")) {
        cout << "Apple exists" << endl;
    }
    
    // 3. contains() - C++20新增
    #if __cplusplus >= 202002L
    if (uset.contains("orange")) {
        cout << "Orange exists" << endl;
    }
    #endif
    
    // 4. equal_range() - 返回相等元素的范围
    auto range = uset.equal_range("grape");
    cout << "Equal range for grape: ";
    for (auto it = range.first; it != range.second; ++it) {
        cout << *it << " ";
    }
    cout << endl;
}
```

**删除操作**

```cpp
void demonstrate_erase() {
    unordered_set<int> uset = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    cout << "Original size: " << uset.size() << endl;
    
    // 1. erase(key) - 按值删除
    size_t erased = uset.erase(5);
    cout << "Erased " << erased << " elements" << endl;
    
    // 2. erase(iterator) - 按迭代器删除
    auto it = uset.find(3);
    if (it != uset.end()) {
        uset.erase(it);
    }
    
    // 3. erase(range) - 范围删除
    auto start = uset.find(7);
    auto end = uset.find(9);
    if (start != uset.end() && end != uset.end()) {
        ++end; // 包含9
        uset.erase(start, end);
    }
    
    // 4. clear() - 清空所有元素
    // uset.clear();
    
    cout << "Final size: " << uset.size() << endl;
    cout << "Remaining elements: ";
    for (int val : uset) {
        cout << val << " ";
    }
    cout << endl;
}
```

## 迭代器和遍历

```cpp
void demonstrate_iterators() {
    unordered_set<string> uset = {"red", "green", "blue", "yellow"};
    
    // 1. 正向迭代器
    cout << "Forward iteration: ";
    for (auto it = uset.begin(); it != uset.end(); ++it) {
        cout << *it << " ";
    }
    cout << endl;
    
    // 2. 常量迭代器
    cout << "Const iteration: ";
    for (auto it = uset.cbegin(); it != uset.cend(); ++it) {
        cout << *it << " ";
    }
    cout << endl;
    
    // 3. 范围for循环
    cout << "Range-based for: ";
    for (const auto& item : uset) {
        cout << item << " ";
    }
    cout << endl;
    
    // 4. 桶迭代器
    cout << "Bucket iteration:" << endl;
    for (size_t i = 0; i < uset.bucket_count(); ++i) {
        cout << "Bucket " << i << ": ";
        for (auto it = uset.begin(i); it != uset.end(i); ++it) {
            cout << *it << " ";
        }
        cout << endl;
    }
}
```

## 容量和桶操作

**大小和容量**

```cpp
void demonstrate_capacity() {
    unordered_set<int> uset;
    
    cout << "Empty: " << uset.empty() << endl;
    cout << "Size: " << uset.size() << endl;
    cout << "Max size: " << uset.max_size() << endl;
    
    // 插入一些元素
    for (int i = 1; i <= 10; ++i) {
        uset.insert(i);
    }
    
    cout << "After insertion:" << endl;
    cout << "Size: " << uset.size() << endl;
    cout << "Bucket count: " << uset.bucket_count() << endl;
    cout << "Load factor: " << uset.load_factor() << endl;
    cout << "Max load factor: " << uset.max_load_factor() << endl;
}
```

**桶操作**

```cpp
void demonstrate_buckets() {
    unordered_set<string> uset = {"apple", "banana", "cherry", "date", "elderberry"};
    
    cout << "Bucket information:" << endl;
    cout << "Bucket count: " << uset.bucket_count() << endl;
    cout << "Max bucket count: " << uset.max_bucket_count() << endl;
    
    // 查看每个元素在哪个桶中
    for (const auto& item : uset) {
        size_t bucket = uset.bucket(item);
        cout << item << " is in bucket " << bucket << endl;
    }
    
    // 查看每个桶的大小
    cout << "\nBucket sizes:" << endl;
    for (size_t i = 0; i < uset.bucket_count(); ++i) {
        cout << "Bucket " << i << " size: " << uset.bucket_size(i) << endl;
    }
}
```

**哈希策略控制**

```cpp
void demonstrate_hash_policy() {
    unordered_set<int> uset;
    
    cout << "Initial bucket count: " << uset.bucket_count() << endl;
    
    // 1. reserve() - 预留空间
    uset.reserve(100);
    cout << "After reserve(100): " << uset.bucket_count() << endl;
    
    // 2. rehash() - 重新哈希
    uset.rehash(50);
    cout << "After rehash(50): " << uset.bucket_count() << endl;
    
    // 3. 设置最大负载因子
    uset.max_load_factor(0.5);
    cout << "Max load factor set to: " << uset.max_load_factor() << endl;
    
    // 插入元素观察扩容
    for (int i = 1; i <= 30; ++i) {
        uset.insert(i);
        if (i % 10 == 0) {
            cout << "After inserting " << i << " elements:" << endl;
            cout << "  Size: " << uset.size() << endl;
            cout << "  Bucket count: " << uset.bucket_count() << endl;
            cout << "  Load factor: " << uset.load_factor() << endl;
        }
    }
}
```

## 算法

```cpp
#include <algorithm>
#include <numeric>

void demonstrate_algorithms() {
    unordered_set<int> uset = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // 1. std::find
    auto it = std::find(uset.begin(), uset.end(), 5);
    if (it != uset.end()) {
        cout << "Found 5 using std::find" << endl;
    }
    
    // 2. std::count
    int count = std::count(uset.begin(), uset.end(), 3);
    cout << "Count of 3: " << count << endl;
    
    // 3. std::for_each
    cout << "Elements: ";
    std::for_each(uset.begin(), uset.end(), [](int val) {
        cout << val << " ";
    });
    cout << endl;
    
    // 4. std::any_of, std::all_of, std::none_of
    bool has_even = std::any_of(uset.begin(), uset.end(), [](int val) {
        return val % 2 == 0;
    });
    cout << "Has even numbers: " << has_even << endl;
    
    bool all_positive = std::all_of(uset.begin(), uset.end(), [](int val) {
        return val > 0;
    });
    cout << "All positive: " << all_positive << endl;
    
    // 5. 转换为其他容器
    vector<int> vec(uset.begin(), uset.end());
    sort(vec.begin(), vec.end()); // 排序
    cout << "Sorted vector: ";
    for (int val : vec) {
        cout << val << " ";
    }
    cout << endl;
}
```

## 内部实现原理

```cpp
// 简化的 unordered_set 实现示例
template<typename T, typename Hash = std::hash<T>, typename Equal = std::equal_to<T>>
class SimpleUnorderedSet {
private:
    struct Node {
        T data;
        Node* next;
        Node(const T& value) : data(value), next(nullptr) {}
    };
    
    std::vector<Node*> buckets;
    size_t bucket_count_;
    size_t size_;
    double max_load_factor_;
    Hash hasher;
    Equal equal;
    
public:
    SimpleUnorderedSet(size_t initial_bucket_count = 16) 
        : bucket_count_(initial_bucket_count), size_(0), max_load_factor_(1.0) {
        buckets.resize(bucket_count_, nullptr);
    }
    
    ~SimpleUnorderedSet() {
        clear();
    }
    
    bool insert(const T& value) {
        if (load_factor() > max_load_factor_) {
            rehash(bucket_count_ * 2);
        }
        
        size_t bucket_index = hasher(value) % bucket_count_;
        Node* current = buckets[bucket_index];
        
        // 检查是否已存在
        while (current) {
            if (equal(current->data, value)) {
                return false; // 已存在
            }
            current = current->next;
        }
        
        // 插入新节点
        Node* new_node = new Node(value);
        new_node->next = buckets[bucket_index];
        buckets[bucket_index] = new_node;
        size_++;
        return true;
    }
    
    bool find(const T& value) const {
        size_t bucket_index = hasher(value) % bucket_count_;
        Node* current = buckets[bucket_index];
        
        while (current) {
            if (equal(current->data, value)) {
                return true;
            }
            current = current->next;
        }
        return false;
    }
    
    bool erase(const T& value) {
        size_t bucket_index = hasher(value) % bucket_count_;
        Node* current = buckets[bucket_index];
        Node* prev = nullptr;
        
        while (current) {
            if (equal(current->data, value)) {
                if (prev) {
                    prev->next = current->next;
                } else {
                    buckets[bucket_index] = current->next;
                }
                delete current;
                size_--;
                return true;
            }
            prev = current;
            current = current->next;
        }
        return false;
    }
    
    size_t size() const { return size_; }
    bool empty() const { return size_ == 0; }
    double load_factor() const { return (double)size_ / bucket_count_; }
    
private:
    void rehash(size_t new_bucket_count) {
        std::vector<Node*> old_buckets = std::move(buckets);
        size_t old_bucket_count = bucket_count_;
        
        bucket_count_ = new_bucket_count;
        buckets.clear();
        buckets.resize(bucket_count_, nullptr);
        size_ = 0;
        
        // 重新插入所有元素
        for (size_t i = 0; i < old_bucket_count; ++i) {
            Node* current = old_buckets[i];
            while (current) {
                Node* next = current->next;
                insert(current->data);
                delete current;
                current = next;
            }
        }
    }
    
    void clear() {
        for (size_t i = 0; i < bucket_count_; ++i) {
            Node* current = buckets[i];
            while (current) {
                Node* next = current->next;
                delete current;
                current = next;
            }
            buckets[i] = nullptr;
        }
        size_ = 0;
    }
};
```

## 应用

### 集合操作实现

```cpp
class SetOperations {
public:
    // 并集
    template<typename T>
    static unordered_set<T> set_union(const unordered_set<T>& set1, 
                                      const unordered_set<T>& set2) {
        unordered_set<T> result = set1;
        result.insert(set2.begin(), set2.end());
        return result;
    }
    
    // 交集
    template<typename T>
    static unordered_set<T> set_intersection(const unordered_set<T>& set1, 
                                             const unordered_set<T>& set2) {
        unordered_set<T> result;
        for (const auto& item : set1) {
            if (set2.count(item)) {
                result.insert(item);
            }
        }
        return result;
    }
    
    // 差集
    template<typename T>
    static unordered_set<T> set_difference(const unordered_set<T>& set1, 
                                           const unordered_set<T>& set2) {
        unordered_set<T> result;
        for (const auto& item : set1) {
            if (!set2.count(item)) {
                result.insert(item);
            }
        }
        return result;
    }
    
    // 对称差集
    template<typename T>
    static unordered_set<T> set_symmetric_difference(const unordered_set<T>& set1, 
                                                     const unordered_set<T>& set2) {
        unordered_set<T> result;
        
        // set1 - set2
        for (const auto& item : set1) {
            if (!set2.count(item)) {
                result.insert(item);
            }
        }
        
        // set2 - set1
        for (const auto& item : set2) {
            if (!set1.count(item)) {
                result.insert(item);
            }
        }
        
        return result;
    }
    
    // 判断子集
    template<typename T>
    static bool is_subset(const unordered_set<T>& subset, 
                         const unordered_set<T>& superset) {
        for (const auto& item : subset) {
            if (!superset.count(item)) {
                return false;
            }
        }
        return true;
    }
};

void demonstrate_set_operations() {
    unordered_set<int> set1 = {1, 2, 3, 4, 5};
    unordered_set<int> set2 = {4, 5, 6, 7, 8};
    
    auto union_set = SetOperations::set_union(set1, set2);
    auto intersection_set = SetOperations::set_intersection(set1, set2);
    auto difference_set = SetOperations::set_difference(set1, set2);
    auto symmetric_diff = SetOperations::set_symmetric_difference(set1, set2);
    
    cout << "Set1: ";
    for (int val : set1) cout << val << " ";
    cout << endl;
    
    cout << "Set2: ";
    for (int val : set2) cout << val << " ";
    cout << endl;
    
    cout << "Union: ";
    for (int val : union_set) cout << val << " ";
    cout << endl;
    
    cout << "Intersection: ";
    for (int val : intersection_set) cout << val << " ";
    cout << endl;
    
    cout << "Difference (set1 - set2): ";
    for (int val : difference_set) cout << val << " ";
    cout << endl;
    
    cout << "Symmetric difference: ";
    for (int val : symmetric_diff) cout << val << " ";
    cout << endl;
}
```

### 去重和存在性检查
```cpp
class DuplicateChecker {
public:
    // 数组去重
    vector<int> remove_duplicates(const vector<int>& arr) {
        unordered_set<int> seen;
        vector<int> result;
        
        for (int num : arr) {
            if (seen.insert(num).second) { // 插入成功说明是新元素
                result.push_back(num);
            }
        }
        return result;
    }
    
    // 检查数组中是否有重复元素
    bool has_duplicates(const vector<int>& arr) {
        unordered_set<int> seen;
        for (int num : arr) {
            if (!seen.insert(num).second) {
                return true; // 插入失败说明已存在
            }
        }
        return false;
    }
    
    // 找出两个数组的公共元素
    vector<int> find_common_elements(const vector<int>& arr1, 
                                    const vector<int>& arr2) {
        unordered_set<int> set1(arr1.begin(), arr1.end());
        unordered_set<int> common;
        
        for (int num : arr2) {
            if (set1.count(num)) {
                common.insert(num);
            }
        }
        
        return vector<int>(common.begin(), common.end());
    }
};
```

### 缓存系统
```cpp
template<typename K, typename V>
class LRUCacheWithSet {
private:
    struct Node {
        K key;
        V value;
        Node* prev;
        Node* next;
        Node(const K& k, const V& v) : key(k), value(v), prev(nullptr), next(nullptr) {}
    };
    
    unordered_map<K, Node*> cache_map;
    unordered_set<K> keys_set; // 用于快速检查键是否存在
    Node* head;
    Node* tail;
    int capacity;
    
public:
    LRUCacheWithSet(int cap) : capacity(cap) {
        head = new Node(K{}, V{});
        tail = new Node(K{}, V{});
        head->next = tail;
        tail->prev = head;
    }
    
    V get(const K& key) {
        if (!keys_set.count(key)) {
            throw std::runtime_error("Key not found");
        }
        
        Node* node = cache_map[key];
        move_to_head(node);
        return node->value;
    }
    
    void put(const K& key, const V& value) {
        if (keys_set.count(key)) {
            Node* node = cache_map[key];
            node->value = value;
            move_to_head(node);
        } else {
            Node* new_node = new Node(key, value);
            
            if (cache_map.size() >= capacity) {
                Node* last = remove_tail();
                cache_map.erase(last->key);
                keys_set.erase(last->key);
                delete last;
            }
            
            cache_map[key] = new_node;
            keys_set.insert(key);
            add_to_head(new_node);
        }
    }
    
    bool contains(const K& key) const {
        return keys_set.count(key) > 0;
    }
    
private:
    void add_to_head(Node* node) {
        node->prev = head;
        node->next = head->next;
        head->next->prev = node;
        head->next = node;
    }
    
    void remove_node(Node* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }
    
    void move_to_head(Node* node) {
        remove_node(node);
        add_to_head(node);
    }
    
    Node* remove_tail() {
        Node* last = tail->prev;
        remove_node(last);
        return last;
    }
};
```

### 图算法应用
```cpp
class Graph {
private:
    unordered_map<int, unordered_set<int>> adj_list;
    
public:
    void add_edge(int u, int v) {
        adj_list[u].insert(v);
        adj_list[v].insert(u); // 无向图
    }
    
    void remove_edge(int u, int v) {
        adj_list[u].erase(v);
        adj_list[v].erase(u);
    }
    
    bool has_edge(int u, int v) const {
        auto it = adj_list.find(u);
        return it != adj_list.end() && it->second.count(v);
    }
    
    // DFS遍历
    void dfs(int start) {
        unordered_set<int> visited;
        dfs_helper(start, visited);
    }
    
    // 检查是否有环
    bool has_cycle() {
        unordered_set<int> visited;
        unordered_set<int> rec_stack;
        
        for (const auto& pair : adj_list) {
            if (!visited.count(pair.first)) {
                if (has_cycle_helper(pair.first, visited, rec_stack)) {
                    return true;
                }
            }
        }
        return false;
    }
    
private:
    void dfs_helper(int node, unordered_set<int>& visited) {
        visited.insert(node);
        cout << node << " ";
        
        for (int neighbor : adj_list[node]) {
            if (!visited.count(neighbor)) {
                dfs_helper(neighbor, visited);
            }
        }
    }
    
    bool has_cycle_helper(int node, unordered_set<int>& visited, 
                         unordered_set<int>& rec_stack) {
        visited.insert(node);
        rec_stack.insert(node);
        
        for (int neighbor : adj_list[node]) {
            if (!visited.count(neighbor)) {
                if (has_cycle_helper(neighbor, visited, rec_stack)) {
                    return true;
                }
            } else if (rec_stack.count(neighbor)) {
                return true;
            }
        }
        
        rec_stack.erase(node);
        return false;
    }
};
```

## 总结

**优势**

1. **高效查找**：平均 O(1) 时间复杂度
2. **动态大小**：自动扩容和收缩
3. **STL兼容**：与标准算法良好集成
4. **类型安全**：模板提供编译时类型检查

**劣势**

1. **无序性**：不保持元素顺序
2. **内存开销**：哈希表需要额外空间
3. **最坏情况**：所有元素冲突时性能退化为 O(n)
4. **哈希依赖**：性能很大程度上依赖哈希函数质量

**适用场景**

- 需要快速查找、插入、删除的场景
- 不关心元素顺序的应用
- 去重操作
- 集合运算
- 缓存系统
- 图算法中的访问标记

`std::unordered_set` 在需要高效集合操作的场景中是首选。


# unordered_map

`std::unordered_map` 是 C++11 引入的基于哈希表实现的关联容器，用于存储键值对（key-value pairs），其中键是唯一的。

## 基本特性

**核心特征**

- **键值对存储**：每个元素都是 `std::pair<const Key, Value>`
- **唯一键**：不允许重复的键
- **无序性**：元素没有特定的排列顺序
- **基于哈希**：使用哈希表实现，提供平均 O(1) 的操作时间
- **动态大小**：可以动态增长和收缩
- **键不可修改**：插入后不能直接修改键值

**底层实现**

- **哈希表**：通常使用链地址法处理冲突
- **桶（Bucket）**：哈希表的存储单元
- **负载因子**：元素数量与桶数量的比值
- **自动扩容**：当负载因子超过阈值时自动扩容

## 声明和初始化

```cpp
#include <unordered_map>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main() {
    // 1. 默认构造
    unordered_map<string, int> map1;
    
    // 2. 初始化列表构造
    unordered_map<string, int> map2 = {
        {"apple", 5},
        {"banana", 3},
        {"orange", 7}
    };
    
    // 3. 范围构造
    vector<pair<string, int>> vec = {{"red", 1}, {"green", 2}, {"blue", 3}};
    unordered_map<string, int> map3(vec.begin(), vec.end());
    
    // 4. 拷贝构造
    unordered_map<string, int> map4(map2);
    
    // 5. 移动构造
    unordered_map<string, int> map5(std::move(map4));
    
    return 0;
}
```

**自定义哈希和相等比较**

```cpp
// 自定义类型作为键
struct Person {
    string name;
    int age;
    
    Person(const string& n, int a) : name(n), age(a) {}
    
    bool operator==(const Person& other) const {
        return name == other.name && age == other.age;
    }
};

// 自定义哈希函数
struct PersonHash {
    size_t operator()(const Person& p) const {
        return hash<string>{}(p.name) ^ (hash<int>{}(p.age) << 1);
    }
};

// 使用自定义哈希
unordered_map<Person, string, PersonHash> person_map;
person_map[Person("Alice", 25)] = "Engineer";
person_map[Person("Bob", 30)] = "Manager";

// 或者使用 Lambda 表达式
auto person_hash = [](const Person& p) {
    return hash<string>{}(p.name) ^ (hash<int>{}(p.age) << 1);
};

auto person_equal = [](const Person& a, const Person& b) {
    return a.name == b.name && a.age == b.age;
};

unordered_map<Person, string, decltype(person_hash), decltype(person_equal)> 
    person_map2(0, person_hash, person_equal);
```

## 基本操作

**插入操作**

```cpp
void demonstrate_insert() {
    unordered_map<string, int> umap;
    
    // 1. operator[] - 插入或访问
    umap["apple"] = 5;
    umap["banana"] = 3;
    
    // 2. insert() - 返回 pair<iterator, bool>
    auto result1 = umap.insert({"orange", 7});
    cout << "Inserted: " << result1.second << endl; // true
    cout << "Key: " << result1.first->first << ", Value: " << result1.first->second << endl;
    
    auto result2 = umap.insert({"apple", 10}); // 键已存在
    cout << "Inserted: " << result2.second << endl; // false
    cout << "Existing value: " << result2.first->second << endl; // 5
    
    // 3. insert() - 使用 pair
    umap.insert(make_pair("grape", 4));
    
    // 4. insert() - 范围插入
    vector<pair<string, int>> fruits = {{"mango", 6}, {"kiwi", 2}};
    umap.insert(fruits.begin(), fruits.end());
    
    // 5. insert() - 初始化列表
    umap.insert({{"peach", 8}, {"plum", 9}});
    
    // 6. emplace() - 就地构造
    umap.emplace("cherry", 12);
    
    // 7. emplace_hint() - 带提示的就地构造
    auto hint = umap.find("apple");
    umap.emplace_hint(hint, "apricot", 11);
    
    // 8. insert_or_assign() - C++17新增
    #if __cplusplus >= 201703L
    auto result3 = umap.insert_or_assign("apple", 15); // 更新现有值
    cout << "Updated: " << !result3.second << endl; // true (更新)
    #endif
    
    // 9. try_emplace() - C++17新增，只在键不存在时插入
    #if __cplusplus >= 201703L
    auto result4 = umap.try_emplace("apple", 20); // 不会更新
    cout << "Try emplace success: " << result4.second << endl; // false
    #endif
    
    // 打印结果
    cout << "Map contents:" << endl;
    for (const auto& pair : umap) {
        cout << pair.first << ": " << pair.second << endl;
    }
}
```

**访问操作**

```cpp
void demonstrate_access() {
    unordered_map<string, int> umap = {
        {"apple", 5}, {"banana", 3}, {"orange", 7}
    };
    
    // 1. operator[] - 如果键不存在会创建
    cout << "Apple count: " << umap["apple"] << endl;
    cout << "Grape count: " << umap["grape"] << endl; // 创建新元素，值为0
    
    // 2. at() - 如果键不存在会抛出异常
    try {
        cout << "Banana count: " << umap.at("banana") << endl;
        cout << "Mango count: " << umap.at("mango") << endl; // 抛出异常
    } catch (const out_of_range& e) {
        cout << "Key not found: " << e.what() << endl;
    }
    
    // 3. find() - 返回迭代器
    auto it = umap.find("orange");
    if (it != umap.end()) {
        cout << "Found: " << it->first << " = " << it->second << endl;
        // 可以修改值
        it->second = 10;
    }
    
    // 4. count() - 返回元素个数（0或1）
    if (umap.count("apple")) {
        cout << "Apple exists" << endl;
    }
    
    // 5. contains() - C++20新增
    #if __cplusplus >= 202002L
    if (umap.contains("banana")) {
        cout << "Banana exists" << endl;
    }
    #endif
    
    // 6. equal_range() - 返回相等元素的范围
    auto range = umap.equal_range("apple");
    cout << "Equal range for apple: ";
    for (auto it = range.first; it != range.second; ++it) {
        cout << it->first << "=" << it->second << " ";
    }
    cout << endl;
}
```

**删除操作**

```cpp
void demonstrate_erase() {
    unordered_map<string, int> umap = {
        {"apple", 5}, {"banana", 3}, {"orange", 7}, 
        {"grape", 4}, {"mango", 6}, {"kiwi", 2}
    };
    
    cout << "Original size: " << umap.size() << endl;
    
    // 1. erase(key) - 按键删除
    size_t erased = umap.erase("banana");
    cout << "Erased " << erased << " elements" << endl;
    
    // 2. erase(iterator) - 按迭代器删除
    auto it = umap.find("orange");
    if (it != umap.end()) {
        umap.erase(it);
    }
    
    // 3. erase(range) - 范围删除
    auto start = umap.find("grape");
    auto end = umap.find("mango");
    if (start != umap.end() && end != umap.end()) {
        ++end; // 包含mango
        umap.erase(start, end);
    }
    
    // 4. clear() - 清空所有元素
    // umap.clear();
    
    cout << "Final size: " << umap.size() << endl;
    cout << "Remaining elements:" << endl;
    for (const auto& pair : umap) {
        cout << pair.first << ": " << pair.second << endl;
    }
}
```

## 迭代器和遍历

```cpp
void demonstrate_iterators() {
    unordered_map<string, int> umap = {
        {"red", 1}, {"green", 2}, {"blue", 3}, {"yellow", 4}
    };
    
    // 1. 正向迭代器
    cout << "Forward iteration:" << endl;
    for (auto it = umap.begin(); it != umap.end(); ++it) {
        cout << it->first << ": " << it->second << endl;
        // 可以修改值，但不能修改键
        // it->first = "new_key"; // 错误！键是const的
        it->second *= 2; // 正确
    }
    
    // 2. 常量迭代器
    cout << "Const iteration:" << endl;
    for (auto it = umap.cbegin(); it != umap.cend(); ++it) {
        cout << it->first << ": " << it->second << endl;
        // it->second = 10; // 错误！常量迭代器不能修改
    }
    
    // 3. 范围for循环
    cout << "Range-based for:" << endl;
    for (const auto& pair : umap) {
        cout << pair.first << ": " << pair.second << endl;
    }
    
    // 4. 结构化绑定 (C++17)
    #if __cplusplus >= 201703L
    cout << "Structured binding:" << endl;
    for (const auto& [key, value] : umap) {
        cout << key << ": " << value << endl;
    }
    #endif
    
    // 5. 桶迭代器
    cout << "Bucket iteration:" << endl;
    for (size_t i = 0; i < umap.bucket_count(); ++i) {
        cout << "Bucket " << i << ": ";
        for (auto it = umap.begin(i); it != umap.end(i); ++it) {
            cout << it->first << "=" << it->second << " ";
        }
        cout << endl;
    }
}
```

## 容量和桶操作

**大小和容量**

```cpp
void demonstrate_capacity() {
    unordered_map<string, int> umap;
    
    cout << "Empty: " << umap.empty() << endl;
    cout << "Size: " << umap.size() << endl;
    cout << "Max size: " << umap.max_size() << endl;
    
    // 插入一些元素
    for (int i = 1; i <= 10; ++i) {
        umap["key" + to_string(i)] = i;
    }
    
    cout << "After insertion:" << endl;
    cout << "Size: " << umap.size() << endl;
    cout << "Bucket count: " << umap.bucket_count() << endl;
    cout << "Load factor: " << umap.load_factor() << endl;
    cout << "Max load factor: " << umap.max_load_factor() << endl;
}
```

**桶操作**

```cpp
void demonstrate_buckets() {
    unordered_map<string, int> umap = {
        {"apple", 5}, {"banana", 3}, {"cherry", 7}, 
        {"date", 4}, {"elderberry", 6}
    };
    
    cout << "Bucket information:" << endl;
    cout << "Bucket count: " << umap.bucket_count() << endl;
    cout << "Max bucket count: " << umap.max_bucket_count() << endl;
    
    // 查看每个元素在哪个桶中
    for (const auto& pair : umap) {
        size_t bucket = umap.bucket(pair.first);
        cout << pair.first << " is in bucket " << bucket << endl;
    }
    
    // 查看每个桶的大小
    cout << "\nBucket sizes:" << endl;
    for (size_t i = 0; i < umap.bucket_count(); ++i) {
        cout << "Bucket " << i << " size: " << umap.bucket_size(i) << endl;
    }
}
```

**哈希策略控制**

```cpp
void demonstrate_hash_policy() {
    unordered_map<string, int> umap;
    
    cout << "Initial bucket count: " << umap.bucket_count() << endl;
    
    // 1. reserve() - 预留空间
    umap.reserve(100);
    cout << "After reserve(100): " << umap.bucket_count() << endl;
    
    // 2. rehash() - 重新哈希
    umap.rehash(50);
    cout << "After rehash(50): " << umap.bucket_count() << endl;
    
    // 3. 设置最大负载因子
    umap.max_load_factor(0.5);
    cout << "Max load factor set to: " << umap.max_load_factor() << endl;
    
    // 插入元素观察扩容
    for (int i = 1; i <= 30; ++i) {
        umap["key" + to_string(i)] = i;
        if (i % 10 == 0) {
            cout << "After inserting " << i << " elements:" << endl;
            cout << "  Size: " << umap.size() << endl;
            cout << "  Bucket count: " << umap.bucket_count() << endl;
            cout << "  Load factor: " << umap.load_factor() << endl;
        }
    }
}
```

## 算法

```cpp
#include <algorithm>
#include <numeric>

void demonstrate_algorithms() {
    unordered_map<string, int> umap = {
        {"apple", 5}, {"banana", 3}, {"orange", 7}, 
        {"grape", 4}, {"mango", 6}
    };
    
    // 1. std::find_if - 查找满足条件的元素
    auto it = std::find_if(umap.begin(), umap.end(), 
        [](const pair<string, int>& p) {
            return p.second > 5;
        });
    if (it != umap.end()) {
        cout << "Found fruit with count > 5: " << it->first << endl;
    }
    
    // 2. std::count_if - 计算满足条件的元素数量
    int count = std::count_if(umap.begin(), umap.end(),
        [](const pair<string, int>& p) {
            return p.second % 2 == 0;
        });
    cout << "Even count fruits: " << count << endl;
    
    // 3. std::for_each - 对每个元素执行操作
    cout << "All fruits:" << endl;
    std::for_each(umap.begin(), umap.end(),
        [](const pair<string, int>& p) {
            cout << p.first << ": " << p.second << endl;
        });
    
    // 4. std::transform - 转换元素
    vector<string> fruit_names;
    std::transform(umap.begin(), umap.end(), back_inserter(fruit_names),
        [](const pair<string, int>& p) {
            return p.first;
        });
    
    cout << "Fruit names: ";
    for (const string& name : fruit_names) {
        cout << name << " ";
    }
    cout << endl;
    
    // 5. std::accumulate - 累积操作
    int total = std::accumulate(umap.begin(), umap.end(), 0,
        [](int sum, const pair<string, int>& p) {
            return sum + p.second;
        });
    cout << "Total count: " << total << endl;
    
    // 6. std::any_of, std::all_of, std::none_of
    bool has_large = std::any_of(umap.begin(), umap.end(),
        [](const pair<string, int>& p) {
            return p.second > 10;
        });
    cout << "Has count > 10: " << has_large << endl;
    
    bool all_positive = std::all_of(umap.begin(), umap.end(),
        [](const pair<string, int>& p) {
            return p.second > 0;
        });
    cout << "All positive: " << all_positive << endl;
}
```

## 内部实现原理

```cpp
// 简化的 unordered_map 实现示例
template<typename K, typename V, typename Hash = std::hash<K>, typename Equal = std::equal_to<K>>
class SimpleUnorderedMap {
private:
    struct Node {
        std::pair<const K, V> data;
        Node* next;
        
        template<typename... Args>
        Node(Args&&... args) : data(std::forward<Args>(args)...), next(nullptr) {}
    };
    
    std::vector<Node*> buckets;
    size_t bucket_count_;
    size_t size_;
    double max_load_factor_;
    Hash hasher;
    Equal equal;
    
public:
    using key_type = K;
    using mapped_type = V;
    using value_type = std::pair<const K, V>;
    
    SimpleUnorderedMap(size_t initial_bucket_count = 16) 
        : bucket_count_(initial_bucket_count), size_(0), max_load_factor_(1.0) {
        buckets.resize(bucket_count_, nullptr);
    }
    
    ~SimpleUnorderedMap() {
        clear();
    }
    
    V& operator[](const K& key) {
        size_t bucket_index = hasher(key) % bucket_count_;
        Node* current = buckets[bucket_index];
        
        // 查找现有键
        while (current) {
            if (equal(current->data.first, key)) {
                return current->data.second;
            }
            current = current->next;
        }
        
        // 键不存在，插入新节点
        if (load_factor() > max_load_factor_) {
            rehash(bucket_count_ * 2);
            bucket_index = hasher(key) % bucket_count_;
        }
        
        Node* new_node = new Node(std::make_pair(key, V{}));
        new_node->next = buckets[bucket_index];
        buckets[bucket_index] = new_node;
        size_++;
        
        return new_node->data.second;
    }
    
    std::pair<Node*, bool> insert(const value_type& value) {
        if (load_factor() > max_load_factor_) {
            rehash(bucket_count_ * 2);
        }
        
        size_t bucket_index = hasher(value.first) % bucket_count_;
        Node* current = buckets[bucket_index];
        
        // 检查是否已存在
        while (current) {
            if (equal(current->data.first, value.first)) {
                return {current, false}; // 已存在
            }
            current = current->next;
        }
        
        // 插入新节点
        Node* new_node = new Node(value);
        new_node->next = buckets[bucket_index];
        buckets[bucket_index] = new_node;
        size_++;
        return {new_node, true};
    }
    
    Node* find(const K& key) {
        size_t bucket_index = hasher(key) % bucket_count_;
        Node* current = buckets[bucket_index];
        
        while (current) {
            if (equal(current->data.first, key)) {
                return current;
            }
            current = current->next;
        }
        return nullptr;
    }
    
    bool erase(const K& key) {
        size_t bucket_index = hasher(key) % bucket_count_;
        Node* current = buckets[bucket_index];
        Node* prev = nullptr;
        
        while (current) {
            if (equal(current->data.first, key)) {
                if (prev) {
                    prev->next = current->next;
                } else {
                    buckets[bucket_index] = current->next;
                }
                delete current;
                size_--;
                return true;
            }
            prev = current;
            current = current->next;
        }
        return false;
    }
    
    size_t size() const { return size_; }
    bool empty() const { return size_ == 0; }
    double load_factor() const { return (double)size_ / bucket_count_; }
    
private:
    void rehash(size_t new_bucket_count) {
        std::vector<Node*> old_buckets = std::move(buckets);
        size_t old_bucket_count = bucket_count_;
        
        bucket_count_ = new_bucket_count;
        buckets.clear();
        buckets.resize(bucket_count_, nullptr);
        size_ = 0;
        
        // 重新插入所有元素
        for (size_t i = 0; i < old_bucket_count; ++i) {
            Node* current = old_buckets[i];
            while (current) {
                Node* next = current->next;
                insert(current->data);
                delete current;
                current = next;
            }
        }
    }
    
    void clear() {
        for (size_t i = 0; i < bucket_count_; ++i) {
            Node* current = buckets[i];
            while (current) {
                Node* next = current->next;
                delete current;
                current = next;
            }
            buckets[i] = nullptr;
        }
        size_ = 0;
    }
};
```

## 应用

### 缓存系统
```cpp
template<typename K, typename V>
class SimpleCache {
private:
    unordered_map<K, V> cache;
    size_t max_size;
    
public:
    SimpleCache(size_t max_sz) : max_size(max_sz) {}
    
    bool get(const K& key, V& value) {
        auto it = cache.find(key);
        if (it != cache.end()) {
            value = it->second;
            return true;
        }
        return false;
    }
    
    void put(const K& key, const V& value) {
        if (cache.size() >= max_size && cache.find(key) == cache.end()) {
            // 简单的随机淘汰策略
            auto it = cache.begin();
            cache.erase(it);
        }
        cache[key] = value;
    }
    
    void remove(const K& key) {
        cache.erase(key);
    }
    
    size_t size() const {
        return cache.size();
    }
    
    void clear() {
        cache.clear();
    }
};

void demonstrate_cache() {
    SimpleCache<string, string> cache(3);
    
    cache.put("user1", "Alice");
    cache.put("user2", "Bob");
    cache.put("user3", "Charlie");
    
    string value;
    if (cache.get("user1", value)) {
        cout << "Found: " << value << endl;
    }
    
    cache.put("user4", "David"); // 会淘汰一个元素
    cout << "Cache size: " << cache.size() << endl;
}
```

### 词频统计
```cpp
class WordCounter {
private:
    unordered_map<string, int> word_count;
    
public:
    void add_text(const string& text) {
        istringstream iss(text);
        string word;
        while (iss >> word) {
            // 转换为小写
            transform(word.begin(), word.end(), word.begin(), ::tolower);
            
            // 移除标点符号
            word.erase(remove_if(word.begin(), word.end(), ::ispunct), word.end());
            
            if (!word.empty()) {
                word_count[word]++;
            }
        }
    }
    
    int get_count(const string& word) const {
        auto it = word_count.find(word);
        return (it != word_count.end()) ? it->second : 0;
    }
    
    vector<pair<string, int>> get_top_words(int n) const {
        vector<pair<string, int>> words(word_count.begin(), word_count.end());
        
        // 按频率排序
        sort(words.begin(), words.end(), 
             [](const pair<string, int>& a, const pair<string, int>& b) {
                 return a.second > b.second;
             });
        
        if (words.size() > n) {
            words.resize(n);
        }
        
        return words;
    }
    
    void print_statistics() const {
        cout << "Total unique words: " << word_count.size() << endl;
        
        int total_words = 0;
        for (const auto& pair : word_count) {
            total_words += pair.second;
        }
        cout << "Total words: " << total_words << endl;
        
        auto top_words = get_top_words(10);
        cout << "Top 10 words:" << endl;
        for (const auto& pair : top_words) {
            cout << pair.first << ": " << pair.second << endl;
        }
    }
};

void demonstrate_word_counter() {
    WordCounter counter;
    
    counter.add_text("Hello world! This is a test. Hello again, world!");
    counter.add_text("Testing the word counter. This is another test.");
    
    counter.print_statistics();
    
    cout << "Count of 'hello': " << counter.get_count("hello") << endl;
    cout << "Count of 'test': " << counter.get_count("test") << endl;
}
```

### 配置管理系统
```cpp
class ConfigManager {
private:
    unordered_map<string, string> config;
    
public:
    void load_from_file(const string& filename) {
        ifstream file(filename);
        string line;
        
        while (getline(file, line)) {
            // 跳过注释和空行
            if (line.empty() || line[0] == '#') continue;
            
            size_t pos = line.find('=');
            if (pos != string::npos) {
                string key = line.substr(0, pos);
                string value = line.substr(pos + 1);
                
                // 去除空格
                key.erase(remove_if(key.begin(), key.end(), ::isspace), key.end());
                value.erase(remove_if(value.begin(), value.end(), ::isspace), value.end());
                
                config[key] = value;
            }
        }
    }
    
    string get_string(const string& key, const string& default_value = "") const {
        auto it = config.find(key);
        return (it != config.end()) ? it->second : default_value;
    }
    
    int get_int(const string& key, int default_value = 0) const {
        auto it = config.find(key);
        if (it != config.end()) {
            try {
                return stoi(it->second);
            } catch (const exception&) {
                return default_value;
            }
        }
        return default_value;
    }
    
    bool get_bool(const string& key, bool default_value = false) const {
        auto it = config.find(key);
        if (it != config.end()) {
            string value = it->second;
            transform(value.begin(), value.end(), value.begin(), ::tolower);
            return value == "true" || value == "1" || value == "yes";
        }
        return default_value;
    }
    
    void set(const string& key, const string& value) {
        config[key] = value;
    }
    
    void set(const string& key, int value) {
        config[key] = to_string(value);
    }
    
    void set(const string& key, bool value) {
        config[key] = value ? "true" : "false";
    }
    
    bool has_key(const string& key) const {
        return config.find(key) != config.end();
    }
    
    void print_all() const {
        cout << "Configuration:" << endl;
        for (const auto& pair : config) {
            cout << pair.first << " = " << pair.second << endl;
        }
    }
};

void demonstrate_config_manager() {
    ConfigManager config;
    
    // 手动设置一些配置
    config.set("server_port", 8080);
    config.set("debug_mode", true);
    config.set("server_name", "MyServer");
    config.set("max_connections", 100);
    
    // 读取配置
    cout << "Server port: " << config.get_int("server_port") << endl;
    cout << "Debug mode: " << config.get_bool("debug_mode") << endl;
    cout << "Server name: " << config.get_string("server_name") << endl;
    cout << "Max connections: " << config.get_int("max_connections") << endl;
    
    // 检查不存在的键
    cout << "Unknown key: " << config.get_string("unknown_key", "default") << endl;
    
    config.print_all();
}
```

### 图的邻接表表示
```cpp
class Graph {
private:
    unordered_map<int, unordered_map<int, int>> adj_list; // 节点 -> {邻居 -> 权重}
    bool is_directed;
    
public:
    Graph(bool directed = false) : is_directed(directed) {}
    
    void add_edge(int from, int to, int weight = 1) {
        adj_list[from][to] = weight;
        if (!is_directed) {
            adj_list[to][from] = weight;
        }
    }
    
    void remove_edge(int from, int to) {
        adj_list[from].erase(to);
        if (!is_directed) {
            adj_list[to].erase(from);
        }
    }
    
    bool has_edge(int from, int to) const {
        auto it = adj_list.find(from);
        if (it != adj_list.end()) {
            return it->second.find(to) != it->second.end();
        }
        return false;
    }
    
    int get_weight(int from, int to) const {
        auto it = adj_list.find(from);
        if (it != adj_list.end()) {
            auto edge_it = it->second.find(to);
            if (edge_it != it->second.end()) {
                return edge_it->second;
            }
        }
        return -1; // 边不存在
    }
    
    vector<int> get_neighbors(int node) const {
        vector<int> neighbors;
        auto it = adj_list.find(node);
        if (it != adj_list.end()) {
            for (const auto& pair : it->second) {
                neighbors.push_back(pair.first);
            }
        }
        return neighbors;
    }
    
    void print_graph() const {
        for (const auto& node : adj_list) {
            cout << "Node " << node.first << ": ";
            for (const auto& edge : node.second) {
                cout << "(" << edge.first << ", " << edge.second << ") ";
            }
            cout << endl;
        }
    }
    
    // BFS遍历
    void bfs(int start) const {
        unordered_map<int, bool> visited;
        queue<int> q;
        
        q.push(start);
        visited[start] = true;
        
        cout << "BFS from " << start << ": ";
        while (!q.empty()) {
            int current = q.front();
            q.pop();
            cout << current << " ";
            
            auto it = adj_list.find(current);
            if (it != adj_list.end()) {
                for (const auto& edge : it->second) {
                    int neighbor = edge.first;
                    if (!visited[neighbor]) {
                        visited[neighbor] = true;
                        q.push(neighbor);
                    }
                }
            }
        }
        cout << endl;
    }
};

void demonstrate_graph() {
    Graph g(false); // 无向图
    
    g.add_edge(1, 2, 5);
    g.add_edge(1, 3, 3);
    g.add_edge(2, 4, 7);
    g.add_edge(3, 4, 2);
    g.add_edge(4, 5, 1);
    
    g.print_graph();
    
    cout << "Edge (1,2) exists: " << g.has_edge(1, 2) << endl;
    cout << "Weight of edge (1,2): " << g.get_weight(1, 2) << endl;
    
    vector<int> neighbors = g.get_neighbors(1);
    cout << "Neighbors of node 1: ";
    for (int neighbor : neighbors) {
        cout << neighbor << " ";
    }
    cout << endl;
    
    g.bfs(1);
}
```


# 容器的选择

## 容器概览

**序列容器（Sequence Containers）**

- **vector** - 动态数组
- **deque** - 双端队列
- **list** - 双向链表
- **forward_list** - 单向链表
- **array** - 固定大小数组

**关联容器（Associative Containers）**

- **set** - 有序集合
- **multiset** - 有序多重集合
- **map** - 有序键值对
- **multimap** - 有序多重键值对

**无序关联容器（Unordered Associative Containers）**

- **unordered_set** - 哈希集合
- **unordered_multiset** - 哈希多重集合
- **unordered_map** - 哈希键值对
- **unordered_multimap** - 哈希多重键值对

**容器适配器（Container Adapters）**

- **stack** - 栈
- **queue** - 队列
- **priority_queue** - 优先队列

## 选择指南

### 序列容器选择

**vector - 首选的序列容器**

```cpp
// 适用场景
vector<int> vec;

// ✅ 优势
// - 随机访问 O(1)
// - 末尾插入/删除 O(1)
// - 内存连续，缓存友好
// - 支持预分配空间

// ❌ 劣势
// - 中间插入/删除 O(n)
// - 扩容时可能重新分配内存
```

**选择vector的场景：**
- 需要随机访问元素
- 主要在末尾进行插入/删除
- 需要与C风格数组兼容
- 对内存局部性有要求

**deque - 双端操作优化**

```cpp
deque<int> dq;

// ✅ 优势
// - 两端插入/删除 O(1)
// - 随机访问 O(1)
// - 不会因扩容而使迭代器失效

// ❌ 劣势
// - 内存不连续
// - 比vector有更多开销

// 适用场景
dq.push_front(1);   // 头部插入
dq.push_back(2);    // 尾部插入
dq.pop_front();     // 头部删除
```

**选择deque的场景：**
- 需要在两端频繁插入/删除
- 需要随机访问
- 实现队列或双端队列

**list - 任意位置高效插入**

```cpp
list<int> lst;

// ✅ 优势
// - 任意位置插入/删除 O(1)
// - 迭代器稳定性好
// - 支持splice操作

// ❌ 劣势
// - 无随机访问
// - 内存开销大
// - 缓存不友好

// 适用场景
auto it = lst.begin();
advance(it, 5);
lst.insert(it, 42);  // 中间插入
lst.splice(it, other_list);  // 链表拼接
```

**选择list的场景：**
- 频繁在中间位置插入/删除
- 需要稳定的迭代器
- 需要splice等链表特有操作

### 关联容器选择

**map vs unordered_map**

```cpp
// 性能对比
class ContainerComparison {
public:
    void compare_map_performance() {
        map<string, int> ordered_map;
        unordered_map<string, int> hash_map;
        
        // map: O(log n) 操作，有序
        ordered_map["key"] = 42;
        
        // unordered_map: O(1) 平均操作，无序
        hash_map["key"] = 42;
        
        // 遍历有序
        for (const auto& pair : ordered_map) {
            // 按键排序输出
        }
        
        // 遍历无序但更快
        for (const auto& pair : hash_map) {
            // 无序输出但查找更快
        }
    }
};
```

**选择map的场景：**
- 需要有序遍历
- 需要范围查询
- 键的比较操作比哈希操作更高效

**选择unordered_map的场景：**
- 主要进行查找操作
- 不需要有序性
- 有好的哈希函数

### 容器适配器选择

```cpp
// 根据数据结构需求选择
class AdapterSelection {
public:
    void demonstrate_adapters() {
        // LIFO (后进先出) - 使用 stack
        stack<int> stk;
        stk.push(1);
        int top = stk.top();
        stk.pop();
        
        // FIFO (先进先出) - 使用 queue
        queue<int> q;
        q.push(1);
        int front = q.front();
        q.pop();
        
        // 优先级队列 - 使用 priority_queue
        priority_queue<int> pq;  // 默认大顶堆
        pq.push(3);
        pq.push(1);
        pq.push(2);
        int max_val = pq.top();  // 3
    }
};
```

## 性能特性对比表

| 容器          | 随机访问 | 插入(头) | 插入(尾) | 插入(中) | 删除(头) | 删除(尾) | 删除(中) | 查找     |
| ------------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- |
| vector        | O(1)     | O(n)     | O(1)*    | O(n)     | O(n)     | O(1)     | O(n)     | O(n)     |
| deque         | O(1)     | O(1)     | O(1)     | O(n)     | O(1)     | O(1)     | O(n)     | O(n)     |
| list          | O(n)     | O(1)     | O(1)     | O(1)     | O(1)     | O(1)     | O(1)     | O(n)     |
| set           | -        | -        | -        | O(log n) | -        | -        | O(log n) | O(log n) |
| unordered_set | -        | -        | -        | O(1)*    | -        | -        | O(1)*    | O(1)*    |
| map           | -        | -        | -        | O(log n) | -        | -        | O(log n) | O(log n) |
| unordered_map | -        | -        | -        | O(1)*    | -        | -        | O(1)*    | O(1)*    |

*摊销时间复杂度

---

| 主要操作 | 推荐容器             | 原因                   |
| -------- | -------------------- | ---------------------- |
| 随机访问 | vector, deque, array | O(1)访问时间           |
| 末尾插入 | vector               | 摊销O(1)，内存连续     |
| 头部插入 | deque, list          | O(1)插入时间           |
| 中间插入 | list                 | O(1)插入，不需移动元素 |
| 查找元素 | set, unordered_set   | O(log n)或O(1)查找     |
| 有序遍历 | set, map             | 自动维护顺序           |
| 键值查找 | map, unordered_map   | 高效的键值对操作       |
