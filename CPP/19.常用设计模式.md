# 设计模式概览

**设计模式是解决特定问题的一系列套路，有一定的普遍性**;是一套被反复使用、多数人知晓的、代码设计经验的总结。它可以提高代码的可重用性、代码的可读性和代码的可靠性以及可扩展性。

常用的设计模式有23种，5种创建型模式 (Creational Pattern)（下表中的简单工厂模式一般不算在内），7种结构型模式 (Structural Pattern)，11种行为型模式 (Behavioral Pattern)

## 创建型模式

| 模式名称                              | 学习难度 | 使用频率 |
| ------------------------------------- | -------- | -------- |
| 单例模式 Singleton Pattern            | ⭐☆☆☆☆    | ⭐⭐⭐⭐☆    |
| 简单工厂模式 Simple Factory Pattern   | ⭐⭐☆☆☆    | ⭐⭐⭐☆☆    |
| 工厂方法模式 Factory Method Pattern   | ⭐⭐☆☆☆    | ⭐⭐⭐⭐⭐    |
| 抽象工厂模式 Abstract Factory Pattern | ⭐⭐⭐⭐☆    | ⭐⭐⭐⭐⭐    |
| 原型模式 Prototype Pattern            | ⭐⭐⭐☆☆    | ⭐⭐⭐☆☆    |
| 建造者模式 Builder Pattern            | ⭐⭐⭐⭐☆    | ⭐⭐☆☆☆    |

## 结构型模式

| 模式名称                   | 学习难度 | 使用频率 |
| -------------------------- | -------- | -------- |
| 适配器模式 Adapter Pattern | ⭐⭐☆☆☆    | ⭐⭐⭐⭐☆    |
| 桥接模式 Bridge Pattern    | ⭐⭐⭐☆☆    | ⭐⭐⭐☆☆    |
| 组合模式 Composite Pattern | ⭐⭐⭐☆☆    | ⭐⭐⭐⭐☆    |
| 装饰模式 Decorator Pattern | ⭐⭐⭐☆☆    | ⭐⭐⭐☆☆    |
| 外观模式 Facade Pattern    | ⭐☆☆☆☆    | ⭐⭐⭐⭐⭐    |
| 享元模式 Flyweight Pattern | ⭐⭐⭐⭐☆    | ⭐☆☆☆☆    |
| 代理模式 Proxy Pattern     | ⭐⭐⭐☆☆    | ⭐⭐⭐⭐☆    |

## 行为型模式

| 模式名称                                   | 学习难度 | 使用频率 |
| ------------------------------------------ | -------- | -------- |
| 职责链模式 Chain of Responsibility Pattern | ⭐⭐⭐☆☆    | ⭐⭐☆☆☆    |
| 命令模式 Command Pattern                   | ⭐⭐⭐☆☆    | ⭐⭐⭐⭐☆    |
| 解释器模式 Interpreter Pattern             | ⭐⭐⭐⭐⭐    | ⭐☆☆☆☆    |
| 迭代器模式 Iterator Pattern                | ⭐⭐⭐☆☆    | ⭐⭐⭐⭐⭐    |
| 中介者模式 Mediator Pattern                | ⭐⭐⭐☆☆    | ⭐⭐☆☆☆    |
| 备忘录模式 Memento Pattern                 | ⭐⭐☆☆☆    | ⭐⭐☆☆☆    |
| 观察者模式 Observer Pattern                | ⭐⭐⭐☆☆    | ⭐⭐⭐⭐⭐    |
| 状态模式 State Pattern                     | ⭐⭐⭐☆☆    | ⭐⭐⭐☆☆    |
| 策略模式 Strategy Pattern                  | ⭐☆☆☆☆    | ⭐⭐⭐⭐☆    |
| 模板方法模式 Template Method Pattern       | ⭐⭐☆☆☆    | ⭐⭐⭐☆☆    |
| 访问者模式 Visitor Pattern                 | ⭐⭐⭐⭐☆    | ⭐☆☆☆☆    |

# 简单工厂模式

## 定义

简单工厂模式是创建型设计模式的一种，它提供了一个创建对象的接口，但不暴露对象的创建逻辑。客户端通过一个公共的接口来创建所需的对象，而不需要知道具体的创建过程。

**核心思想**

- **封装对象创建过程**：将对象的创建逻辑集中在一个工厂类中
- **降低耦合度**：客户端不直接依赖具体的产品类
- **统一创建接口**：通过工厂方法统一创建不同类型的对象
- **简化客户端代码**：客户端只需要知道产品的标识，不需要了解创建细节

**结构组成**

1. **抽象产品 (Abstract Product)**：定义产品的公共接口
2. **具体产品 (Concrete Product)**：实现抽象产品接口的具体类
3. **简单工厂 (Simple Factory)**：负责创建具体产品对象的工厂类
4. **客户端 (Client)**：使用工厂创建产品对象

## 实现

### 形状工厂

```cpp
#include <iostream>
#include <memory>
#include <string>

// 抽象产品：形状接口
class Shape {
public:
    virtual void draw() = 0;
    virtual ~Shape() = default;
};

// 具体产品：圆形
class Circle : public Shape {
public:
    void draw() override {
        std::cout << "绘制圆形" << std::endl;
    }
};

// 具体产品：矩形
class Rectangle : public Shape {
public:
    void draw() override {
        std::cout << "绘制矩形" << std::endl;
    }
};

// 具体产品：三角形
class Triangle : public Shape {
public:
    void draw() override {
        std::cout << "绘制三角形" << std::endl;
    }
};

// 简单工厂类
class ShapeFactory {
public:
    static std::unique_ptr<Shape> createShape(const std::string& shapeType) {
        if (shapeType == "Circle") {
            return std::make_unique<Circle>();
        } else if (shapeType == "Rectangle") {
            return std::make_unique<Rectangle>();
        } else if (shapeType == "Triangle") {
            return std::make_unique<Triangle>();
        } else {
            return nullptr;
        }
    }
};

// 客户端使用
int main() {
    // 创建不同类型的形状
    auto circle = ShapeFactory::createShape("Circle");
    auto rectangle = ShapeFactory::createShape("Rectangle");
    auto triangle = ShapeFactory::createShape("Triangle");
    
    // 使用创建的对象
    if (circle) circle->draw();
    if (rectangle) rectangle->draw();
    if (triangle) triangle->draw();
    
    return 0;
}
```

![形状工厂](../img/cpp_img/形状工厂.png)

### 数据库连接工厂

```cpp
class DatabaseConnection {
public:
    virtual void connect() = 0;
    virtual ~DatabaseConnection() = default;
};

class MySQLConnection : public DatabaseConnection {
public:
    void connect() override {
        std::cout << "连接到 MySQL 数据库" << std::endl;
    }
};

class PostgreSQLConnection : public DatabaseConnection {
public:
    void connect() override {
        std::cout << "连接到 PostgreSQL 数据库" << std::endl;
    }
};

class DatabaseFactory {
public:
    static std::unique_ptr<DatabaseConnection> createConnection(const std::string& dbType) {
        if (dbType == "MySQL") {
            return std::make_unique<MySQLConnection>();
        } else if (dbType == "PostgreSQL") {
            return std::make_unique<PostgreSQLConnection>();
        }
        return nullptr;
    }
};
```

![简单工厂_数据库连接工厂](../img/cpp_img/简单工厂_数据库连接工厂.png)

### 日志记录器工厂

```cpp
class Logger {
public:
    virtual void log(const std::string& message) = 0;
    virtual ~Logger() = default;
};

class FileLogger : public Logger {
public:
    void log(const std::string& message) override {
        std::cout << "[文件日志] " << message << std::endl;
    }
};

class ConsoleLogger : public Logger {
public:
    void log(const std::string& message) override {
        std::cout << "[控制台日志] " << message << std::endl;
    }
};

class LoggerFactory {
public:
    static std::unique_ptr<Logger> createLogger(const std::string& loggerType) {
        if (loggerType == "file") {
            return std::make_unique<FileLogger>();
        } else if (loggerType == "console") {
            return std::make_unique<ConsoleLogger>();
        }
        return nullptr;
    }
};
```

![简单工厂_日志记录器工厂](../img/cpp_img/简单工厂_日志记录器工厂.png)

## 总结

### 优缺点

**优点：**

1、工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离

2、客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量

3、通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。

**总结：可以根据产品的名字生产出对应的产品**

**缺点：**

1、由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响；

2、使用简单工厂模式势必会增加系统中类的个数（引入新的工程类），增加了系统的复杂度和理解难度；(比如，如果想要创建梯形、椭圆形之类的图形，还需要改动Factory的代码)

3、系统拓展困难，一旦添加了新的产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的拓展和维护

4、简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构

**总结：违反了单一职责原则、违反了开放闭合原则、违反了依赖倒置原则**

### 适用场景

1. **产品类型相对固定**：当需要创建的对象类型不会频繁变化时
2. **客户端不关心创建过程**：只需要获得产品对象，不关心如何创建
3. **创建逻辑相对简单**：不涉及复杂的创建过程
4. **需要统一管理对象创建**：希望将创建逻辑集中管理

简单工厂模式是最基础的工厂模式，它通过一个工厂类来创建不同类型的产品对象。虽然它违反了开闭原则，但在产品类型相对固定的场景下，简单工厂模式能够有效地封装对象创建逻辑，降低客户端与具体产品类之间的耦合度。在实际开发中，简单工厂模式常用于创建配置对象、数据库连接、日志记录器等场景。


# 工厂方法模式

## 定义

工厂方法模式是创建型设计模式的一种，它定义了一个创建对象的接口，但让子类决定实例化哪一个类。工厂方法让类的实例化推迟到子类中进行，从而实现了创建者和具体产品的解耦。

**核心思想**

- **延迟实例化**：将对象的创建延迟到子类中决定
- **遵循开闭原则**：对扩展开放，对修改关闭
- **单一职责**：每个工厂类只负责创建一种产品
- **依赖倒置**：依赖抽象而不是具体实现

**结构组成**

1. **抽象产品 (Abstract Product)**：定义产品的公共接口
2. **具体产品 (Concrete Product)**：实现抽象产品接口的具体类
3. **抽象工厂 (Abstract Factory)**：声明工厂方法，返回抽象产品类型
4. **具体工厂 (Concrete Factory)**：实现工厂方法，返回具体产品实例
5. **客户端 (Client)**：使用抽象工厂和抽象产品

## 实现

### 交通工具工厂

```cpp
#include <iostream>
#include <memory>
#include <vector>

// 抽象产品：交通工具
class Vehicle {
public:
    virtual void start() = 0;
    virtual void stop() = 0;
    virtual ~Vehicle() = default;
};

// 具体产品：汽车
class Car : public Vehicle {
public:
    void start() override {
        std::cout << "汽车启动：点火，挂档，踩油门" << std::endl;
    }
    
    void stop() override {
        std::cout << "汽车停止：踩刹车，拉手刹" << std::endl;
    }
};

// 具体产品：自行车
class Bicycle : public Vehicle {
public:
    void start() override {
        std::cout << "自行车启动：踩踏板" << std::endl;
    }
    
    void stop() override {
        std::cout << "自行车停止：捏刹车" << std::endl;
    }
};

// 具体产品：飞机
class Airplane : public Vehicle {
public:
    void start() override {
        std::cout << "飞机启动：启动引擎，滑行起飞" << std::endl;
    }
    
    void stop() override {
        std::cout << "飞机停止：降落，关闭引擎" << std::endl;
    }
};

// 抽象工厂：交通工具工厂
class VehicleFactory {
public:
    virtual std::unique_ptr<Vehicle> createVehicle() = 0;
    virtual ~VehicleFactory() = default;
    
    // 模板方法：定义使用流程
    void useVehicle() {
        auto vehicle = createVehicle();
        vehicle->start();
        std::cout << "正在使用交通工具..." << std::endl;
        vehicle->stop();
    }
};

// 具体工厂：汽车工厂
class CarFactory : public VehicleFactory {
public:
    std::unique_ptr<Vehicle> createVehicle() override {
        return std::make_unique<Car>();
    }
};

// 具体工厂：自行车工厂
class BicycleFactory : public VehicleFactory {
public:
    std::unique_ptr<Vehicle> createVehicle() override {
        return std::make_unique<Bicycle>();
    }
};

// 具体工厂：飞机工厂
class AirplaneFactory : public VehicleFactory {
public:
    std::unique_ptr<Vehicle> createVehicle() override {
        return std::make_unique<Airplane>();
    }
};

// 客户端使用
int main() {
    // 创建不同的工厂
    std::vector<std::unique_ptr<VehicleFactory>> factories;
    factories.push_back(std::make_unique<CarFactory>());
    factories.push_back(std::make_unique<BicycleFactory>());
    factories.push_back(std::make_unique<AirplaneFactory>());
    
    // 使用工厂创建和使用交通工具
    for (auto& factory : factories) {
        factory->useVehicle();
        std::cout << "-------------------" << std::endl;
    }
    
    return 0;
}
```

![交通工具工厂](../img/cpp_img/交通工具工厂.png)

### 数据库连接工厂

```cpp
// 抽象产品：数据库连接
class DatabaseConnection {
public:
    virtual void connect() = 0;
    virtual void executeQuery(const std::string& sql) = 0;
    virtual void disconnect() = 0;
    virtual ~DatabaseConnection() = default;
};

// 具体产品：MySQL连接
class MySQLConnection : public DatabaseConnection {
public:
    void connect() override {
        std::cout << "连接到MySQL数据库" << std::endl;
    }
    
    void executeQuery(const std::string& sql) override {
        std::cout << "在MySQL中执行: " << sql << std::endl;
    }
    
    void disconnect() override {
        std::cout << "断开MySQL连接" << std::endl;
    }
};

// 具体产品：PostgreSQL连接
class PostgreSQLConnection : public DatabaseConnection {
public:
    void connect() override {
        std::cout << "连接到PostgreSQL数据库" << std::endl;
    }
    
    void executeQuery(const std::string& sql) override {
        std::cout << "在PostgreSQL中执行: " << sql << std::endl;
    }
    
    void disconnect() override {
        std::cout << "断开PostgreSQL连接" << std::endl;
    }
};

// 抽象工厂：数据库工厂
class DatabaseFactory {
public:
    virtual std::unique_ptr<DatabaseConnection> createConnection() = 0;
    virtual ~DatabaseFactory() = default;
};

// 具体工厂：MySQL工厂
class MySQLFactory : public DatabaseFactory {
public:
    std::unique_ptr<DatabaseConnection> createConnection() override {
        return std::make_unique<MySQLConnection>();
    }
};

// 具体工厂：PostgreSQL工厂
class PostgreSQLFactory : public DatabaseFactory {
public:
    std::unique_ptr<DatabaseConnection> createConnection() override {
        return std::make_unique<PostgreSQLConnection>();
    }
};
```

![工厂方法_数据库连接](../img/cpp_img/工厂方法_数据库连接.png)

### 日志记录器工厂

```cpp
// 抽象产品：日志记录器
class Logger {
public:
    virtual void log(const std::string& message) = 0;
    virtual ~Logger() = default;
};

// 具体产品：文件日志记录器
class FileLogger : public Logger {
public:
    void log(const std::string& message) override {
        std::cout << "[文件日志] " << message << std::endl;
    }
};

// 具体产品：控制台日志记录器
class ConsoleLogger : public Logger {
public:
    void log(const std::string& message) override {
        std::cout << "[控制台日志] " << message << std::endl;
    }
};

// 具体产品：网络日志记录器
class NetworkLogger : public Logger {
public:
    void log(const std::string& message) override {
        std::cout << "[网络日志] " << message << std::endl;
    }
};

// 抽象工厂：日志工厂
class LoggerFactory {
public:
    virtual std::unique_ptr<Logger> createLogger() = 0;
    virtual ~LoggerFactory() = default;
};

// 具体工厂实现
class FileLoggerFactory : public LoggerFactory {
public:
    std::unique_ptr<Logger> createLogger() override {
        return std::make_unique<FileLogger>();
    }
};

class ConsoleLoggerFactory : public LoggerFactory {
public:
    std::unique_ptr<Logger> createLogger() override {
        return std::make_unique<ConsoleLogger>();
    }
};

class NetworkLoggerFactory : public LoggerFactory {
public:
    std::unique_ptr<Logger> createLogger() override {
        return std::make_unique<NetworkLogger>();
    }
};
```

![工厂方法_日志记录器](../img/cpp_img/工厂方法_日志记录器.png)

## 总结

### 优缺点

**优点：**

1、用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。

2、灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。

3、典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类。

4、对扩展开放对修改关闭；解决了简单工厂的缺点问题。

**总结：遵循了单一职责原则、开放闭合原则、遵循了依赖倒置原则。**

**缺点：**

1、类的个数容易过多，增加复杂度

2、增加了系统的抽象性和理解难度

3、接口的传入参数类型需要一致，且只能对单一变化量接口使用

4、抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决。

**总结：工厂的数量会随着产品的增加而急剧上升。**

### 适用场景

1. **创建对象需要大量重复代码**
2. **客户端不依赖于产品类实例如何被创建、实现等细节**
3. **一个类通过其子类来指定创建哪个对象**
4. **需要为库或框架提供扩展点**

### 与简单工厂模式的区别

| 特性           | 简单工厂模式                   | 工厂方法模式                     |
| -------------- | ------------------------------ | -------------------------------- |
| **工厂数量**   | 一个工厂类                     | 多个工厂类（每个产品一个工厂）   |
| **扩展性**     | 违反开闭原则，需要修改工厂类   | 遵循开闭原则，只需添加新工厂类   |
| **复杂度**     | 简单，适合产品种类少的情况     | 相对复杂，适合产品种类多的情况   |
| **职责分离**   | 工厂类职责较重                 | 每个工厂类职责单一               |
| **客户端依赖** | 依赖具体工厂类                 | 依赖抽象工厂类                   |
| **参数传递**   | 通常需要参数来决定创建哪种产品 | 不需要参数，工厂类型决定产品类型 |

工厂方法模式是一种非常实用的创建型设计模式，它通过将对象的创建延迟到子类中，实现了创建者和产品的解耦。相比简单工厂模式，工厂方法模式更好地遵循了开闭原则和单一职责原则，使得系统更容易扩展和维护。在需要创建多种相关产品，且产品种类可能会增加的场景下，工厂方法模式是一个很好的选择。


# 抽象工厂模式

## 定义

抽象工厂模式是创建型设计模式的一种，它提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。抽象工厂模式也被称为Kit模式，它是工厂方法模式的进一步抽象和推广。

**核心思想**

- **产品族概念**：创建一系列相关的产品对象
- **多个工厂方法**：一个抽象工厂包含多个工厂方法
- **产品一致性**：确保同一工厂创建的产品属于同一产品族
- **易于切换产品族**：通过切换工厂来切换整个产品族

**结构组成**

1. **抽象工厂 (Abstract Factory)**：声明创建抽象产品对象的操作接口
2. **具体工厂 (Concrete Factory)**：实现创建具体产品对象的操作
3. **抽象产品 (Abstract Product)**：为一类产品对象声明接口
4. **具体产品 (Concrete Product)**：定义具体工厂创建的产品对象
5. **客户端 (Client)**：使用抽象工厂和抽象产品类声明的接口

**产品族概念**

产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品。例如：
- **现代风格家具族**：现代沙发 + 现代茶几 + 现代衣柜
- **古典风格家具族**：古典沙发 + 古典茶几 + 古典衣柜

## 实现

### GUI组件工厂

```cpp
#include <iostream>
#include <memory>

// 抽象产品A：按钮
class Button {
public:
    virtual void render() = 0;
    virtual void onClick() = 0;
    virtual ~Button() = default;
};

// 抽象产品B：文本框
class TextBox {
public:
    virtual void render() = 0;
    virtual void input(const std::string& text) = 0;
    virtual ~TextBox() = default;
};

// 抽象产品C：复选框
class CheckBox {
public:
    virtual void render() = 0;
    virtual void toggle() = 0;
    virtual ~CheckBox() = default;
};

// Windows风格的具体产品
class WindowsButton : public Button {
public:
    void render() override {
        std::cout << "渲染Windows风格按钮" << std::endl;
    }
    
    void onClick() override {
        std::cout << "Windows按钮被点击" << std::endl;
    }
};

class WindowsTextBox : public TextBox {
public:
    void render() override {
        std::cout << "渲染Windows风格文本框" << std::endl;
    }
    
    void input(const std::string& text) override {
        std::cout << "Windows文本框输入: " << text << std::endl;
    }
};

class WindowsCheckBox : public CheckBox {
public:
    void render() override {
        std::cout << "渲染Windows风格复选框" << std::endl;
    }
    
    void toggle() override {
        std::cout << "Windows复选框状态切换" << std::endl;
    }
};

// macOS风格的具体产品
class MacButton : public Button {
public:
    void render() override {
        std::cout << "渲染macOS风格按钮" << std::endl;
    }
    
    void onClick() override {
        std::cout << "macOS按钮被点击" << std::endl;
    }
};

class MacTextBox : public TextBox {
public:
    void render() override {
        std::cout << "渲染macOS风格文本框" << std::endl;
    }
    
    void input(const std::string& text) override {
        std::cout << "macOS文本框输入: " << text << std::endl;
    }
};

class MacCheckBox : public CheckBox {
public:
    void render() override {
        std::cout << "渲染macOS风格复选框" << std::endl;
    }
    
    void toggle() override {
        std::cout << "macOS复选框状态切换" << std::endl;
    }
};

// Linux风格的具体产品
class LinuxButton : public Button {
public:
    void render() override {
        std::cout << "渲染Linux风格按钮" << std::endl;
    }
    
    void onClick() override {
        std::cout << "Linux按钮被点击" << std::endl;
    }
};

class LinuxTextBox : public TextBox {
public:
    void render() override {
        std::cout << "渲染Linux风格文本框" << std::endl;
    }
    
    void input(const std::string& text) override {
        std::cout << "Linux文本框输入: " << text << std::endl;
    }
};

class LinuxCheckBox : public CheckBox {
public:
    void render() override {
        std::cout << "渲染Linux风格复选框" << std::endl;
    }
    
    void toggle() override {
        std::cout << "Linux复选框状态切换" << std::endl;
    }
};

// 抽象工厂
class GUIFactory {
public:
    virtual std::unique_ptr<Button> createButton() = 0;
    virtual std::unique_ptr<TextBox> createTextBox() = 0;
    virtual std::unique_ptr<CheckBox> createCheckBox() = 0;
    virtual ~GUIFactory() = default;
};

// 具体工厂：Windows工厂
class WindowsFactory : public GUIFactory {
public:
    std::unique_ptr<Button> createButton() override {
        return std::make_unique<WindowsButton>();
    }
    
    std::unique_ptr<TextBox> createTextBox() override {
        return std::make_unique<WindowsTextBox>();
    }
    
    std::unique_ptr<CheckBox> createCheckBox() override {
        return std::make_unique<WindowsCheckBox>();
    }
};

// 具体工厂：macOS工厂
class MacFactory : public GUIFactory {
public:
    std::unique_ptr<Button> createButton() override {
        return std::make_unique<MacButton>();
    }
    
    std::unique_ptr<TextBox> createTextBox() override {
        return std::make_unique<MacTextBox>();
    }
    
    std::unique_ptr<CheckBox> createCheckBox() override {
        return std::make_unique<MacCheckBox>();
    }
};

// 具体工厂：Linux工厂
class LinuxFactory : public GUIFactory {
public:
    std::unique_ptr<Button> createButton() override {
        return std::make_unique<LinuxButton>();
    }
    
    std::unique_ptr<TextBox> createTextBox() override {
        return std::make_unique<LinuxTextBox>();
    }
    
    std::unique_ptr<CheckBox> createCheckBox() override {
        return std::make_unique<LinuxCheckBox>();
    }
};

// 客户端应用程序
class Application {
public:
    Application(std::unique_ptr<GUIFactory> factory) 
        : factory_(std::move(factory)) {
        createUI();
    }
    
    void createUI() {
        button_ = factory_->createButton();
        textBox_ = factory_->createTextBox();
        checkBox_ = factory_->createCheckBox();
    }
    
    void renderUI() {
        button_->render();
        textBox_->render();
        checkBox_->render();
    }
    
    void interactWithUI() {
        button_->onClick();
        textBox_->input("Hello World");
        checkBox_->toggle();
    }
    
private:
    std::unique_ptr<GUIFactory> factory_;
    std::unique_ptr<Button> button_;
    std::unique_ptr<TextBox> textBox_;
    std::unique_ptr<CheckBox> checkBox_;
};

// 工厂选择器
std::unique_ptr<GUIFactory> createFactory(const std::string& platform) {
    if (platform == "Windows") {
        return std::make_unique<WindowsFactory>();
    } else if (platform == "macOS") {
        return std::make_unique<MacFactory>();
    } else if (platform == "Linux") {
        return std::make_unique<LinuxFactory>();
    }
    return nullptr;
}

// 使用示例
int main() {
    // 根据平台创建对应的工厂
    std::string platform = "Windows"; // 可以从配置文件或环境变量获取
    
    auto factory = createFactory(platform);
    if (factory) {
        Application app(std::move(factory));
        
        std::cout << "=== 渲染UI ===" << std::endl;
        app.renderUI();
        
        std::cout << "\n=== 交互操作 ===" << std::endl;
        app.interactWithUI();
    }
    
    return 0;
}
```

![GUI组件工厂](../img/cpp_img/GUI组件工厂.png)

### 游戏角色装备工厂

```cpp
#include <iostream>
#include <memory>
#include <vector>

// 抽象产品：武器
class Weapon {
public:
    virtual void attack() = 0;
    virtual int getDamage() const = 0;
    virtual ~Weapon() = default;
};

// 抽象产品：护甲
class Armor {
public:
    virtual void defend() = 0;
    virtual int getDefense() const = 0;
    virtual ~Armor() = default;
};

// 抽象产品：饰品
class Accessory {
public:
    virtual void useSpecialAbility() = 0;
    virtual std::string getEffect() const = 0;
    virtual ~Accessory() = default;
};

// 战士装备族
class WarriorSword : public Weapon {
public:
    void attack() override {
        std::cout << "挥舞战士之剑进行强力攻击!" << std::endl;
    }
    
    int getDamage() const override { return 100; }
};

class WarriorArmor : public Armor {
public:
    void defend() override {
        std::cout << "战士重甲提供强大防护!" << std::endl;
    }
    
    int getDefense() const override { return 80; }
};

class WarriorShield : public Accessory {
public:
    void useSpecialAbility() override {
        std::cout << "举起盾牌，格挡敌人攻击!" << std::endl;
    }
    
    std::string getEffect() const override { return "格挡+50%"; }
};

// 法师装备族
class MageStaff : public Weapon {
public:
    void attack() override {
        std::cout << "挥舞法师法杖释放魔法攻击!" << std::endl;
    }
    
    int getDamage() const override { return 120; }
};

class MageRobe : public Armor {
public:
    void defend() override {
        std::cout << "法师长袍提供魔法防护!" << std::endl;
    }
    
    int getDefense() const override { return 40; }
};

class MageOrb : public Accessory {
public:
    void useSpecialAbility() override {
        std::cout << "魔法球增强法术威力!" << std::endl;
    }
    
    std::string getEffect() const override { return "魔法伤害+30%"; }
};

// 盗贼装备族
class RogueDagger : public Weapon {
public:
    void attack() override {
        std::cout << "使用盗贼匕首进行快速攻击!" << std::endl;
    }
    
    int getDamage() const override { return 80; }
};

class RogueLeather : public Armor {
public:
    void defend() override {
        std::cout << "盗贼皮甲提供灵活防护!" << std::endl;
    }
    
    int getDefense() const override { return 50; }
};

class RogueCloak : public Accessory {
public:
    void useSpecialAbility() override {
        std::cout << "隐身斗篷让你消失在阴影中!" << std::endl;
    }
    
    std::string getEffect() const override { return "隐身5秒"; }
};

// 抽象装备工厂
class EquipmentFactory {
public:
    virtual std::unique_ptr<Weapon> createWeapon() = 0;
    virtual std::unique_ptr<Armor> createArmor() = 0;
    virtual std::unique_ptr<Accessory> createAccessory() = 0;
    virtual std::string getClassName() const = 0;
    virtual ~EquipmentFactory() = default;
};

// 具体工厂：战士装备工厂
class WarriorEquipmentFactory : public EquipmentFactory {
public:
    std::unique_ptr<Weapon> createWeapon() override {
        return std::make_unique<WarriorSword>();
    }
    
    std::unique_ptr<Armor> createArmor() override {
        return std::make_unique<WarriorArmor>();
    }
    
    std::unique_ptr<Accessory> createAccessory() override {
        return std::make_unique<WarriorShield>();
    }
    
    std::string getClassName() const override { return "战士"; }
};

// 具体工厂：法师装备工厂
class MageEquipmentFactory : public EquipmentFactory {
public:
    std::unique_ptr<Weapon> createWeapon() override {
        return std::make_unique<MageStaff>();
    }
    
    std::unique_ptr<Armor> createArmor() override {
        return std::make_unique<MageRobe>();
    }
    
    std::unique_ptr<Accessory> createAccessory() override {
        return std::make_unique<MageOrb>();
    }
    
    std::string getClassName() const override { return "法师"; }
};

// 具体工厂：盗贼装备工厂
class RogueEquipmentFactory : public EquipmentFactory {
public:
    std::unique_ptr<Weapon> createWeapon() override {
        return std::make_unique<RogueDagger>();
    }
    
    std::unique_ptr<Armor> createArmor() override {
        return std::make_unique<RogueLeather>();
    }
    
    std::unique_ptr<Accessory> createAccessory() override {
        return std::make_unique<RogueCloak>();
    }
    
    std::string getClassName() const override { return "盗贼"; }
};

// 游戏角色类
class GameCharacter {
public:
    GameCharacter(std::unique_ptr<EquipmentFactory> factory)
        : factory_(std::move(factory)) {
        equipItems();
    }
    
    void equipItems() {
        weapon_ = factory_->createWeapon();
        armor_ = factory_->createArmor();
        accessory_ = factory_->createAccessory();
        
        std::cout << "=== " << factory_->getClassName() << "装备完成 ===" << std::endl;
    }
    
    void showStats() {
        std::cout << "职业: " << factory_->getClassName() << std::endl;
        std::cout << "攻击力: " << weapon_->getDamage() << std::endl;
        std::cout << "防御力: " << armor_->getDefense() << std::endl;
        std::cout << "特殊效果: " << accessory_->getEffect() << std::endl;
    }
    
    void performActions() {
        weapon_->attack();
        armor_->defend();
        accessory_->useSpecialAbility();
    }
    
private:
    std::unique_ptr<EquipmentFactory> factory_;
    std::unique_ptr<Weapon> weapon_;
    std::unique_ptr<Armor> armor_;
    std::unique_ptr<Accessory> accessory_;
};

// 角色创建器
class CharacterCreator {
public:
    static std::unique_ptr<EquipmentFactory> createEquipmentFactory(const std::string& characterClass) {
        if (characterClass == "Warrior") {
            return std::make_unique<WarriorEquipmentFactory>();
        } else if (characterClass == "Mage") {
            return std::make_unique<MageEquipmentFactory>();
        } else if (characterClass == "Rogue") {
            return std::make_unique<RogueEquipmentFactory>();
        }
        return nullptr;
    }
};

// 使用示例
int main() {
    std::vector<std::string> characterClasses = {"Warrior", "Mage", "Rogue"};
    
    for (const auto& characterClass : characterClasses) {
        auto factory = CharacterCreator::createEquipmentFactory(characterClass);
        if (factory) {
            GameCharacter character(std::move(factory));
            
            character.showStats();
            std::cout << "\n=== 战斗演示 ===" << std::endl;
            character.performActions();
            std::cout << "\n" << std::string(40, '-') << "\n" << std::endl;
        }
    }
    
    return 0;
}
```

![游戏角色装备工厂](../img/cpp_img/游戏角色装备工厂.png)

## 总结

### 优缺点

**优点：**

1. 抽象工厂模式隔离了具体类的生成，使得客户端并不需要知道什么被创建。
2. 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一产品族中的对象；
3. 增加新的产品族很方便（生成新的具体工厂），无需修改已有系统代码，符合开闭原则；

**缺点：**
**增加新的产品等级结构很复杂**，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。

### 适用场景

1. **系统需要独立于产品的创建、组合和表示**
2. **系统需要由多个产品族中的一个来配置**
3. **需要强调一系列相关产品对象的设计以便进行联合使用**
4. **提供一个产品类库，只想显示接口而不是实现**

### 与其他工厂模式的对比

| 特性             | 简单工厂     | 工厂方法     | 抽象工厂               |
| ---------------- | ------------ | ------------ | ---------------------- |
| **产品数量**     | 单一产品     | 单一产品     | 产品族（多个相关产品） |
| **工厂数量**     | 一个工厂     | 多个工厂     | 多个工厂               |
| **工厂方法数量** | 一个方法     | 一个方法     | 多个方法               |
| **扩展性**       | 违反开闭原则 | 符合开闭原则 | 符合开闭原则           |
| **复杂度**       | 简单         | 中等         | 复杂                   |
| **适用场景**     | 产品种类少   | 产品种类多   | 产品族的创建           |

### 实际应用场景

1. **跨平台UI框架**：不同操作系统的UI组件
2. **数据库访问层**：不同数据库的连接、命令、事务对象
3. **游戏开发**：不同职业的装备、技能、属性
4. **主题系统**：不同主题的颜色、字体、图标
5. **文档处理**：不同格式的解析器、生成器、验证器

抽象工厂模式是处理产品族创建的强大工具，它通过提供一系列相关产品的创建接口，确保了产品的一致性和系统的可扩展性。虽然它增加了系统的复杂度，但在需要管理多个相关产品族的场景下，抽象工厂模式能够提供清晰的架构和良好的可维护性。在实际应用中，合理地设计产品族和工厂层次结构是成功应用这一模式的关键。


# 观察者模式

## 定义
观察者模式是一种行为型设计模式，它定义了对象之间的一对多依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。

**核心思想**

- **发布-订阅机制**：主题（Subject）维护一个观察者列表，状态改变时通知所有观察者
- **松耦合**：主题和观察者之间通过抽象接口交互，降低耦合度
- **动态关系**：观察者可以在运行时动态添加或移除
- **广播通信**：一个主题可以同时通知多个观察者

**结构组成**

**1. 抽象主题（Subject）**

定义添加、删除和通知观察者的接口

**2. 具体主题（ConcreteSubject）**

实现抽象主题接口，维护观察者列表和状态

**3. 抽象观察者（Observer）**

定义更新接口，供主题通知时调用

**4. 具体观察者（ConcreteObserver）**

实现抽象观察者接口，定义具体的更新行为

## 实现

### 基础实现

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>

// 抽象观察者
class Observer {
public:
    virtual ~Observer() = default;
    virtual void update(const std::string& message) = 0;
};

// 抽象主题
class Subject {
public:
    virtual ~Subject() = default;
    virtual void attach(Observer* observer) = 0;
    virtual void detach(Observer* observer) = 0;
    virtual void notify() = 0;
};

// 具体主题 - 新闻发布者
class NewsPublisher : public Subject {
private:
    std::vector<Observer*> observers;
    std::string news;
    
public:
    void attach(Observer* observer) override {
        observers.push_back(observer);
    }
    
    void detach(Observer* observer) override {
        observers.erase(
            std::remove(observers.begin(), observers.end(), observer),
            observers.end()
        );
    }
    
    void notify() override {
        for (auto* observer : observers) {
            observer->update(news);
        }
    }
    
    void setNews(const std::string& newNews) {
        news = newNews;
        notify();
    }
    
    std::string getNews() const {
        return news;
    }
};

// 具体观察者 - 新闻订阅者
class NewsSubscriber : public Observer {
private:
    std::string name;
    
public:
    NewsSubscriber(const std::string& subscriberName) 
        : name(subscriberName) {}
    
    void update(const std::string& message) override {
        std::cout << "订阅者 " << name << " 收到新闻: " << message << std::endl;
    }
};

// 使用示例
int main() {
    NewsPublisher publisher;
    
    NewsSubscriber subscriber1("张三");
    NewsSubscriber subscriber2("李四");
    NewsSubscriber subscriber3("王五");
    
    // 订阅新闻
    publisher.attach(&subscriber1);
    publisher.attach(&subscriber2);
    publisher.attach(&subscriber3);
    
    // 发布新闻
    publisher.setNews("重大科技突破！");
    
    std::cout << "\n--- 李四取消订阅 ---\n" << std::endl;
    publisher.detach(&subscriber2);
    
    // 再次发布新闻
    publisher.setNews("经济形势分析报告发布");
    
    return 0;
}
```

![观察者模式](../img/cpp_img/观察者模式.png)

### 股票价格监控系统

```cpp
#include <iostream>
#include <vector>
#include <memory>
#include <string>
#include <unordered_map>

// 股票数据结构
struct StockData {
    std::string symbol;
    double price;
    double change;
    double changePercent;
    
    StockData(const std::string& sym, double p, double c, double cp)
        : symbol(sym), price(p), change(c), changePercent(cp) {}
};

// 抽象观察者
class StockObserver {
public:
    virtual ~StockObserver() = default;
    virtual void onPriceUpdate(const StockData& data) = 0;
    virtual std::string getName() const = 0;
};

// 抽象主题
class StockSubject {
public:
    virtual ~StockSubject() = default;
    virtual void subscribe(std::shared_ptr<StockObserver> observer) = 0;
    virtual void unsubscribe(std::shared_ptr<StockObserver> observer) = 0;
    virtual void notifyObservers(const StockData& data) = 0;
};

// 具体主题 - 股票市场
class StockMarket : public StockSubject {
private:
    std::vector<std::weak_ptr<StockObserver>> observers;
    std::unordered_map<std::string, StockData> stocks;
    
    void cleanupObservers() {
        observers.erase(
            std::remove_if(observers.begin(), observers.end(),
                [](const std::weak_ptr<StockObserver>& wp) {
                    return wp.expired();
                }),
            observers.end()
        );
    }
    
public:
    void subscribe(std::shared_ptr<StockObserver> observer) override {
        observers.push_back(observer);
    }
    
    void unsubscribe(std::shared_ptr<StockObserver> observer) override {
        observers.erase(
            std::remove_if(observers.begin(), observers.end(),
                [&observer](const std::weak_ptr<StockObserver>& wp) {
                    auto sp = wp.lock();
                    return sp && sp == observer;
                }),
            observers.end()
        );
    }
    
    void notifyObservers(const StockData& data) override {
        cleanupObservers();
        for (auto& weakObserver : observers) {
            if (auto observer = weakObserver.lock()) {
                observer->onPriceUpdate(data);
            }
        }
    }
    
    void updateStock(const std::string& symbol, double newPrice) {
        double oldPrice = 0.0;
        if (stocks.find(symbol) != stocks.end()) {
            oldPrice = stocks[symbol].price;
        }
        
        double change = newPrice - oldPrice;
        double changePercent = oldPrice != 0 ? (change / oldPrice) * 100 : 0;
        
        StockData data(symbol, newPrice, change, changePercent);
        stocks[symbol] = data;
        
        notifyObservers(data);
    }
};

// 具体观察者 - 投资者
class Investor : public StockObserver {
private:
    std::string name;
    double alertThreshold;
    
public:
    Investor(const std::string& investorName, double threshold = 5.0)
        : name(investorName), alertThreshold(threshold) {}
    
    void onPriceUpdate(const StockData& data) override {
        std::cout << "投资者 " << name << " 收到 " << data.symbol 
                  << " 价格更新: $" << data.price;
        
        if (std::abs(data.changePercent) >= alertThreshold) {
            std::cout << " [警告: 变动幅度 " << data.changePercent << "%]";
        }
        
        std::cout << std::endl;
    }
    
    std::string getName() const override {
        return name;
    }
};

// 具体观察者 - 交易系统
class TradingSystem : public StockObserver {
private:
    std::string systemName;
    
public:
    TradingSystem(const std::string& name) : systemName(name) {}
    
    void onPriceUpdate(const StockData& data) override {
        std::cout << "交易系统 " << systemName << " 处理 " << data.symbol
                  << " 数据: 价格=$" << data.price 
                  << ", 变动=$" << data.change
                  << " (" << data.changePercent << "%)" << std::endl;
        
        // 模拟自动交易逻辑
        if (data.changePercent > 10) {
            std::cout << "  -> 触发卖出信号" << std::endl;
        } else if (data.changePercent < -10) {
            std::cout << "  -> 触发买入信号" << std::endl;
        }
    }
    
    std::string getName() const override {
        return systemName;
    }
};

// 使用示例
int main() {
    auto market = std::make_shared<StockMarket>();
    
    auto investor1 = std::make_shared<Investor>("张投资", 3.0);
    auto investor2 = std::make_shared<Investor>("李股民", 5.0);
    auto tradingSystem = std::make_shared<TradingSystem>("智能交易系统");
    
    // 订阅股票更新
    market->subscribe(investor1);
    market->subscribe(investor2);
    market->subscribe(tradingSystem);
    
    std::cout << "=== 股票价格更新 ===\n" << std::endl;
    
    // 模拟股票价格变化
    market->updateStock("AAPL", 150.00);
    std::cout << std::endl;
    
    market->updateStock("AAPL", 165.00);  // 10% 涨幅
    std::cout << std::endl;
    
    market->updateStock("GOOGL", 2800.00);
    std::cout << std::endl;
    
    // 投资者1取消订阅
    std::cout << "--- 张投资取消订阅 ---\n" << std::endl;
    market->unsubscribe(investor1);
    
    market->updateStock("AAPL", 148.50);  // 下跌
    
    return 0;
}
```

![股票市场观察者](../img/cpp_img/股票市场观察者.png)

## 总结

### 优缺点

**优点**:

1、观察者和被观察者是抽象耦合的

2、建立一套触发机制。

**缺点**:

1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。

2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。

3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

### 适用场景

1. **GUI事件处理**：按钮点击、窗口事件等
2. **模型-视图架构**：MVC、MVP、MVVM模式
3. **消息系统**：发布-订阅消息队列
4. **数据绑定**：数据变化自动更新UI
5. **监控系统**：系统状态监控和告警
6. **游戏开发**：事件系统、状态变化通知

观察者模式是一种强大的行为型设计模式，它通过建立一对多的依赖关系，实现了对象间的松耦合通信。该模式在GUI编程、事件处理、数据绑定等场景中应用广泛，是现代软件架构中不可或缺的设计模式之一。正确使用观察者模式可以提高代码的可维护性和扩展性，但也需要注意性能和内存管理等问题。


# 职责链模式

## 定义
职责链模式是一种行为型设计模式，它为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。

**核心思想**

- **请求传递**：将请求沿着处理者链传递，直到有处理者能够处理它
- **动态组合**：可以动态地组织和分配责任
- **发送者与接收者解耦**：请求发送者不需要知道具体哪个对象会处理请求
- **责任分离**：每个处理者只关注自己能处理的请求类型

**结构组成**

**1. 抽象处理者（Handler）**

定义处理请求的接口，包含指向下一个处理者的引用

**2. 具体处理者（ConcreteHandler）**

实现处理请求的具体逻辑，如果不能处理则传递给下一个处理者

**3. 客户端（Client）**

创建处理者链并发送请求

## 实现

### 请假审批系统

```cpp
#include <iostream>
#include <memory>
#include <string>

// 请假请求
struct LeaveRequest {
    std::string employeeName;
    int days;
    std::string reason;
    
    LeaveRequest(const std::string& name, int d, const std::string& r)
        : employeeName(name), days(d), reason(r) {}
};

// 抽象处理者
class LeaveHandler {
protected:
    std::shared_ptr<LeaveHandler> nextHandler;
    std::string handlerName;
    
public:
    LeaveHandler(const std::string& name) : handlerName(name) {}
    virtual ~LeaveHandler() = default;
    
    // 设置下一个处理者
    void setNext(std::shared_ptr<LeaveHandler> handler) {
        nextHandler = handler;
    }
    
    // 处理请求的模板方法
    void handleRequest(const LeaveRequest& request) {
        if (canHandle(request)) {
            processRequest(request);
        } else if (nextHandler) {
            std::cout << handlerName << " 无法处理，转交给下一级" << std::endl;
            nextHandler->handleRequest(request);
        } else {
            std::cout << "没有合适的处理者能够处理此请求" << std::endl;
        }
    }
    
protected:
    // 判断是否能处理请求
    virtual bool canHandle(const LeaveRequest& request) = 0;
    // 处理请求
    virtual void processRequest(const LeaveRequest& request) = 0;
};

// 具体处理者 - 组长
class TeamLeader : public LeaveHandler {
public:
    TeamLeader() : LeaveHandler("组长") {}
    
protected:
    bool canHandle(const LeaveRequest& request) override {
        return request.days <= 1;
    }
    
    void processRequest(const LeaveRequest& request) override {
        std::cout << handlerName << " 批准了 " << request.employeeName 
                  << " 的 " << request.days << " 天请假申请";
        std::cout << " (原因: " << request.reason << ")" << std::endl;
    }
};

// 具体处理者 - 部门经理
class DepartmentManager : public LeaveHandler {
public:
    DepartmentManager() : LeaveHandler("部门经理") {}
    
protected:
    bool canHandle(const LeaveRequest& request) override {
        return request.days <= 3;
    }
    
    void processRequest(const LeaveRequest& request) override {
        std::cout << handlerName << " 批准了 " << request.employeeName 
                  << " 的 " << request.days << " 天请假申请";
        std::cout << " (原因: " << request.reason << ")" << std::endl;
    }
};

// 具体处理者 - 总经理
class GeneralManager : public LeaveHandler {
public:
    GeneralManager() : LeaveHandler("总经理") {}
    
protected:
    bool canHandle(const LeaveRequest& request) override {
        return request.days <= 7;
    }
    
    void processRequest(const LeaveRequest& request) override {
        std::cout << handlerName << " 批准了 " << request.employeeName 
                  << " 的 " << request.days << " 天请假申请";
        std::cout << " (原因: " << request.reason << ")" << std::endl;
    }
};

// 具体处理者 - 董事会
class Board : public LeaveHandler {
public:
    Board() : LeaveHandler("董事会") {}
    
protected:
    bool canHandle(const LeaveRequest& request) override {
        return request.days <= 30;
    }
    
    void processRequest(const LeaveRequest& request) override {
        if (request.days > 15) {
            std::cout << handlerName << " 需要特别审议 " << request.employeeName 
                      << " 的 " << request.days << " 天长期请假申请" << std::endl;
        } else {
            std::cout << handlerName << " 批准了 " << request.employeeName 
                      << " 的 " << request.days << " 天请假申请" << std::endl;
        }
    }
};

// 使用示例
int main() {
    // 创建处理者链
    auto teamLeader = std::make_shared<TeamLeader>();
    auto deptManager = std::make_shared<DepartmentManager>();
    auto generalManager = std::make_shared<GeneralManager>();
    auto board = std::make_shared<Board>();
    
    // 构建职责链
    teamLeader->setNext(deptManager);
    deptManager->setNext(generalManager);
    generalManager->setNext(board);
    
    // 测试不同的请假申请
    std::cout << "=== 请假审批系统 ===\n" << std::endl;
    
    LeaveRequest request1("张三", 1, "感冒发烧");
    std::cout << "处理请求: " << request1.employeeName << " 请假 " 
              << request1.days << " 天" << std::endl;
    teamLeader->handleRequest(request1);
    std::cout << std::endl;
    
    LeaveRequest request2("李四", 3, "家庭事务");
    std::cout << "处理请求: " << request2.employeeName << " 请假 " 
              << request2.days << " 天" << std::endl;
    teamLeader->handleRequest(request2);
    std::cout << std::endl;
    
    LeaveRequest request3("王五", 7, "结婚度蜜月");
    std::cout << "处理请求: " << request3.employeeName << " 请假 " 
              << request3.days << " 天" << std::endl;
    teamLeader->handleRequest(request3);
    std::cout << std::endl;
    
    LeaveRequest request4("赵六", 20, "出国深造");
    std::cout << "处理请求: " << request4.employeeName << " 请假 " 
              << request4.days << " 天" << std::endl;
    teamLeader->handleRequest(request4);
    std::cout << std::endl;
    
    LeaveRequest request5("钱七", 50, "长期病假");
    std::cout << "处理请求: " << request5.employeeName << " 请假 " 
              << request5.days << " 天" << std::endl;
    teamLeader->handleRequest(request5);
    
    return 0;
}
```

![请假审批系统](../img/cpp_img/请假审批系统.png)

### 日志处理系统

```cpp
#include <iostream>
#include <memory>
#include <string>
#include <fstream>
#include <ctime>
#include <iomanip>
#include <sstream>

// 日志级别枚举
enum class LogLevel {
    DEBUG = 1,
    INFO = 2,
    WARNING = 3,
    ERROR = 4,
    FATAL = 5
};

// 日志消息结构
struct LogMessage {
    LogLevel level;
    std::string message;
    std::string timestamp;
    std::string source;
    
    LogMessage(LogLevel lvl, const std::string& msg, const std::string& src = "")
        : level(lvl), message(msg), source(src) {
        // 生成时间戳
        auto now = std::time(nullptr);
        auto tm = *std::localtime(&now);
        std::ostringstream oss;
        oss << std::put_time(&tm, "%Y-%m-%d %H:%M:%S");
        timestamp = oss.str();
    }
};

// 抽象日志处理者
class LogHandler {
protected:
    std::shared_ptr<LogHandler> nextHandler;
    LogLevel handlerLevel;
    std::string handlerName;
    
public:
    LogHandler(LogLevel level, const std::string& name)
        : handlerLevel(level), handlerName(name) {}
    
    virtual ~LogHandler() = default;
    
    void setNext(std::shared_ptr<LogHandler> handler) {
        nextHandler = handler;
    }
    
    void handle(const LogMessage& message) {
        if (message.level >= handlerLevel) {
            writeLog(message);
        }
        
        if (nextHandler) {
            nextHandler->handle(message);
        }
    }
    
protected:
    virtual void writeLog(const LogMessage& message) = 0;
    
    std::string levelToString(LogLevel level) {
        switch (level) {
            case LogLevel::DEBUG: return "DEBUG";
            case LogLevel::INFO: return "INFO";
            case LogLevel::WARNING: return "WARNING";
            case LogLevel::ERROR: return "ERROR";
            case LogLevel::FATAL: return "FATAL";
            default: return "UNKNOWN";
        }
    }
};

// 控制台日志处理者
class ConsoleLogHandler : public LogHandler {
public:
    ConsoleLogHandler(LogLevel level = LogLevel::DEBUG)
        : LogHandler(level, "控制台处理器") {}
    
protected:
    void writeLog(const LogMessage& message) override {
        std::cout << "[" << handlerName << "] "
                  << "[" << message.timestamp << "] "
                  << "[" << levelToString(message.level) << "] ";
        
        if (!message.source.empty()) {
            std::cout << "[" << message.source << "] ";
        }
        
        std::cout << message.message << std::endl;
    }
};

// 文件日志处理者
class FileLogHandler : public LogHandler {
private:
    std::string filename;
    
public:
    FileLogHandler(LogLevel level, const std::string& file)
        : LogHandler(level, "文件处理器"), filename(file) {}
    
protected:
    void writeLog(const LogMessage& message) override {
        std::ofstream file(filename, std::ios::app);
        if (file.is_open()) {
            file << "[" << message.timestamp << "] "
                 << "[" << levelToString(message.level) << "] ";
            
            if (!message.source.empty()) {
                file << "[" << message.source << "] ";
            }
            
            file << message.message << std::endl;
            file.close();
        }
    }
};

// 邮件日志处理者（模拟）
class EmailLogHandler : public LogHandler {
private:
    std::string emailAddress;
    
public:
    EmailLogHandler(LogLevel level, const std::string& email)
        : LogHandler(level, "邮件处理器"), emailAddress(email) {}
    
protected:
    void writeLog(const LogMessage& message) override {
        // 模拟发送邮件
        std::cout << "[" << handlerName << "] 发送邮件到: " << emailAddress << std::endl;
        std::cout << "  主题: 系统" << levelToString(message.level) << "级别日志" << std::endl;
        std::cout << "  内容: [" << message.timestamp << "] " << message.message << std::endl;
        std::cout << std::endl;
    }
};

// 数据库日志处理者（模拟）
class DatabaseLogHandler : public LogHandler {
private:
    std::string connectionString;
    
public:
    DatabaseLogHandler(LogLevel level, const std::string& connStr)
        : LogHandler(level, "数据库处理器"), connectionString(connStr) {}
    
protected:
    void writeLog(const LogMessage& message) override {
        // 模拟数据库插入
        std::cout << "[" << handlerName << "] 插入到数据库: " << connectionString << std::endl;
        std::cout << "  INSERT INTO logs (timestamp, level, source, message) VALUES (\"" 
                  << message.timestamp << "\", \"" << levelToString(message.level) 
                  << "\", \"" << message.source << "\", \"" << message.message << "\")" << std::endl;
        std::cout << std::endl;
    }
};

// 日志管理器
class Logger {
private:
    std::shared_ptr<LogHandler> handlerChain;
    
public:
    void setHandlerChain(std::shared_ptr<LogHandler> chain) {
        handlerChain = chain;
    }
    
    void debug(const std::string& message, const std::string& source = "") {
        if (handlerChain) {
            handlerChain->handle(LogMessage(LogLevel::DEBUG, message, source));
        }
    }
    
    void info(const std::string& message, const std::string& source = "") {
        if (handlerChain) {
            handlerChain->handle(LogMessage(LogLevel::INFO, message, source));
        }
    }
    
    void warning(const std::string& message, const std::string& source = "") {
        if (handlerChain) {
            handlerChain->handle(LogMessage(LogLevel::WARNING, message, source));
        }
    }
    
    void error(const std::string& message, const std::string& source = "") {
        if (handlerChain) {
            handlerChain->handle(LogMessage(LogLevel::ERROR, message, source));
        }
    }
    
    void fatal(const std::string& message, const std::string& source = "") {
        if (handlerChain) {
            handlerChain->handle(LogMessage(LogLevel::FATAL, message, source));
        }
    }
};

// 使用示例
int main() {
    // 创建不同的日志处理者
    auto consoleHandler = std::make_shared<ConsoleLogHandler>(LogLevel::DEBUG);
    auto fileHandler = std::make_shared<FileLogHandler>(LogLevel::INFO, "app.log");
    auto emailHandler = std::make_shared<EmailLogHandler>(LogLevel::ERROR, "admin@company.com");
    auto dbHandler = std::make_shared<DatabaseLogHandler>(LogLevel::WARNING, "localhost:3306/logs");
    
    // 构建处理链
    consoleHandler->setNext(fileHandler);
    fileHandler->setNext(dbHandler);
    dbHandler->setNext(emailHandler);
    
    // 创建日志管理器
    Logger logger;
    logger.setHandlerChain(consoleHandler);
    
    std::cout << "=== 日志处理系统测试 ===\n" << std::endl;
    
    // 测试不同级别的日志
    logger.debug("调试信息：用户登录验证", "AuthService");
    std::cout << std::endl;
    
    logger.info("用户张三成功登录系统", "AuthService");
    std::cout << std::endl;
    
    logger.warning("数据库连接池使用率达到80%", "DatabasePool");
    std::cout << std::endl;
    
    logger.error("支付接口调用失败", "PaymentService");
    std::cout << std::endl;
    
    logger.fatal("系统内存不足，即将崩溃", "SystemMonitor");
    
    return 0;
}
```

![日志处理系统](../img/cpp_img/日志处理系统.png)

## 总结

### 优缺点

> 优点
>
> 1. 解耦请求与处理: 发送者和处理者解耦，请求的发送者无需知道链的结构和具体处理者，只需将请求提交到链中。
>    示例：员工请假流程中，员工只需提交请假申请，无需关心审批链的具体节点（组长→经理→总监等）。
>
> 2. 符合开闭原则: 可以动态添加、删除处理者，或调整处理顺序（灵活扩展处理链）。
>
> 3. 符合单一职责原则：每个处理者专注于自己的职责（如校验、审批、计算等），职责清晰，代码可维护性高。

> 缺点
>
> 1. 请求可能未被处理: 如果链中没有任何处理者能处理请求，且没有设置默认处理者（如链尾的 “兜底” 处理者），请求可能被忽略，导致隐性 bug。
>    解决方案：在链尾添加一个默认处理者（如 “无处理者” 提示）。
>
> 2. 调试成本较高: 请求的传递路径是动态的，可能需要跟踪整个链的调用过程，尤其当链较长时，调试难度增加。
>    缓解方法：在处理者中添加日志记录，输出请求传递的节点信息。
>
> 3. 性能可能受影响: 若链过长，请求需要遍历多个处理者，可能导致性能损耗（尤其是对实时性要求高的场景）。
>    适用场景：优先用于请求处理逻辑较简单、链长度可控的场景。

### 适用场景

1. **多个对象可以处理同一请求**：但具体由哪个对象处理在运行时确定
2. **不明确指定接收者**：希望向多个对象中的一个提交请求
3. **动态指定处理者集合**：可处理请求的对象集合需要动态指定
4. **审批流程**：如请假审批、采购审批等
5. **异常处理**：不同级别的异常需要不同的处理方式
6. **日志系统**：不同级别的日志需要不同的输出方式

### 变体模式

**1. 纯职责链**

每个处理者要么处理请求，要么传递给下一个处理者，不能同时进行

**2. 不纯职责链**

允许一个处理者处理请求后，仍然将请求传递给下一个处理者

**3. 分支职责链**

处理者可以根据条件选择不同的下一个处理者

---

职责链模式是一种强大的行为型设计模式，它通过将请求的发送者和接收者解耦，提供了一种灵活的请求处理机制。该模式特别适用于需要多级处理、审批流程、过滤器链等场景。虽然可能带来一定的性能开销，但其提供的灵活性和可扩展性使其在许多实际应用中都有重要价值。正确使用职责链模式可以使系统更加模块化、易于维护和扩展。


# 装饰器模式

## 定义
装饰器模式是一种结构型设计模式，它允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。装饰器模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。

**核心思想**

- **动态扩展功能**：在运行时动态地给对象添加额外的职责
- **替代继承**：通过组合而非继承来扩展功能
- **透明性**：装饰后的对象与原对象具有相同的接口
- **递归组合**：可以用多个装饰器装饰同一个对象

**结构组成**

**1. 抽象组件（Component）**

定义一个对象接口，可以给这些对象动态地添加职责

**2. 具体组件（ConcreteComponent）**

实现抽象组件接口的具体对象

**3. 抽象装饰器（Decorator）**

维持一个指向组件对象的引用，并定义一个与组件接口一致的接口

**4. 具体装饰器（ConcreteDecorator）**

实现具体的装饰功能，给组件添加职责

## 实现

### 咖啡订购系统

```cpp
#include <iostream>
#include <memory>
#include <string>

// 抽象组件 - 饮料接口
class Beverage {
public:
    virtual ~Beverage() = default;
    virtual std::string getDescription() const = 0;
    virtual double getCost() const = 0;
};

// 具体组件 - 浓缩咖啡
class Espresso : public Beverage {
public:
    std::string getDescription() const override {
        return "浓缩咖啡";
    }
    
    double getCost() const override {
        return 1.99;
    }
};

// 具体组件 - 深度烘焙咖啡
class DarkRoast : public Beverage {
public:
    std::string getDescription() const override {
        return "深度烘焙咖啡";
    }
    
    double getCost() const override {
        return 0.99;
    }
};

// 具体组件 - 脱咖啡因咖啡
class Decaf : public Beverage {
public:
    std::string getDescription() const override {
        return "脱咖啡因咖啡";
    }
    
    double getCost() const override {
        return 1.05;
    }
};

// 抽象装饰器
class CondimentDecorator : public Beverage {
protected:
    std::shared_ptr<Beverage> beverage;
    
public:
    CondimentDecorator(std::shared_ptr<Beverage> bev) : beverage(bev) {}
    virtual ~CondimentDecorator() = default;
};

// 具体装饰器 - 牛奶
class Milk : public CondimentDecorator {
public:
    Milk(std::shared_ptr<Beverage> bev) : CondimentDecorator(bev) {}
    
    std::string getDescription() const override {
        return beverage->getDescription() + ", 牛奶";
    }
    
    double getCost() const override {
        return beverage->getCost() + 0.10;
    }
};

// 具体装饰器 - 豆浆
class Soy : public CondimentDecorator {
public:
    Soy(std::shared_ptr<Beverage> bev) : CondimentDecorator(bev) {}
    
    std::string getDescription() const override {
        return beverage->getDescription() + ", 豆浆";
    }
    
    double getCost() const override {
        return beverage->getCost() + 0.15;
    }
};

// 具体装饰器 - 摩卡
class Mocha : public CondimentDecorator {
public:
    Mocha(std::shared_ptr<Beverage> bev) : CondimentDecorator(bev) {}
    
    std::string getDescription() const override {
        return beverage->getDescription() + ", 摩卡";
    }
    
    double getCost() const override {
        return beverage->getCost() + 0.20;
    }
};

// 具体装饰器 - 奶泡
class Whip : public CondimentDecorator {
public:
    Whip(std::shared_ptr<Beverage> bev) : CondimentDecorator(bev) {}
    
    std::string getDescription() const override {
        return beverage->getDescription() + ", 奶泡";
    }
    
    double getCost() const override {
        return beverage->getCost() + 0.10;
    }
};

// 使用示例
int main() {
    std::cout << "=== 星巴克咖啡订购系统 ===\n" << std::endl;
    
    // 订购一杯浓缩咖啡
    auto beverage1 = std::make_shared<Espresso>();
    std::cout << beverage1->getDescription() << " $" << beverage1->getCost() << std::endl;
    
    // 订购一杯深度烘焙咖啡，加双倍摩卡，加奶泡
    auto beverage2 = std::make_shared<DarkRoast>();
    beverage2 = std::make_shared<Mocha>(beverage2);
    beverage2 = std::make_shared<Mocha>(beverage2);
    beverage2 = std::make_shared<Whip>(beverage2);
    std::cout << beverage2->getDescription() << " $" << beverage2->getCost() << std::endl;
    
    // 订购一杯脱咖啡因咖啡，加豆浆，加摩卡，加奶泡
    auto beverage3 = std::make_shared<Decaf>();
    beverage3 = std::make_shared<Soy>(beverage3);
    beverage3 = std::make_shared<Mocha>(beverage3);
    beverage3 = std::make_shared<Whip>(beverage3);
    std::cout << beverage3->getDescription() << " $" << beverage3->getCost() << std::endl;
    
    return 0;
}
```

![咖啡订购系统](../img/cpp_img/咖啡订购系统.png)

### 文本处理系统

```cpp
#include <iostream>
#include <memory>
#include <string>
#include <algorithm>
#include <sstream>

// 抽象组件 - 文本处理器接口
class TextProcessor {
public:
    virtual ~TextProcessor() = default;
    virtual std::string process(const std::string& text) const = 0;
    virtual std::string getDescription() const = 0;
};

// 具体组件 - 基础文本处理器
class BasicTextProcessor : public TextProcessor {
public:
    std::string process(const std::string& text) const override {
        return text;
    }
    
    std::string getDescription() const override {
        return "基础文本";
    }
};

// 抽象装饰器
class TextDecorator : public TextProcessor {
protected:
    std::shared_ptr<TextProcessor> processor;
    
public:
    TextDecorator(std::shared_ptr<TextProcessor> proc) : processor(proc) {}
    virtual ~TextDecorator() = default;
};

// 具体装饰器 - 大写转换
class UpperCaseDecorator : public TextDecorator {
public:
    UpperCaseDecorator(std::shared_ptr<TextProcessor> proc) : TextDecorator(proc) {}
    
    std::string process(const std::string& text) const override {
        std::string processed = processor->process(text);
        std::transform(processed.begin(), processed.end(), processed.begin(), ::toupper);
        return processed;
    }
    
    std::string getDescription() const override {
        return processor->getDescription() + " -> 大写转换";
    }
};

// 具体装饰器 - 加密
class EncryptionDecorator : public TextDecorator {
private:
    int shift;
    
public:
    EncryptionDecorator(std::shared_ptr<TextProcessor> proc, int s = 3) 
        : TextDecorator(proc), shift(s) {}
    
    std::string process(const std::string& text) const override {
        std::string processed = processor->process(text);
        std::string encrypted;
        
        for (char c : processed) {
            if (std::isalpha(c)) {
                char base = std::isupper(c) ? 'A' : 'a';
                encrypted += static_cast<char>((c - base + shift) % 26 + base);
            } else {
                encrypted += c;
            }
        }
        
        return encrypted;
    }
    
    std::string getDescription() const override {
        return processor->getDescription() + " -> 凯撒加密(偏移" + std::to_string(shift) + ")";
    }
};

// 具体装饰器 - 压缩（模拟）
class CompressionDecorator : public TextDecorator {
public:
    CompressionDecorator(std::shared_ptr<TextProcessor> proc) : TextDecorator(proc) {}
    
    std::string process(const std::string& text) const override {
        std::string processed = processor->process(text);
        
        // 简单的压缩模拟：移除多余空格
        std::string compressed;
        bool lastWasSpace = false;
        
        for (char c : processed) {
            if (c == ' ') {
                if (!lastWasSpace) {
                    compressed += c;
                    lastWasSpace = true;
                }
            } else {
                compressed += c;
                lastWasSpace = false;
            }
        }
        
        return compressed;
    }
    
    std::string getDescription() const override {
        return processor->getDescription() + " -> 压缩";
    }
};

// 具体装饰器 - Base64编码（简化版）
class Base64Decorator : public TextDecorator {
public:
    Base64Decorator(std::shared_ptr<TextProcessor> proc) : TextDecorator(proc) {}
    
    std::string process(const std::string& text) const override {
        std::string processed = processor->process(text);
        
        // 简化的Base64编码模拟
        std::string encoded;
        for (size_t i = 0; i < processed.length(); ++i) {
            encoded += std::to_string(static_cast<int>(processed[i]));
            if (i < processed.length() - 1) {
                encoded += "-";
            }
        }
        
        return "[BASE64:" + encoded + "]";
    }
    
    std::string getDescription() const override {
        return processor->getDescription() + " -> Base64编码";
    }
};

// 具体装饰器 - 添加时间戳
class TimestampDecorator : public TextDecorator {
public:
    TimestampDecorator(std::shared_ptr<TextProcessor> proc) : TextDecorator(proc) {}
    
    std::string process(const std::string& text) const override {
        std::string processed = processor->process(text);
        
        // 添加简单时间戳
        auto now = std::time(nullptr);
        return "[" + std::to_string(now) + "] " + processed;
    }
    
    std::string getDescription() const override {
        return processor->getDescription() + " -> 添加时间戳";
    }
};

// 具体装饰器 - HTML格式化
class HtmlDecorator : public TextDecorator {
private:
    std::string tag;
    
public:
    HtmlDecorator(std::shared_ptr<TextProcessor> proc, const std::string& htmlTag = "p") 
        : TextDecorator(proc), tag(htmlTag) {}
    
    std::string process(const std::string& text) const override {
        std::string processed = processor->process(text);
        return "<" + tag + ">" + processed + "</" + tag + ">";
    }
    
    std::string getDescription() const override {
        return processor->getDescription() + " -> HTML格式化(" + tag + ")";
    }
};

// 文本处理管道类
class TextProcessingPipeline {
private:
    std::shared_ptr<TextProcessor> processor;
    
public:
    TextProcessingPipeline() {
        processor = std::make_shared<BasicTextProcessor>();
    }
    
    TextProcessingPipeline& addUpperCase() {
        processor = std::make_shared<UpperCaseDecorator>(processor);
        return *this;
    }
    
    TextProcessingPipeline& addEncryption(int shift = 3) {
        processor = std::make_shared<EncryptionDecorator>(processor, shift);
        return *this;
    }
    
    TextProcessingPipeline& addCompression() {
        processor = std::make_shared<CompressionDecorator>(processor);
        return *this;
    }
    
    TextProcessingPipeline& addBase64() {
        processor = std::make_shared<Base64Decorator>(processor);
        return *this;
    }
    
    TextProcessingPipeline& addTimestamp() {
        processor = std::make_shared<TimestampDecorator>(processor);
        return *this;
    }
    
    TextProcessingPipeline& addHtml(const std::string& tag = "p") {
        processor = std::make_shared<HtmlDecorator>(processor, tag);
        return *this;
    }
    
    std::string process(const std::string& text) const {
        return processor->process(text);
    }
    
    std::string getDescription() const {
        return processor->getDescription();
    }
};

// 使用示例
int main() {
    std::cout << "=== 文本处理装饰器系统 ===\n" << std::endl;
    
    std::string originalText = "Hello   World! This is a test message.";
    std::cout << "原始文本: \"" << originalText << "\"\n" << std::endl;
    
    // 示例1：基础处理
    TextProcessingPipeline pipeline1;
    std::cout << "处理管道1: " << pipeline1.getDescription() << std::endl;
    std::cout << "结果: \"" << pipeline1.process(originalText) << "\"\n" << std::endl;
    
    // 示例2：大写转换 + 压缩
    TextProcessingPipeline pipeline2;
    pipeline2.addUpperCase().addCompression();
    std::cout << "处理管道2: " << pipeline2.getDescription() << std::endl;
    std::cout << "结果: \"" << pipeline2.process(originalText) << "\"\n" << std::endl;
    
    // 示例3：压缩 + 大写 + 加密
    TextProcessingPipeline pipeline3;
    pipeline3.addCompression().addUpperCase().addEncryption(5);
    std::cout << "处理管道3: " << pipeline3.getDescription() << std::endl;
    std::cout << "结果: \"" << pipeline3.process(originalText) << "\"\n" << std::endl;
    
    // 示例4：完整处理链
    TextProcessingPipeline pipeline4;
    pipeline4.addCompression()
             .addUpperCase()
             .addTimestamp()
             .addHtml("h1");
    std::cout << "处理管道4: " << pipeline4.getDescription() << std::endl;
    std::cout << "结果: \"" << pipeline4.process(originalText) << "\"\n" << std::endl;
    
    // 示例5：Base64编码链
    TextProcessingPipeline pipeline5;
    pipeline5.addCompression().addBase64();
    std::cout << "处理管道5: " << pipeline5.getDescription() << std::endl;
    std::cout << "结果: \"" << pipeline5.process(originalText) << "\"" << std::endl;
    
    return 0;
}
```

![文本处理系统](../img/cpp_img/文本处理系统.png)

## 总结

### 优缺点

> 优点
>
> 1. 灵活性高：装饰器模式提供了比继承更灵活的扩展方式。继承是静态的，在编译时就确定了类的功能，而装饰器模式可以在运行时动态地为对象添加或移除功能。
> 2. 可维护性好：通过将不同的功能封装在不同的装饰器类中，使得代码的结构更加清晰，每个装饰器类只负责单一的功能，便于维护和修改。
> 3. 复用性强：装饰器类可以被多个对象复用，不同的装饰器还可以进行组合，以实现不同的功能组合。
> 4. 遵循开闭原则：对扩展开放，对修改关闭。可以在不修改现有代码的情况下，通过添加新的装饰器类来扩展系统的功能。

> 缺点
>
> 1. 产生过多小对象：使用装饰器模式会产生许多小对象，每个装饰器都是一个独立的类，这会增加系统的复杂性和理解难度。
> 2. 调试困难：由于装饰器的嵌套使用，可能会导致调试时难以跟踪对象的行为，特别是当装饰器链较长时。

### 适用场景

1. **动态添加功能**：需要在不修改现有代码的情况下扩展对象功能
2. **功能组合**：需要将多个功能进行组合使用
3. **避免继承爆炸**：当用继承扩展功能会导致子类数量急剧增加时
4. **临时功能**：需要临时给对象添加一些功能
5. **插件系统**：实现可插拔的功能模块
6. **数据处理管道**：构建数据处理的流水线

### 变体模式

**1. 透明装饰器**

装饰器和组件实现相同的接口

**2. 半透明装饰器**

装饰器除了实现组件接口外，还可以定义新的方法

**3. 函数式装饰器**

使用函数而非类来实现装饰功能

---

装饰器模式是一种强大的结构型设计模式，它提供了一种灵活的方式来扩展对象的功能，而无需修改其结构。该模式特别适用于需要动态添加功能、避免继承爆炸、构建处理管道等场景。虽然可能增加系统复杂性，但其提供的灵活性和可组合性使其在许多实际应用中都有重要价值。正确使用装饰器模式可以使系统更加模块化、易于扩展和维护。